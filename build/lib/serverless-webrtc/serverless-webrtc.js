// Generated by CoffeeScript 1.9.3
(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['adapter'], function() {
    var Master, Peer, SlavePeer, cfg, con;
    cfg = {
      iceServers: [
        {
          url: "stun:23.21.150.121"
        }
      ]
    };
    con = {
      optional: [
        {
          DtlsSrtpKeyAgreement: true
        }
      ]
    };
    Peer = (function() {
      function Peer() {
        this.con = new RTCPeerConnection(cfg, con);
        this.con.onsignalingstatechange = function(s) {
          return this.log('signaling state change: ', s);
        };
        this.con.oniceconnectionstatechange = function(s) {
          return this.log('ice connection state change: ', s);
        };
        this.con.onicegatheringstatechange = function(s) {
          return this.log('ice gathering state change: ', s);
        };
        this.con.onicecandidate = (function(_this) {
          return function(e) {
            _this.log("candidate", e);
            if (e.candidate === null) {
              return _this.offerReady(_this.con.localDescription);
            }
          };
        })(this);
      }

      Peer.prototype.log = function() {
        var args, msg;
        msg = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return console.log.apply(console, [this.desc + ": " + msg].concat(slice.call(args)));
      };

      Peer.prototype.useOffer = function(offerJson) {
        this.log("using offer", offerJson);
        return this.con.setRemoteDescription(new RTCSessionDescription(JSON.parse(offerJson)));
      };

      Peer.prototype.configChannel = function(chan) {
        this.chan = chan;
        this.chan.onmessage = function(e) {
          if (e.data.charCodeAt(0) === 2) {
            this.log("ignoring message '2'");
            return;
          }
          this.log("got message", e.data);
          return this.handleMessage(JSON.parse(e.data).message);
        };
        return this.chan.onopen = function(e) {
          return this.log('data channel connect');
        };
      };

      Peer.prototype.handleMessage = function(message) {
        return this.log("received message: " + message);
      };

      return Peer;

    })();
    Master = (function(superClass) {
      extend(Master, superClass);

      function Master() {
        return Master.__super__.constructor.apply(this, arguments);
      }

      Master.prototype.desc = 'Master';

      Master.prototype.createOffer = function(cont, err) {
        this.setupDataChannel();
        return this.con.createOffer(((function(_this) {
          return function(desc) {
            _this.con.setLocalDescription(desc, (function() {}), (function() {}));
            return cont(desc);
          };
        })(this)), err);
      };

      Master.prototype.offerReady = function(offer) {
        return this.log("offer ready offer: " + (JSON.stringify(offer)));
      };

      Master.prototype.setupDataChannel = function() {
        var e;
        try {
          this.configChannel(this.con.createDataChannel('test', {
            reliable: true
          }));
          return this.log("created datachannel");
        } catch (_error) {
          e = _error;
          return console.warn(this.desc + ": couldn't create data channel", e);
        }
      };

      return Master;

    })(Peer);
    return SlavePeer = (function(superClass) {
      extend(SlavePeer, superClass);

      function SlavePeer(offerJson) {}

      SlavePeer.prototype.desc = 'Slave';

      SlavePeer.prototype.prepareSlave = function(offerJson) {
        this.con.ondatachannel = function(e) {
          this.configChannel(e.channel || Math.floor(e / Chrome(sends(event, FF(sends(raw(channel)))))));
          return this.log("received datachannel", arguments);
        };
        this.useOffer(offerJson);
        return this.con.createAnswer((function(answerDesc) {
          writeToChatLog("Created local answer", "text-success");
          console.log("Created local answer: ", answerDesc);
          return this.con.setLocalDescription(answerDesc);
        }), (function() {
          return console.warn("No answer created");
        }));
      };

      SlavePeer.prototype.slaveAnswerReady = function(desc) {
        return console.log("Answer ready: " + (JSON.stringify(offer)));
      };

      return SlavePeer;

    })(Peer);
  });

}).call(this);

//# sourceMappingURL=serverless-webrtc.js.map
