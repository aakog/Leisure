// Generated by CoffeeScript 1.12.6
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['./text-operation', './wrapped-operation'], function(OT) {
    var GuardedOperation, TextOperation, WrappedOperation, guardsFromOp, isDelete, isInsert, isRetain, transform;
    TextOperation = OT.TextOperation, WrappedOperation = OT.WrappedOperation;
    isRetain = TextOperation.isRetain, isInsert = TextOperation.isInsert, isDelete = TextOperation.isDelete, transform = TextOperation.transform;
    GuardedOperation = (function(superClass) {
      extend(GuardedOperation, superClass);

      function GuardedOperation(original, guards) {
        this.original = original;
        this.guards = guards;
      }

      GuardedOperation.prototype.conflictsWith = function(operation) {
        var cursor, guardPos, i, len, nextGuardStart, nextGuardStop, op, ref;
        if (operation instanceof WrappedOperation) {
          operation = operation.wrapped;
        }
        nextGuardStart = this.guards[0];
        nextGuardStop = this.guards[1];
        guardPos = 2;
        cursor = 0;
        ref = operation.ops;
        for (i = 0, len = ref.length; i < len; i++) {
          op = ref[i];
          if (isRetain(op)) {
            cursor += op;
            while (cursor >= nextGuardStop) {
              if (guardPos >= this.guards.length) {
                return false;
              }
              nextGuardStart = this.guards[guardPos++];
              nextGuardStop = this.guards[guardPos++];
            }
          } else if (isDelete(op)) {
            cursor -= op;
            if (nextGuardStart < cursor) {
              return true;
            }
          } else if ((nextGuardStart <= cursor && cursor < nextGuardStop)) {
            return true;
          }
        }
        return false;
      };

      GuardedOperation.prototype.toGuardOp = function() {
        var cursor, end, op, pos, start;
        op = new TextOperation();
        cursor = 0;
        pos = 0;
        while (pos < this.guards.length) {
          start = this.guards[pos++];
          end = this.guards[pos++];
          if (cursor < start) {
            op.retain(start - cursor);
          }
          op.insert('x');
          if (cursor < end) {
            op.retain(end - cursor);
          }
          op.insert('x');
        }
        if (cursor < this.baseLength) {
          op.retain(this.baseLength - cursor);
        }
        return op;
      };

      GuardedOperation.prototype.transform = function(refOp) {
        var conOp, guardOp, i, len, t;
        t = WrappedOperation.transform(this.original, refOp)[0];
        guardOp = this.toGuardOp();
        for (i = 0, len = concurrentOperations.length; i < len; i++) {
          conOp = concurrentOperations[i];
          if (conOp instanceof WrappedOperation) {
            conOp = conOp.wrapped;
          }
          guardOp = transform(guardOp, conOp);
        }
        return new GuardedOperation(t, guardsFromOp(guardOp));
      };

      return GuardedOperation;

    })(WrappedOperation);
    guardsFromOp = function(op) {
      var cursor, newGuards, pos;
      newGuards = [];
      cursor = 0;
      pos = 0;
      while (pos < op.ops.length) {
        if (isRetain(op)) {
          cursor += op;
        } else if (isInsert(op)) {
          newGuards.push(cursor);
        }
      }
      return newGuards;
    };
    OT.GuardedOperation = GuardedOperation;
    OT.RejectGuardedOperation = {};
    return OT;
  });

}).call(this);

//# sourceMappingURL=guarded-operation.js.map
