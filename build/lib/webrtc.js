// Generated by CoffeeScript 1.12.4
(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['./webrtc-adapter'], function() {
    var MasterConnection, PeerConnection, SlaveConnection, cfg, con;
    cfg = {
      iceServers: [
        {
          url: "stun:23.21.150.121"
        }, {
          url: 'turn:numb.viagenie.ca',
          credential: 'muazkh',
          username: 'webrtc@live.com'
        }
      ]
    };
    con = {
      optional: [
        {
          DtlsSrtpKeyAgreement: true
        }
      ]
    };
    PeerConnection = (function() {
      function PeerConnection(arg) {
        var connected, handleMessage, offerReady;
        connected = arg.connected, handleMessage = arg.handleMessage, offerReady = arg.offerReady;
        if (!offerReady || !handleMessage) {
          throw new Error("Missing handlers " + this.desc);
        }
        this.con = new RTCPeerConnection(cfg, con);
        this.con.onsignalingstatechange = (function(_this) {
          return function(s) {
            return _this.log('signaling state change: ', s);
          };
        })(this);
        this.con.oniceconnectionstatechange = (function(_this) {
          return function(s) {
            return _this.log('ice connection state change: ', s);
          };
        })(this);
        this.con.onicegatheringstatechange = (function(_this) {
          return function(s) {
            return _this.log('ice gathering state change: ', s);
          };
        })(this);
        this.con.onicecandidate = (function(_this) {
          return function(e) {
            if (e.candidate === null) {
              return _this.offerReady(_this.con.localDescription);
            } else {
              return _this.log("candidate", e);
            }
          };
        })(this);
        this.connected = connected;
        this.handleMessage = handleMessage;
        this.offerReady = offerReady;
      }

      PeerConnection.prototype.log = function() {
        var args, msg;
        msg = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return console.log.apply(console, [this.desc + ": " + msg].concat(slice.call(args)));
      };

      PeerConnection.prototype.useOffer = function(offerJson) {
        var err, offer;
        this.log("using offer", offerJson);
        offer = null;
        try {
          offer = JSON.parse(offerJson);
        } catch (error) {
          err = error;
          throw new Error("Could not parse offer: " + offerJson);
        }
        return this.con.setRemoteDescription(new RTCSessionDescription(offer));
      };

      PeerConnection.prototype.useChannel = function(chan) {
        this.chan = chan;
        this.chan.onmessage = (function(_this) {
          return function(e) {
            if (e.data.charCodeAt(0) === 2) {
              _this.log("ignoring message '2'");
              return;
            }
            _this.log("got message", e.data);
            return _this.handleMessage(e.data);
          };
        })(this);
        return this.chan.onopen = (function(_this) {
          return function(e) {
            return _this.connected();
          };
        })(this);
      };

      PeerConnection.prototype.connected = function(e) {
        return this.log('data channel connect');
      };

      PeerConnection.prototype.sendMessage = function(msg) {
        return this.chan.send(msg);
      };

      PeerConnection.prototype.close = function() {
        return this.con.close();
      };

      return PeerConnection;

    })();
    MasterConnection = (function(superClass) {
      extend(MasterConnection, superClass);

      function MasterConnection() {
        return MasterConnection.__super__.constructor.apply(this, arguments);
      }

      MasterConnection.prototype.desc = 'Master';

      MasterConnection.prototype.start = function(errFunc) {
        var err;
        try {
          this.useChannel(this.con.createDataChannel('test', {
            reliable: true
          }));
          this.log("created datachannel");
          this.con.createOffer(((function(_this) {
            return function(desc) {
              return _this.con.setLocalDescription(desc, (function() {}), (function() {}));
            };
          })(this)), errFunc);
          return this;
        } catch (error) {
          err = error;
          err.message = "Could not start connection: " + err.message;
          return errFunc(err);
        }
      };

      MasterConnection.prototype.establishConnection = function(slaveAnswerJSON) {
        var answer, err;
        answer = null;
        try {
          answer = JSON.parse(slaveAnswerJSON);
        } catch (error) {
          err = error;
          throw new Error("Could not parse answer: " + slaveAnswerJSON);
        }
        return this.con.setRemoteDescription(new RTCSessionDescription(answer));
      };

      return MasterConnection;

    })(PeerConnection);
    SlaveConnection = (function(superClass) {
      extend(SlaveConnection, superClass);

      function SlaveConnection() {
        return SlaveConnection.__super__.constructor.apply(this, arguments);
      }

      SlaveConnection.prototype.desc = 'Slave';

      SlaveConnection.prototype.start = function(offerJson, errFunc) {
        var err;
        try {
          this.con.ondatachannel = (function(_this) {
            return function(e) {
              _this.useChannel(e.channel || Math.floor(e / (Chrome(sends(event, FF(sends(raw(channel))))))));
              return _this.connected(e);
            };
          })(this);
          this.useOffer(offerJson);
          this.con.createAnswer(((function(_this) {
            return function(answerDesc) {
              return _this.con.setLocalDescription(answerDesc, (function() {}), (function() {}));
            };
          })(this)), errFunc);
          return this;
        } catch (error) {
          err = error;
          err.message = "Could not start connection: " + err.message;
          return errFunc(err);
        }
      };

      return SlaveConnection;

    })(PeerConnection);
    return {
      PeerConnection: PeerConnection,
      MasterConnection: MasterConnection,
      SlaveConnection: SlaveConnection
    };
  });

}).call(this);

//# sourceMappingURL=webrtc.js.map
