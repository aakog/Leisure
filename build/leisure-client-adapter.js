// Generated by CoffeeScript 2.2.4
(function() {
  // Leisure Cliient Adapter
  // =======================
  // Copyright (C) 2015, Bill Burdick, Roy Riggs, TEAM CTHULHU

  // Peer-to-peer connection between Leisure instances.  They send "final"
  // document changes to each other, meaning that all document computations
  // are complete and only the document changes need be replicated.

  // Licensed with ZLIB license.
  // =============================

  // This software is provided 'as-is', without any express or implied
  // warranty. In no event will the authors be held liable for any damages
  // arising from the use of this software.

  // Permission is granted to anyone to use this software for any purpose,
  // including commercial applications, and to alter it and redistribute it
  // freely, subject to the following restrictions:

  // 1. The origin of this software must not be misrepresented; you must not
  // claim that you wrote the original software. If you use this software
  // in a product, an acknowledgment in the product documentation would be
  // appreciated but is not required.

  // 2. Altered source versions must be plainly marked as such, and must not be
  // misrepresented as being the original software.

  // 3. This notice may not be removed or altered from any source distribution.
  'use strict';
  var slice = [].slice;

  define(['jquery', 'immutable', './utilities', './editor', './editorSupport', 'sockjs', './advice', './common', 'bluebird', 'lib/ot/ot', './replacements'], function(jq, immutable, Utilities, Editor, Support, SockJS, Advice, Common, Bluebird, OT, Rep) {
    var DataStore, EditorClient, Map, OrgData, Peer, Promise, Replacements, Selection, Set, TextOperation, afterMethod, ajaxGet, basicDataFilter, beforeMethod, blockText, callOriginal, changeAdvice, computeNewStructure, configureOpts, diag, editorToolbar, fileTypes, getDocumentParams, isDelete, isInsert, isRetain, makeImageBlob, noTrim, preserveSelection, randomUserName, replacementFor, replacements, typeForFile;
    ({Map, Set} = window.Immutable = immutable);
    ({ajaxGet} = Utilities);
    ({DataStore, preserveSelection, blockText, computeNewStructure} = Editor);
    ({OrgData, getDocumentParams, editorToolbar, basicDataFilter, replacementFor, makeImageBlob} = Support);
    ({changeAdvice, afterMethod, beforeMethod, callOriginal} = Advice);
    ({noTrim} = Common);
    ({Promise} = Bluebird);
    ({TextOperation, Selection, EditorClient} = OT);
    ({isRetain, isInsert, isDelete} = TextOperation);
    ({Replacements, replacements} = Rep);
    fileTypes = {
      jpg: 'image/jpeg',
      png: 'image/png',
      gif: 'image/gif',
      bmp: 'image/bmp',
      xpm: 'image/xpm',
      svg: 'image/svg+xml'
    };
    diag = function(...args) {
      return console.log(...args);
    };
    Peer = (function() {
      // Peer is the top-level object for a peer-to-peer-capable Leisure instance.
      class Peer {
        constructor() {
          this.data = new OrgData();
          this.namd = randomUserName();
          this.guardedChangeId = 0;
          this.guardPromises = {};
        }

        setEditor(editor) {
          this.editor = editor;
        }

        disconnect() {
          var ref;
          if ((ref = this.con) != null) {
            ref.close();
          }
          return this.con = null;
        }

        connect(url, connectedFunc1) {
          var opened, peer;
          this.url = url;
          this.connectedFunc = connectedFunc1;
          console.log("CONNECTED");
          this.con = new SockJS(this.url);
          opened = false;
          new Promise((resolve, reject) => {
            this.con.onopen = () => {
              opened = true;
              this.con.onerror = () => {
                return this.closed();
              };
              return resolve();
            };
            return this.con.onerror = function() {
              if (!openend) {
                return reject();
              }
            };
          });
          this.con.onmessage = (msg) => {
            return this.handleMessage(JSON.parse(msg.data));
          };
          this.con.onclose = () => {
            return this.closed();
          };
          peer = this;
          this.editor.options.data.peer = this;
          configureOpts(this.editor.options);
          return this.editor.on('selection', () => {
            return this.getSelection();
          });
        }

        opFor({start, end, text}, length) {
          var op;
          op = new TextOperation();
          if (start > 0) {
            op = op.retain(start);
          }
          if (end > start) {
            op = op.delete(end - start);
          }
          if (text.length) {
            op = op.insert(text);
          }
          if (length > end) {
            op = op.retain(length - end);
          }
          return op;
        }

        opsFor(repls, totalLength) {
          if (repls instanceof Replacements) {
            return this.baseOpsFor(totalLength, function(f) {
              var length, offset, results, t, text;
              t = repls.replacements;
              results = [];
              while (!t.isEmpty()) {
                ({offset, length, text} = t.peekFirst());
                t = t.removeFirst();
                results.push(f(offset, length, text));
              }
              return results;
            });
          } else if (_.isArray(repls)) {
            return this.baseOpsFor(totalLength, function(f) {
              var j, last, repl, results;
              last = 0;
              results = [];
              for (j = repls.length - 1; j >= 0; j += -1) {
                repl = repls[j];
                f(repl.start - last, repl.end - repl.start, repl.text);
                results.push(last = repl.end);
              }
              return results;
            });
          }
        }

        baseOpsFor(totalLength, iterate) {
          var cursor, op;
          op = new TextOperation();
          cursor = 0;
          iterate(function(offset, length, text) {
            if (offset > 0) {
              op = op.retain(offset);
            }
            if (length > 0) {
              op = op.delete(length);
            }
            if (text.length) {
              op = op.insert(text);
            }
            return cursor += offset + length;
          });
          if (totalLength > cursor) {
            op = op.retain(totalLength - cursor);
          }
          return op;
        }

        inverseOpFor({start, end, text}, len) {
          return this.opFor({
            start: start,
            end: start + text.length,
            text: this.data.getDocSubstring(start, end)
          }, len);
        }

        close() {
          console.log(`CLOSING: ${this.type}`);
          return this.con.close();
        }

        closed() {
          return changeAdvice(this.editor.options, false, {
            changesFor: {
              p2p: true
            },
            doCollaboratively: {
              p2p: true
            }
          });
        }

        send(type, msg) {
          msg.type = type;
          //diag "SEND #{JSON.stringify msg}"
          return this.con.send(JSON.stringify(msg));
        }

        handleMessage(msg) {
          if (!(msg.type in this.handler)) {
            console.log(`Received bad message ${msg.type}`, msg);
            return this.close();
          } else {
            return this.handler[msg.type].call(this, msg);
          }
        }

        finishConnected({
            id: id1,
            peers,
            revision
          }) {
          this.id = id1;
          this.editorClient = new EditorClient(revision, peers, this, this);
          this.newConnectionFunc(_.size(this.editorClient.clients));
          if (typeof this.connectedFunc === "function") {
            this.connectedFunc(this);
          }
          return this.connectedFunc = null;
        }

        createSession(host, connectedFunc, newConnectionFunc) {
          var peer, ref;
          this.host = host;
          this.newConnectionFunc = newConnectionFunc;
          peer = this;
          this.type = 'Master';
          this.newConnectionFunc = (ref = this.newConnectionFunc) != null ? ref : function() {};
          this.handler = {
            __proto__: Peer.prototype.handler,
            connected: function(msg) {
              this.guid = msg.guid;
              this.connectUrl = new URL(`join-${this.guid}`, this.url);
              this.editorClient = new EditorClient(0, {}, this, this);
              return this.finishConnected(msg);
            },
            slaveConnect: function(msg) {
              return this.send('slaveApproval', {
                slaveId: msg.slaveId,
                approval: true
              });
            },
            slaveDisconnect: function(msg) {},
            requestFile: function({slaveId, filename, id}) {
              return this.editor.options.data.getFile(filename, ((content) => {
                return this.send('fileContent', {
                  slaveId,
                  id,
                  content: btoa(content)
                });
              }), (function(failure) {
                return this.send('fileError', {slaveId, id, failure});
              }));
            },
            customMessage: function({name, args, slaveId, msgId}) {
              return peer.editor.options._runCollaborativeCode(name, slaveId, args).then((result) => {
                return this.send('customResponse', {slaveId, msgId, result});
              }).catch((err) => {
                console.error(`Error with custom message name: ${name}, slaveId: ${slaveId}, msgId: ${msgId}\n${err.stack}`);
                return this.send('customError', {
                  slaveId,
                  msgId,
                  err: err.stack
                });
              });
            }
          };
          this.connect(`http://${this.host}/Leisure/create`, () => {
            this.send('initDoc', {
              doc: this.data.getText(),
              name: this.name
            });
            this.docSnap = this.data.getText();
            return connectedFunc();
          });
          return this.docSnap = this.data.getText();
        }

        connectToSession(url, connected, newConnectionFunc) {
          var customMessageCount, fileRequestCount, getFile, peer, pendingRequests, ref;
          this.url = url;
          this.newConnectionFunc = newConnectionFunc;
          this.type = 'Slave';
          this.newConnectionFunc = (ref = this.newConnectionFunc) != null ? ref : function() {};
          this.localResources = {};
          this.imgCount = 0;
          fileRequestCount = 0;
          customMessageCount = 0;
          pendingRequests = new Map();
          peer = this;
          getFile = function(filename, cont, fail) {
            var p;
            p = new Promise(function(success, failure) {
              var id;
              id = `request-${fileRequestCount++}`;
              pendingRequests = pendingRequests.set(id, [success, failure]);
              return peer.send('requestFile', {id, filename});
            });
            if (cont || fail) {
              return p.then(cont, fail);
            } else {
              return p;
            }
          };
          changeAdvice(this.editor.options.data, true, {
            getFile: {
              p2p: function(parent) {
                return getFile;
              }
            }
          });
          Leisure.localActivateScripts(this.editor.options);
          changeAdvice(this.editor.options, true, {
            imageError: {
              p2p: function(parent) {
                return function(img, e) {
                  var name, ref1, ref2, src;
                  src = img.getAttribute('src');
                  if (!src.match('^.*:.*')) {
                    name = (ref1 = src.match(/([^#?]*)([#?].*)?$/)) != null ? ref1[1] : void 0;
                    src = `${src}`;
                  } else {
                    name = (ref2 = src.match(/^file:([^#?]*)([#?].*)?$/)) != null ? ref2[1] : void 0;
                  }
                  if (name) {
                    if (!img.id) {
                      img.id = `p2p-image-${peer.imgCount++}`;
                    }
                    img.src = '';
                    return peer.fetchImage(img.id, src);
                  }
                };
              }
            },
            doCollaboratively: {
              p2p: function(parent) {
                return function(name, args) {
                  return peer.sendCustom(name, args);
                };
              }
            }
          });
          this.fetchImage = function(imgId, src) {
            var data, img;
            if (img = $(`#${imgId}`)[0]) {
              if (data = this.localResources[src]) {
                if (data instanceof Promise) {
                  return data.then((data) => {
                    return this.replaceImage(img, src, data);
                  });
                } else {
                  return preserveSelection((range) => {
                    return this.replaceImage(img, src, data);
                  });
                }
              } else {
                return this.localResources[src] = new Promise((resolve, reject) => {
                  return getFile(src, ((file) => {
                    data = this.localResources[src] = makeImageBlob(src, file);
                    preserveSelection((range) => {
                      return this.replaceImage(img, src, data);
                    });
                    return resolve(data);
                  }), reject);
                });
              }
            }
          };
          this.replaceImage = function(img, src, data) {
            return setTimeout((() => {
              return img.src = data;
            //img.onload = =>
            }), 0);
          };
          this.pendingCustomMessages = {};
          this.handler = {
            __proto__: Peer.prototype.handler,
            connected: function(msg) {
              this.finishConnected(msg);
              this.editor.options.load('shared', msg.doc);
              return this.docSnap = msg.doc;
            },
            fileContent: function({id, content}) {
              var cont;
              [cont] = pendingRequests.get(id);
              pendingRequests = pendingRequests.remove(id);
              return cont(atob(content));
            },
            fileError: function({id, failure}) {
              var cont, fail;
              [cont, fail] = pendingRequests.get(id);
              pendingRequests = pendingRequests.remove(id);
              return fail(failure);
            },
            customResponse: function({msgId, result}) {
              var success;
              [success] = this.pendingCustomMessages[msgId];
              delete this.pendingCustomMessages[msgId];
              return success(result);
            },
            customError: function({msgId, err}) {
              var failure, ref1;
              ref1 = this.pendingCustomMessages[msgId], [failure] = slice.call(ref1, -1);
              delete this.pendingCustomMessages[msgId];
              return failure(err);
            }
          };
          this.sendCustom = function(name, args) {
            return new Promise((succeed, fail) => {
              var msgId;
              msgId = `custom-${customMessageCount++}`;
              this.pendingCustomMessages[msgId] = [succeed, fail];
              return this.send('customMessage', {name, args, msgId});
            });
          };
          return this.connect(this.url, () => {
            this.send('intro', {
              name: this.name
            });
            return typeof connected === "function" ? connected() : void 0;
          });
        }

        replsForTextOp(textOp) {
          var cursor, j, len1, op, popLastEmpty, ref, repls;
          repls = [];
          popLastEmpty = function() {
            var r;
            if ((r = _.last(repls)) && r.start === r.end && r.text.length === 0) {
              return repls.pop();
            }
          };
          cursor = 0;
          ref = textOp.ops;
          for (j = 0, len1 = ref.length; j < len1; j++) {
            op = ref[j];
            if (isRetain(op)) {
              cursor += op;
              popLastEmpty();
              repls.push({
                start: cursor,
                end: cursor,
                text: ''
              });
            } else if (isDelete(op)) {
              cursor -= op;
              _.last(repls).end = cursor;
            } else {
              _.last(repls).text += op;
            }
          }
          popLastEmpty();
          //console.log "INCOMING REPLACE: #{JSON.stringify repls}"
          return repls;
        }

        replaceText(start, end, text) {
          return this.data.replaceText({
            start,
            end,
            text,
            source: 'peer'
          });
        }

        // OT API
        registerCallbacks(cb) {
          if (cb.client_left) {
            return this.serverCallbacks = cb;
          } else {
            return this.editorCallbacks = cb;
          }
        }

        // EditorAdapter methods
        registerUndo(undoFunc) {
          this.undoFunc = undoFunc;
        }

        registerRedo(redoFunc) {
          this.redoFunc = redoFunc;
        }

        getValue() {
          return this.data.getText();
        }

        applyOperation(op) {
          return preserveSelection((sel) => {
            var j, ref, repl;
            if (sel.type !== 'None') {
              this.data.addMark('selStart', sel.start);
              this.data.addMark('selEnd', sel.start + sel.length);
            }
            ref = this.replsForTextOp(op);
            for (j = ref.length - 1; j >= 0; j += -1) {
              repl = ref[j];
              this.replaceText(repl.start, repl.end, repl.text);
            }
            if (sel.type !== 'None') {
              sel.start = this.data.getMarkLocation('selStart');
              sel.length = this.data.getMarkLocation('selEnd') - sel.start;
              this.data.removeMark('selStart');
              return this.data.removeMark('selEnd');
            }
          });
        }

        getSelection() {
          var newSel, sel;
          sel = this.editor.getSelectedDocRange();
          newSel = sel.type === 'Caret' ? Selection.createCursor(sel.start) : sel.type === 'Range' ? new Selection([new Selection.Range(sel.start, sel.start + sel.length)]) : new Selection();
          newSel.scrollTop = sel.scrollTop;
          newSel.scrollLeft = sel.scrollLeft;
          return newSel;
        }

        setSelection(sel) {
          if (sel.ranges.length) {
            return this.editor.selectDocRange({
              start: sel.ranges[0].start,
              length: sel.ranges[0].end - sel.ranges[0].start,
              scrollTop: sel.scrollTop,
              scrollLeft: sel.scrollLeft
            });
          }
        }

        setOtherSelection(sel, color, id) {
          //$(".selection-#{id}").remove()
          return console.log(`OTHER SELECTION: ${JSON.stringify(sel)}`);
        }

        // ServerAdapter methods
        sendSelection(sel) {
          return this.send('selection', {
            selection: sel
          });
        }

        sendOperation(revision, operation, selection) {
          return this.send('operation', {revision, operation, selection});
        }

        sendGuardedOperation(revision, operation, guards) {
          var guardId;
          //console.log "GUARD SENT"
          guardId = `guard-${this.guardedChangeId++}`;
          this.send('guardedOperation', {
            revision,
            operation,
            guards,
            guardId,
            selection: this.editorClient.selection
          });
          return new Promise((success, failure) => {
            return this.guardPromises[guardId] = [success, failure];
          });
        }

      };

      Peer.prototype.type = 'Unknown Handler';

      Peer.prototype.handler = {
        log: function(msg) {
          return console.log(msg.msg);
        },
        connection: function({peerId, peerName}) {
          this.serverCallbacks.set_name(peerId, peerName);
          return this.newConnectionFunc(_.size(this.editorClient.clients));
        },
        disconnection: function({peerId}) {
          this.serverCallbacks.client_left(peerId);
          return this.newConnectionFunc(_.size(this.editorClient.clients));
        },
        error: function(msg) {
          console.log(`Received error: ${msg.error}`, msg);
          return this.close();
        },
        ack: function() {
          return this.serverCallbacks.ack();
        },
        ackGuard: function({guardId, operation}) {
          this.guardPromises[guardId][0](operation);
          return delete this.guardPromises[guardId];
        },
        rejectGuard: function(ack) {
          this.guardPromises[ack.guardId][1](ack);
          return delete this.guardPromises[ack.guardId];
        },
        operation: function({peerId, operation, meta}) {
          this.fromServer = true;
          this.editor.options.data.allowObservation(() => {
            return this.serverCallbacks.operation(operation);
          });
          this.fromServer = false;
          return this.serverCallbacks.selection(peerId, meta);
        },
        selection: function({peerId, selection}) {
          return this.serverCallbacks.selection(selection);
        },
        setName: function({peerId, name}) {
          this.serverCallbacks.set_name(peerId, name);
          return this.newConnectionFunc(_.size(this.editorClient.clients));
        }
      };

      return Peer;

    }).call(this);
    typeForFile = function(name) {
      var ext, ignore;
      [ignore, ext] = name.match(/\.([^#.]*)(#.*)?$/);
      return fileTypes[ext];
    };
    configureOpts = function(opts) {
      var data, peer;
      data = opts.data;
      if (!data.peer) {
        return;
      }
      peer = data.peer;
      return changeAdvice(data, true, {
        replaceText: {
          p2p: function(parent) {
            return function(repl) {
              var end, newLen, oldLen, start, text;
              if (repl.source !== 'peer') {
                oldLen = this.getLength();
                ({start, end, text} = repl);
                newLen = oldLen + text.length - end + start;
                peer.editorCallbacks.change(peer.opFor(repl, oldLen), peer.inverseOpFor(repl, newLen));
              }
              return parent(repl);
            };
          }
        }
      });
    };
    window.randomUserName = randomUserName = function(done) {
      var a, i;
      a = 'a'.charCodeAt(0);
      return 'user' + ((function() {
        var j, results;
        results = [];
        for (i = j = 0; j < 10; i = ++j) {
          results.push(String.fromCharCode(a + Math.floor(Math.random() * 26)));
        }
        return results;
      })()).join;
    };
    Object.assign(Leisure, {
      configurePeerOpts: configureOpts
    });
    return {Peer};
  });

}).call(this);

//# sourceMappingURL=leisure-client-adapter.js.map
