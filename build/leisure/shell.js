// Generated by CoffeeScript 2.3.0
(function() {
  // Shell support for Leisure. Runs in Node.js

  // If a line begins with a string that is unevaluable
  // * try executing it as a shell command
  // * pass any unevaluable arguments that are strings through verbatim
  var Nil, asBool, booleanFor, defaultEnv, define, detoken, evalInput, execFileSync, inErr, lazy, lz, newCall, replEnv, resolve, rz, show, trimLastNl;

  ({execFileSync} = require('child_process'));

  ({define, booleanFor} = Leisure.Runtime);

  ({newCall, resolve, lazy, defaultEnv, replEnv, show, evalInput} = Leisure.Base);

  ({Nil} = Leisure.Ast);

  rz = resolve;

  lz = lazy;

  inErr = false;

  global.handleError = function(err, cont, text, source) {
    var err2;
    if (inErr) {
      throw err;
    }
    inErr = true;
    try {
      return cont(evalInput(`e[${text}]`, show));
    } catch (error) {
      err2 = error;
      if (err2.status && err2.stderr) {
        return cont(`ERR ${trimLastNl(err2.stderr.toString())}`);
      } else {
        console.log("Shell ERROR:", err, text);
        return cont('');
      }
    } finally {
      inErr = false;
    }
  };

  trimLastNl = function(str) {
    if (str[str.length - 1] === '\n') {
      return str.substring(0, str.length - 1);
    } else {
      return str;
    }
  };

  asBool = function(bool) {
    return bool instanceof Leisure_true;
  };

  define('exec', function(list) {
    var arg, err, err2, fargs, res, t;
    if (res = L_checkPartial(L_exec, arguments)) {
      return res;
    } else {
      list = rz(list);
      fargs = [];
      while (list instanceof Leisure_cons) {
        t = L_head(list);
        arg = null;
        err = null;
        try {
          arg = evalInput(detoken(t), show, true);
        } catch (error) {
          err2 = error;
          err = err2;
        }
        if (arg == null) {
          arg = (function() {
            if (typeof t === 'string') {
              return t;
            } else if (t instanceof Leisure_token) {
              return L_tokenString(t);
            } else if (err) {
              throw err;
            }
          })();
        }
        fargs.push(arg);
        list = L_tail(list);
      }
      try {
        return trimLastNl(execFileSync.call(null, fargs[0], fargs.slice(1), {
          stdio: 'pipe'
        }).toString());
      } catch (error) {
        err = error;
        if (err.stderr) {
          return trimLastNl(err.stderr.toString());
        } else {
          throw err;
        }
      }
    }
  });

  detoken = function(toks) {
    if (toks instanceof Leisure_cons) {
      return `(${toks.map(detoken).join(' ')})`;
    } else {
      return L_strTokenString(toks);
    }
  };

  evalInput("stringify s = s[\"'\" s \"'\"]", identity);

  evalInput("destructure toks = isCons toks\n  toks\n    \\h t D . ['cons' (destructure h) (destructure t)]\n    'nil'\n  isNil toks\n    'nil'\n    isToken toks\n      toks \\t p . p \\fil ln off . ['token' (stringify t) ['filepos' (stringify fil) ln off]]\n      isParens toks\n        toks \\s e c . ['parens' s e (destructure c)]\n        isString toks\n          stringify toks\n          toks", identity);

  evalInput("rewriteFlags list = isCons list\n  do\n    n = handleDash list\n    isNil n\n      do\n        x <- flat list\n        n = handleDash x\n        isNil n\n          [(rewriteFlags x)]\n          n\n      n\n  isNil list\n    nil\n    list", identity);

  evalInput("handleDash list = do\n  a1 = head list\n  a1Pos = tokenFilepos a1\n  a1Line = fileposLine a1Pos\n  a1Off = fileposOffset a1Pos\n  a2 = second list\n  a2D = handleDash a2\n  a2F = isNil a2D a2 a2D\n  a3 = third list\n  a3Str = tokenString a3\n  a3Pos = tokenFilepos a3\n  a3Line = fileposLine a3Pos\n  a3Off = fileposOffset a3Pos\n  and[\n    isCons list\n    (consLength list) == 3\n    isToken a1\n    isToken a3\n    isTokenString a1 '-'\n    a1Line == a3Line\n    a1Off + 1 == a3Off]\n    a2F == a2D\n      append a2F [s['-' a3Str]]\n      [a2F s['-' a3Str]]\n    []", identity);

  evalInput("defMacro 'e[' \\list . ['exec' (destructure (rewriteFlags (head (stripNesting list))))]", identity);

  evalInput("defTokenPack 'shell' [[] ['e[':']'] []]", identity);

  evalInput("addStdTokenPacks ['shell']", identity);

}).call(this);

//# sourceMappingURL=shell.js.map
