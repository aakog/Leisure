# primitives
#
# eq a b -> true if they are equal or false otherwise
#
# getType value -> an option containing the type
#
# is value type -> true if the value has type type, false otherwise
#
# eval ast -> evaluates ast and returns the result
#
# parse string -> an Either with ast or error msg (give it two functions)
#
# pretty value -> pretty print a value
#
# funcSource func -> option with function's src or none if no source (e.g. primitive or lambda)
#
#    MONADS
#
# bind m binding -> monadically transform a value with a function and continue with result of function
#
# print string -> print a string and continue with false
#
# prompt string -> ask user for input and continue with value
#
# return value -> continus with value
#
# js string -> run JS code and continue with value
#
# createS -> create a new state variable and continue with it
#
# getS var -> get the value from the state variable var and continue with it
#
# setS var val -> set the state variable var to val and continue with false
#
#    STRING functions
#
# concat list -> string
#
#    AST-constructors
#
# lit value -> a lit AST node, containing value
#
# ref var-name -> a ref AST node, containing var-name
#
# lambda var-name body-ast -> a lambda AST node, with var-name and the body AST
#
# apply func-ast body-ast -> an apply AST node, with func and body ASTs
#
# prim arg rest-ast -> a prim AST node, rest-ast should either be a ref or a prim
#
#    List functions
#
# MORE DOCUMETATION NEEDED :)
#

########################
## convenience functions
########################

defMacro 'write[' \list . ['write' ['strCat' [(listify (head list))]]]

addTokenGroup 'write[' ']'

defMacro 's[' \list . ['strCat' [(listify (head list))]]

addTokenGroup 's[' ']'

defMacro 'err[' \list . ['err' ['strCat' [(listify (head list))]]]

addTokenGroup 'err[' ']'

######
##
######

afetch k alist  = alist (\h t D . h \key value . eq key k value (afetch k t)) nil

#TODO a when macro would be nice inside do, instead of using caseResult, below
#but this old definition doesn't do it right
#defMacro 'when' \line . line \cond rest . [cond 'do':rest 'nil']

addTokenGroup 'js[' ']'

defMacro 'js[' \list . ['js' ['strCat' ['flatten' [(listify (head list))]]]]

html x = \f . f x
getHtml x = x \h . h

# numerics

iszero = eq 0
positive = 0 <

addToken '--'
addToken '++'

-- = (flip (-)) 1
++ = (1 +)

# Strings
intercalate x l = strCat (intersperse x l)
string = show

# Simplification
visit func l = \\
  result = func func l
  .
  isCons result
    result \h t . cons (visit func h) (visit func t)
    result

stripNesting l = isCons l
  l \h t . (isCons h) && (isNil t)
    stripNesting h
    _map stripNesting l
  l

simplify exprString = do
  list <- scanLineM exprString
  stripNesting (visit (\func x . isToken x (tokenString x) ((isParens x) (visit func (parensContent x)) x)) list)

#######################
## Monadic values
#######################

range a b = \f . f a b

upto n = range 0 n

repeat n = \f . f n

isRepeat r = hasType r repeat

isRange r = hasType r range

runRepeat count limit f = count < limit
  [(f count) | runRepeat (count + 1) limit f]
  []

#######################
## More list stuff
#######################

all func seq = isNil seq
  true
  func (head seq)
    all func (tail seq)
    false
    

partition func list = subpartition [] func list

subpartition res func list = isNil list
  triple [] [] []
  func (head list)
    triple (_reverse res) (head list) (tail list)
    subpartition [(head list) | res] func (tail list)

findOption func list = do
  result = func (head list)
  isNil list
    none
    isNone result
      findOption func (tail list)
      result

## difference lists
differenceList = \@dataType differenceList .\@type differenceList . \x . x
dlitem item = \@type differenceList . \rest . item : rest
dlpush list item = dlappend list \rest . item : rest
dlappend a b = \@type differenceList . \rest . a (b rest)
dllist l = \@type differenceList . \rest . _append l rest

isDl x = hasType x differenceList

addTokenGroup 'append[' ']'

defMacro 'append[' \list . foldr1 (\item rest . ['append' item rest]) (head list)

addTokenGroup 'dl[' ']'

defMacro 'dl[' \list .
  ['\\@' 'type' 'differenceList' '.' '\\' 'rest' '.' (listifyDl (head list) 'rest')]

listifyDl list lvar =
  isNil list
    lvar
    partition (flip isTokenString '|') list \front middle back .
      isNil middle
        _foldl (\acc el . ['cons' el acc]) lvar (reverse list)
        _foldl (\acc el . ['cons' el acc]) [[back] lvar] (reverse front)

addTokenGroup 'map{' '}'

_declareType 'hamt' 'keyedSequence'

defMacro 'map{' \list . (listifyOp 'mapPair' (head list) 'hamt')

mapPair keyValue map = keyValue \key value . mapSet key value map

isMap h = hasType h hamt

mapFoldr func finalValue map = empty map
  finalValue
  map \h t . func h (mapFoldr func finalValue t)

toAlist map = mapFoldr aconsPair nil map

addTokenGroup 'set[' ']'

_declareType 'amtSet' 'sequence'

defMacro 'set[' \list . (listifyOp 'setAdd' (head list) 'amtSet')

isSet s = hasType s amtSet

setEmpty s = (setSize s) == 0

addTokenGroup 'vec[' ']'

_declareType 'vector' 'sequence'

defMacro 'vec[' \list . (listifyOp 'vectorUnshift' (head list) 'vector')

isVector v = hasType v vector

push = vectorPush
pop = vectorPop
shift = vectorShift
unshift = vectorUnshift

# remove any x's found in list
remove x l = removeIf (eq x) l

# remove any elements where f evals to true, f must take exactly one argument
removeIf f l = filter (compose not f) l

take n list = positive n
  list
    \h t D . cons h (take (-- n) t)
    nil
  nil

takeWhile predicate list = list
  \h t D . predicate (head list)
    cons h (takeWhile predicate t)
    nil
  nil

drop x list = positive x
  list
    \h t D . drop (-- x) t
    nil
  list

dropWhile predicate list = list
  \h t D . predicate h
    dropWhile predicate t
    list
  nil

dropLast n list = reverse (drop n (reverse list))

box n list = list == nil
  nil
  [(take n list) | box n (drop n list)]

at l x = (x == 0) (head l) (at (tail l) (-- (x) ) )

series func n = n:(series func (func n))
from n = series ++ n
fromBy n inc = series ((+) inc) n
fromTo n m = takeWhile ((>) m) (from n)
fromToBy n m inc = takeWhile ((>) m) (fromBy n inc)

# count returns the number of times x appears in l
count x l = countIf (eq x) l

# countIf returns the number of times x satifies f in l, f must take a single argument
# eg. countIf odd? [3 1] gives number: 2
countIf f l = (eq l nil) 0
  + (f (head l) 1 0) (countIf f (tail l))
countIfNot f l = countIf (\x. not (f x)) l

# list sorting
sort l = sortBy (<=) l
sortBy cmp l = mergeSort cmp l

#################
# YAML and JSON
#################

toJson obj = isString obj obj
  isKeyedSequence obj
    toJsonObject (foldr (\pair rest . pair \h t . [[(toJson h)|(toJson t)] | rest]) nil obj)
    (isSequence obj)
      toJsonArray (foldr (\item rest . [(toJson item) | rest]) nil obj)
      obj

toYaml jsonStuff = jsonToYaml (toJson jsonStuff)

#######################
## Cases
#######################

addToken '->'

mkStr tok = concat['"' (tokenString tok) '"']

defMacro 'defCase' \list . do
  h1 = head list
  t1 = tail list
  h2 = head t1
  t2 = tail t1
  h3 = head t2
  t3 = tail t2
  and[
    all isCons [list t1 t2]
    isTokenString h2 '.']
      makeCaseArgs list (mkStr h1) (mkStr h3) t3 id
      parseErr "Error in case definition -- expected func.name args | condition -> action, but got " list

makeCaseArgs orig funcName altName rest args = rest
  \h t D . isTokenString h '|'
    makeCaseCondition orig funcName altName (args nil) t id
    makeCaseArgs orig funcName altName t (dlpush args h)
  parseErr "Error in case definition -- expected func.name args | condition -> action, but got " orig

makeCaseCondition orig funcName altName args rest cond = rest
  \h t D . isTokenString h '->'
    ['bind' (_foldr1 _append [['advise' funcName altName (length args) '\\'] args ['.' (cond nil) ['some' t] 'none']]) ['\\' '_' '.' 'unit']]
    makeCaseCondition orig funcName altName args t (dlpush cond h)
 parseErr "Error in case definition -- expected func.name args | condition -> action, but got " orig

#######################
## Cases
#######################

defMacro 'defTypeCase' \list . do
  func = head list
  t1 = tail list
  dot = head t1
  t2 = tail t1
  type = head t2
  rest = tail t2
  str tok = jsonStringify (strTokenString tok) id id
  and (all isCons [list t1 t2 rest]) (isTokenString dot '.')
    partition (flip isTokenString '->') rest \args arrow body .
      isNil arrow
        parseErr s["No -> in defTypeCase: " list]
        ['_defTypeCase' (str func) (str type) ['\\@' 'arity' s[(length args)] '.' '\\' | (_append args ['.' | body])]]
    parseErr s["Not enough arguments to defTypeCase: " list]

defMacro 'declareType' \list . do
  type1 = strTokenString (head list)
  t1 = tail list
  type2 = strTokenString (head t1)
  not (isList list)
    parseErr "Extends needs 1 or 2 arguments but there were none"
    isCons t1
      ['_declareType' (jsonStringify type1 id id) (jsonStringify type2 id id)]
      ['_declareType' (jsonStringify type1 id id) 'nil']

######################
# equality
######################

#defCase equal.cons a b | and (isCons a) (isCons b) -> and
#  equal (head a) (head b)
#  equal (tail a) (tail b)

defTypeCase equal.cons a b -> and[
  isCons b
  equal (head a) (head b)
  equal (tail a) (tail b)]

######################
# sequences
######################

conj a list = cons a list

zip a b = isNil a
  nil
  isNil b
    nil
    cons (cons (head a) (head b)) (zip (tail a) (tail b))

first x = head x
nth n seq  = head (drop (max 0 n - 1) seq)
second seq = nth 2 seq
third seq  = nth 3 seq
foruth seq = nth 4 seq
fifth seq  = nth 5 seq
sixth seq  = nth 6 seq

mapchunks func list =
  empty list
    nil
    do
      r = func list
      (isSequence r) && (not (empty r))
        [(head r) | mapchunks func (tail r)]
        [r]

chunk n list = mapchunks (\l . [(take n l) | drop n l]) list

# map, but preserve the old list where possible, so that == works on it
mapSave func l = isNil l
  nil
  \\
    newH = func (head l)
    newT = mapSave func (tail l)
    .
    and (eq newH (head l)) (eq newT (tail l))
      l
      cons newH newT

### this "quicksort" is really, really slow
### so it's renamed to slowsort
slowsort less list = (qs less list) nil
# qs is written using a difference list so it can append in linear time
# sortedFunc must return whether the two args are in sorted order
# \rest . (qs ... makes a difference list.  id is the empty difference list.
qs sortedFunc list = list
  \h t D . \\
    greater = filter (sortedFunc h) t
    lesser = filter (compose not (sortedFunc h)) t
    .
    \rest . (qs sortedFunc lesser) (cons h ((qs sortedFunc greater) rest))
  id

# you can add more cases to isSequence and isKeyedSequence if you want
isSequence l = isSome (find (\f . f l) [isCons isNil isRepeat isRange isOption isEither isString isDl isMap isSet isVector])
isKeyedSequence l = isSome (find (\f . f l) [isAlist isMap])

tolist x = [x]

defCase tolist.list l | isList l -> l
defCase tolist.repeat r | isRepeat r -> runRepeat 0 (r id) id
defCase tolist.range r | isRange r -> r \a b . runRepeat a b id
defCase tolist.opt o | isOption o -> o (\x . [x]) []
defCase tolist.either e | isEither e -> e (\_ . []) (\x . [x])
defCase tolist.string s | isString s -> strToList s
defCase tolist.differenceList l | isDl l -> l []
defCase tolist.map h | isMap h -> mapPairs h
defCase tolist.set s | isSet s -> setItems s
defCase tolist.vector v | isVector v -> vectorItems v

#defTypeCase tolist.list l | isList l -> l
#defTypeCase tolist.repeat r | isRepeat r -> runRepeat 0 (r id) id
#defTypeCase tolist.range r | isRange r -> r \a b . runRepeat a b id
#defTypeCase tolist.opt o | isOption o -> o (\x . [x]) []
#defTypeCase tolist.either e | isEither e -> e (\_ . []) (\x . [x])
#defTypeCase tolist.string s | isString s -> strToList s
#defTypeCase tolist.differenceList l | isDl l -> l []
#defTypeCase tolist.map h | isMap h -> mapPairs h
#defTypeCase tolist.set s | isSet s -> setItems s
#defTypeCase tolist.vector v | isVector v -> vectorItems v

defCase conj.range v r | isRange r -> r \a b .
  b == v
    range a b + 1
    a - 1 == v
      range v a
      a < v && v < b
        r
        v < a
          [v | tolist r]
          dlpush (dllist (tolist r)) v
defCase conj.repeat v r | isRepeat r -> r \count .
  count == v
    repeat count + 1
    (0 <= v) && v < count
      r
      v < 0
        [v | tolist r]
        dlpush (dllist (tolist r)) v
defCase conj.string v s | isString s -> s + v
defCase conj.differenceList v l | isDl l -> dlpush l v
defCase conj.alist v h | (isAlist h) || (isCons v) || (!isCons (tail v)) ->
  aconsf (head v) (tail v) h
defCase conj.map v h | (isMap h) || (isCons v) || (!isCons (tail v)) ->
  mapSet (head v) (tail v) h
defCase conj.set v s | isSet s -> setAdd v s
defCase conj.vector val vec | isVector vec -> vectorPush val vec

defCase head.any x | not (isList x) -> head (tolist x)
defCase head.range r | isRange r -> r \a b . a < b a nil
defCase head.string s | isString s -> strAt s 0
defCase head.map h | isMap h -> mapFirst h
defCase head.set s | isSet s -> setFirst s
defCase head.vector v | isVector v -> vectorFirst v

defCase tail.any x | not (isList x) -> tail (tolist x)
defCase tail.range r | isRange r -> r \a b . a < b (range a + 1 b) r
defCase tail.string s | isString s -> strSubstring s 1 (strLen s)
defCase tail.differenceList l | isDl l -> dllist (tail (tolist l))
defCase tail.map h | isMap h -> mapRest h
defCase tail.set s | isSet s -> setRest s
defCase tail.vector v | isVector v -> vectorRest v

defCase length.range r | isRange r -> r \a b . b - a
defCase length.repeat r | isRepeat r -> r \count . count == 0
defCase length.string s | isString s -> strLen s
defCase length.differenceList l | isDl l -> length (tolist l)
defCase length.map h | isMap h -> mapSize h
defCase length.set s | isSet s -> setSize s
defCase length.vector v | isVector v -> vectorSize v

empty l = (length l) == 0
defCase empty.cons l | isCons l -> false
defCase empty.nil l | isNil l -> true

defCase append.any x y | not (and (isList x) (isList y)) -> _append (tolist x) (tolist y)
defCase append.range x y | and[(isRange x) (isRange y) (x \xa xb . y \ya yb . xb == ya)] ->
  x \xa xb . y \ya yb . range xa yb
defCase append.string x y | isString x -> x + y
defCase append.differenceList x y | isDl x -> dlappend x (isDl y y (dllist (tolist y)))
defCase append.map x y | and (isMap x) (isKeyedSequence y) ->
  isMap y
    mapMerge x y
    _foldr (\el result . el \k v . set k v result) x (tolist y)
defCase append.set x y | isSet x ->
  isSet y
    setUnion x y
    _foldr (\el result . setAdd el result) x (tolist y)
defCase append.vector x y | isVector x ->
  isSet y
    vectorConcat x y
    _foldr (\el result . vectorPush el result) x (tolist (vectorReverse y))

delete item list = filter (item !=) list
defCase delete.alist key alist | isAlist alist -> aremove key alist
defCase delete.set item set | isSet set -> setRemove item set
defCase delete.vector item vec | isVector vec -> vectorRemove item vec
defCase delete.map key map | isMap map -> mapRemove key map
defCase delete.differenceList item dl | isDl dl -> dllist (filter (item !=) (tolist dl))

defCase map.any func l | not (isList l) -> _map func (tolist l)
defCase map.repeat func r | isRepeat r -> runRepeat 0 (r id) func
defCase map.range func r | isRange r -> r \a b . runRepeat a b func
defCase map.opt func o | isOption o -> o (compose some func) none
defCase map.either func e | isEither e -> e (\_ . e) (compose right func)
defCase map.string func s | isString s -> strCat (_map func (strToList s))
defCase map.alist func alist | isAlist alist ->
  _foldr (\el result . set (head el) (func (tail el)) result) nil alist
defCase map.differenceList func l | isDl l -> dllist (_map func (l []))
defCase map.map func h | isMap h ->
  _foldr (\el result . set (head el) (func (tail el)) result) hamt (tolist h)
defCase map.set func s | isSet s ->
  _foldr (\el result . set (head el) (func (tail el)) result) amtSet (setItems s)
defCase map.vector func v | isVector v ->
  _foldr (\el result . vectorPush (func el) result) vector (vectorItems v)

defCase foldl.any func init l | not (isList l) -> _foldl func init (tolist l)
defCase foldl1.any func l | not (isList l) -> _foldl1 func (tolist l)
defCase foldr.any func final l | not (isList l) -> _foldr func final (tolist l)
defCase foldr.map func final m | isMap m -> mapFoldr func final m
defCase foldr1.any func l | not (isList l) -> _foldr1 func (tolist l)

defCase reverse.alist l | isAlist l -> foldr (\el rest . acons (head el) (tail el) rest) {} (_reverse l)
defCase reverse.range r | isRange r -> r
defCase reverse.repeat r | isRepeat r -> r
defCase reverse.string s | isString s -> strReverse s
defCase reverse.differenceList l | isDl l -> dllist (reverse (l []))
defCase reverse.map h | isMap h -> mapReverse h
defCase reverse.set s | isSet s -> setReverse s
defCase reverse.vector v | isVector v -> vectorReverse v

contains item l = _contains item l
defCase contains.any item l | not (isList l) -> _contains item (tolist l)
defCase contains.alist item l | isAlist l -> isSome (_find (\el . item == (head el)) l)
defCase contains.range item r | isRange r -> r \ a b . (isNumber item) && ((a <= item) || (item < b))
defCase contains.repeat item r | isRepeat r -> r \ count . (isNumber item) && ((0 <= item) || (item < count))
defCase contains.differenceList item l | isDl l -> _contains item (l [])
defCase contains.map item h | isMap h -> mapContains item h
defCase contains.set item s | isSet s -> setContains item s
defCase contains.vector item v | isVector v -> vectorContains item v

######################
# maps
######################
get key alist = find (\el . eq key (head el)) alist (\cell . cell \head tail . tail) unit
defCase get.map key h | isMap h -> mapGet key h

getOpt key alist = find (\el . eq key (head el)) alist (\cell . cell \head tail . some tail) none
defCase getOpt.map key h | isMap h -> mapGetOpt key h

set key value alist = acons key value (aremove key alist)
defCase set.map key value h | isMap h -> mapSet key value h

######################
# numbers
######################

increasing x = cons x (increasing (+ x 1))
wholes = increasing 0
naturals = tail wholes

######################
# show
######################
## Generic presentation

showBase func obj = func obj

defCase showBase.unit func obj | hasType obj unit -> ''
defCase showBase.some func obj | hasType obj some -> concat["(some " (showBase func (obj id false)) ")"]
defCase showBase.some2 func obj | hasType obj some2 -> concat["(some2 " (obj (\a b . showBase func [a ', ' b]) false) ")"]
defCase showBase.err func obj | hasType obj err -> concat["(err " (obj id) ")"]
defCase showBase.token func obj | hasType obj token -> obj \str pos .
  isFilepos pos
    pos \file line offset . concat['token ' str ' ' file ' ' line ' ' offset]
    concat['(token ' str ' ' pos ')']
defCase showBase.filepos func obj | hasType obj filepos -> obj \file line offset . concat['(filepos ' file ' ' line ' ' offset ')']
defCase showBase.cons func obj | hasType obj cons -> concatFlat['[' (showBase func (head obj)) (showConsElements func (tail obj))  ']']

showConsElements func list = isCons list
  [' ' (showBase func (head list)) (showConsElements func (tail list))]
  isNil list
    ''
    [' | ' (showBase func list)]

defCase showBase.range func obj | hasType obj range -> obj \start end .
  concat['(range ' start ' ' end ')']

defCase showBase.repeat func obj | hasType obj repeat -> concat['(repeat ' (obj id) ')']
defCase showBase.map func obj | hasType obj hamt -> concatFlat[
  'map{'
  intersperse (_map (\item . [(showBase func (head item)) ':' (showBase func (tail item))]) (mapPairs obj)) ' '
  '}']

defCase showBase.set func obj | isSet obj -> concatFlat[
  'set['
  intersperse (setItems obj) ' '
  ']']

defCase showBase.vector func obj | isVector obj -> concatFlat[
  'vec['
  intersperse (vectorItems obj) ' '
  ']']

defCase showBase.assoc func obj | (isAlist obj) && (not (isNil obj)) -> concatFlat[
  '{'
  intersperse (_map (\item . [(showBase func (head item)) ':' (showBase func (tail item))]) obj) ' '
  '}']

defCase showBase.left func obj | hasType obj left -> concat["(left " (showBase func (obj id id)) ")"]
defCase showBase.right func obj | hasType obj right -> concat["(right " (showBase func (obj id id)) ")"]
defCase showBase.differenceList func l | isDl l -> concatFlat[
  'dl['
  intersperse (_map (showBase func) (l [])) ' '
  ']']
defCase showBase.triple func obj | hasType obj triple ->
  obj \a b c . concat["(triple " (showBase func a) " " (showBase func b) " " (showBase func c) ")"]

## presentation

showHtml x = showBase presentHtml x

show x = showBase present x

present x = x

presentHtml x = escapeHtml (present x)

defCase present.string obj | (getType obj) == '*string' -> jsonStringify obj id id
defCase present.func obj | (getType obj) == '*function' -> presentFunction obj

presentFunction obj = do
  info = funcInfo obj
  guts = isNil info
    [(funcName obj
      id
      'unknown')]
    and (> (length info) 1) (getFunction (head info) (\func . hasProperty func 'infix') false)
      [(present (head (tail info))) (head info) | _map present (tail (tail info))]
      cons (head info) (_map present (tail info))
  concat["(" (join guts ' ') ")"]

defCase presentHtml.func obj | (getType obj) == '*function' ->
  concat['<span class="partial-application">' (presentFunction obj) '</span>']

defCase present.nil obj | hasType obj nil -> 'nil'

defCase present.none obj | hasType obj none -> "none"

defCase presentHtml.html obj | hasType obj html -> obj id

######################
# binding
######################
# binding false returns unit and the list binding ellides unit values from results
#
# This makes bind useful for list comprehensions, like this:
#
# do
#   x <- [1 2 3]
#   x > 1
#   x + 2

wrapped x = \f . f x

defMacro 'wrap' \list . ['wrapped' list]

defCase showBase.wrapped func v | hasType v wrapped -> concat['wrap ' (showBase func (v id))]

defCase bind.wrapped v cont | hasType v wrapped -> cont (v id)

defCase bind.bool bool cont | or (bool == true) (bool == false) -> bool
  cont true
  false

defCase bind.option opt cont | isOption opt -> log "USING OPTION BIND" opt
  \value . cont value
  none

defCase bind.either either cont | isEither either -> either
  \_ . either
  \value . cont value

defMacro 'for' \list . ['tolist' list]

defMacro 'flat' \list . ['flatWrapper' list]

flatWrapper m = \f . f m

defCase showBase.flat func v | hasType v flatWrapper -> concat['flat ' (showBase func (v id))]

defCase bind.flat fe cont | hasType fe flatWrapper -> monadicFlatMap cont (fe id)

defCase bind.list l cont | isList l -> monadicMap cont l

defCase bind.differenceList l cont | isDl l -> primBind (monadicMap cont l) \l . dllist l

# add 2-variable bind for alist and map?

fold l i = \f . f l i

defCase showBase.fold func v | hasType v fold ->
  concat['fold ' (showBase func \l i . l) (showBase func \l i . i)]

defCase bind.fold fr cont | hasType fr fold -> fr \list init .
  _foldl (\acc el . maybeBind acc \accVal . do
    ret = cont accVal el
    ret == unit
      accVal
      ret) init (tolist list)

monadicFlatMap cont list = _foldr (\el acc . maybeBind (cont el) \elVal . maybeBind acc \accVal .
  elVal == unit
    accVal
    _append elVal accVal) [] (tolist list)

monadicMap cont list = _foldr (\el acc . maybeBind (cont el) \elVal . maybeBind acc \accVal .
  elVal == unit
    accVal
    [elVal | accVal]) [] (tolist list)

maybeBind item cont = isIO item
  primBind item cont
  cont item

check condition elseResult = condition true elseResult

defCase bind.err err cont | isErr err -> err

#######################
## running
#######################

defMacro 'run' \list . ['wrappedRun' list]

wrappedRun m = \f . f m

defCase bind.wrappedRun m cont | hasType m wrappedRun -> bind (m id) \x . bind x cont

#######################
## pre/postconditions
#######################

# defWrapper func realFunc x y -> log "Calling func" realFunc x y
defMacro 'defWrapper' \list . partition (flip isTokenString '->') list \left arrow right . do
  name = concat["'" (strTokenString (head left)) "'"]
  oldName = head (tail left)
  args = tail (tail left)
  ['override' name (_append ['\\' oldName '.' '\\@' 'arity' (length args) '.' '\\' | args] ['.' | right])]

#defWrapper head oldHead list -> assertType 'head argument' cons list \h t . h
#defWrapper tail oldTail list -> assertType 'tail argument' cons list \h t . t
#defWrapper mapSet oldMapSet key value aMap -> oldMapSet
#  key
#  value
#  assertType 'mapSet map' hamt aMap

#######################
## output tag functions
#######################

html x = \f . f x

#defTokenPack 'util' [['->' '--' '++'] ['js[':']' 'write[':']' 's[':']' 'err[':']' 'dl[':']' 'map{':'}' 'set[':']' 'vec[':']' 'append[':']'] []]
#addStdTokenPacks ['util']

#####
# AST funcs
#####
_1of2 s = s \a b . a
_2of2 s = s \a b . b
_1of3 s = s \a b c . a
_2of3 s = s \a b c . b
_3of3 s = s \a b c . c
_1of4 s = s \a b c d . a
_2of4 s = s \a b c d . b
_3of4 s = s \a b c d . c
_4of4 s = s \a b c d . d
getLitValue ast = _1of2 ast
getLitRange ast = _2of2 ast
getRefName ast = _1of2 ast
getRefRange ast = _2of2 ast
getLambdaName ast = _1of3 ast
getLambdaBody ast = _2of3 ast
getLambdaRange ast = _3of3 ast
getApplyFunc ast = _1of2 ast
getApplyArg ast = _2of2 ast
getLetName ast = _1of4 ast
getLetValue ast = _2of4 ast
getLetBody ast = _3of4 ast
getLetRange ast = _4of4 ast
getAnnoName ast = _1of3 ast
getAnnoData ast = _2of3 ast
getAnnoBody ast = _3of3 ast

####
# Util funcs
####

requireJS file = primBind (getValue 'requiredFiles')
  \files . contains file files
    false
    primBind (loadJS file)
      \result . result
        \x . left x
        \_ . primBind (setValue 'requiredFiles' (cons file files))
          \_ . right true

loadJS file = primBind (readFile file)
  \result . result
    \err . err
    \contents . js contents

definitionList = do
  f <- funcList
  m <- getValue 'macroDefs'
  sort (_append f (_map head m))

eval str = do
  ast <- newParseLine 0 nil str
  ifNotErr ast (runAst ast)

########
## cond
########

tokenSrc tokens = do
  tokens = flatten (tokenList tokens)
  tokens = mapchunks (\l . [[
   tokenString (head l)
   (isNil (tail l)) '' (spacesBetween (first l) (second l))] | tail l]) tokens
  strCat (flatten tokens)

spacesBetween tok1 tok2 = tok1 \t1 p1 . tok2 \_ p2. p1 \_ l1 o1 . p2 \_ l2 o2 .
  (l1 == l2)
    strRep o2 - o1 - (length t1) ' '
    (strRep l2 - l1 '\n') + (strRep o2 ' ')

strRep n char = n <= 0 '' char + (strRep n - 1 char)

tokenList tokens = do
  isParens tokens
    tokens \start end content . [
      token '(' start
      tokenList content
      token ')' (end \f l o . filepos f l (max 0 o - 1))]
    isList tokens
      map tokenList tokens
      [tokens]

defMacro 'cond' \list .
  foldr (\l rest . do
    l = stripParens l
    not and[(isSequence l) (length l) == 2]
      error s['Bad cond format, cond expects pairs of expressions: ' (tokenSrc list)]
      [(first l) (second l) | [((empty rest) 'false' rest)]]) nil list

#############
## backquote
#############

addToken '`'
addToken '~'
addToken '~@'

defMacro '`' \list . consFromTokens (head list)

consFromTokens toks = do
  item = head toks
  rest = tail toks
  item2 = head rest
  rest2 = tail rest
  cond
    (isNil toks) 'nil'
    (isParens toks) (toks \s e c . consFromTokens c)
    (isToken toks) (stringForToken toks)
    (isString toks) (jsonStringify toks id id)
    (not (isCons toks)) toks
    (isTokenString item '~') ['cons' (stripParens item2) (consFromTokens rest2)]
    (isTokenString item '~@')
      empty rest2
        stripParens item2
        ['_append' ['tolist' (stripParens item2)] (consFromTokens rest2)]
    true ['cons' (consFromTokens item) (consFromTokens rest)]

stringForToken tok = tok \tok pos . token (jsonStringify tok id id) pos

defTokenPack 'util' [['->' '--' '++' '`' '~' '~@'] ['js[':']' 'write[':']' 's[':']' 'err[':']' 'dl[':']' 'map{':'}' 'set[':']' 'vec[':']' 'append[':']'] []]
addStdTokenPacks ['util']
