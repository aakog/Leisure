// Generated by CoffeeScript 1.9.3

/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
 */

(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['./base', './ast', 'lib/lodash.min', 'immutable', 'lib/js-yaml'], function(Base, Ast, _, Immutable, Yaml) {
    var LeisureObject, Leisure_unit, Map, Monad, Monad2, Nil, SimpyCons, _false, _identity, _true, _unit, actors, ast2Json, asyncMonad, basicCall, bind2, booleanFor, call, callBind, callMonad, cons, consFrom, continueMonads, curry, defaultEnv, define, dump, ensureLeisureClass, escapePresentationHtml, funcInfo, functionInfo, gensymCounter, getDataType, getMonadSyncMode, getType, getValue, hamt, head, identity, isMonad, isPartial, jsonConvert, lacons, lazy, lc, left, lz, makeHamt, makeMonad, makeSyncMonad, mkProto, monadModeSync, nakedDefine, nameSub, newRunMonad, newbind, nextHamtPair, nextMonad, none, nsLog, parensContent, parensEnd, parensStart, partialCall, posString, presentationReplacements, presentationToHtmlReplacements, readDir, readFile, ref, replaceErr, requireFiles, resolve, right, root, runMonad, runMonad2, rz, safeLoad, setDataType, setType, setValue, setWarnAsync, simpyCons, some, statFile, strCoord, strFromList, strToList, subcurry, tail, tokenPos, tokenString, trampCurry, unescapePresentationHtml, values, warnAsync, withSyncModeDo, writeFile;
    ref = root = Base, readFile = ref.readFile, statFile = ref.statFile, readDir = ref.readDir, writeFile = ref.writeFile, defaultEnv = ref.defaultEnv, SimpyCons = ref.SimpyCons, simpyCons = ref.simpyCons, resolve = ref.resolve, lazy = ref.lazy, nsLog = ref.nsLog, funcInfo = ref.funcInfo;
    define = Ast.define, nakedDefine = Ast.nakedDefine, cons = Ast.cons, Nil = Ast.Nil, head = Ast.head, tail = Ast.tail, getType = Ast.getType, getDataType = Ast.getDataType, ast2Json = Ast.ast2Json, ensureLeisureClass = Ast.ensureLeisureClass, LeisureObject = Ast.LeisureObject, mkProto = Ast.mkProto, setType = Ast.setType, setDataType = Ast.setDataType, functionInfo = Ast.functionInfo, nameSub = Ast.nameSub, isPartial = Ast.isPartial, partialCall = Ast.partialCall;
    Map = Immutable.Map;
    safeLoad = Yaml.safeLoad, dump = Yaml.dump;
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    gensymCounter = 0;
    call = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return basicCall(args, defaultEnv, identity);
    };
    callMonad = function() {
      var args, cont, env, j;
      args = 3 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 2) : (j = 0, []), env = arguments[j++], cont = arguments[j++];
      return basicCall(args, env, cont);
    };
    basicCall = function(args, env, cont) {
      var arg, j, len, ref1, res;
      res = rz(global["L_" + args[0]]);
      ref1 = args.slice(1);
      for (j = 0, len = ref1.length; j < len; j++) {
        arg = ref1[j];
        res = (function(arg) {
          return res(lz(arg));
        })(arg);
      }
      return runMonad(res, env, cont);
    };
    consFrom = function(array, i) {
      i = i || 0;
      if (i < array.length) {
        return cons(array[i], consFrom(array, i + 1));
      } else {
        return rz(L_nil);
      }
    };
    identity = function(x) {
      return x;
    };
    _identity = function(x) {
      return rz(x);
    };
    _unit = setType((function(x) {
      return rz(x);
    }), 'unit');
    _true = setType((function(a) {
      return function(b) {
        return rz(a);
      };
    }), 'true');
    _false = setType((function(a) {
      return function(b) {
        return rz(b);
      };
    }), 'false');
    left = function(x) {
      return setType((function(lCase) {
        return function(rCase) {
          return rz(lCase)(lz(x));
        };
      }), 'left');
    };
    right = function(x) {
      return setType((function(lCase) {
        return function(rCase) {
          return rz(rCase)(lz(x));
        };
      }), 'right');
    };
    some = function(x) {
      return setType((function(someCase) {
        return function(noneCase) {
          return rz(someCase)(lz(x));
        };
      }), 'some');
    };
    none = setType((function(someCase) {
      return function(noneCase) {
        return rz(noneCase);
      };
    }), 'none');
    define('eq', function(a, b) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(a) === rz(b));
      }
    });
    define('==', function(a, b) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(a) === rz(b));
      }
    });
    booleanFor = function(bool) {
      if (bool) {
        return rz(L_true);
      } else {
        return rz(L_false);
      }
    };
    define('hasType', function(data, func) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        if (typeof rz(func) === 'string') {
          return booleanFor(getType(rz(data)) === rz(func));
        } else {
          return booleanFor(getType(rz(data)) === getDataType(rz(func)));
        }
      }
    });
    define('getDataType', function(func) {
      if (typeof rz(func) === 'string') {
        return rz(func);
      } else {
        return getDataType(rz(func));
      }
    });
    define('assert', function(bool) {
      return function(msg) {
        return function(expr) {
          return rz(bool)(expr)(function() {
            throw new Error(rz(msg));
          });
        };
      };
    });
    define('assertLog', function(bool) {
      return function(msg) {
        return function(expr) {
          return rz(bool)(expr)(function() {
            console.log(new Error(rz(msg)).stack);
            console.log("LOGGED ERROR -- RESUMING EXECUTION...");
            return rz(expr);
          });
        };
      };
    });
    define('trace', function(msg) {
      console.log("STACKTRACE: ", new Error(rz(msg)).stack);
      return msg;
    });
    define('jsTrue', function(x) {
      if (rz(x)) {
        return _true;
      } else {
        return _false;
      }
    });
    define('error', function(msg) {
      throw new Error(rz(msg));
    });
    define('+', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) + rz(y);
      }
    });
    define('-', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) - rz(y);
      }
    });
    define('*', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) * rz(y);
      }
    });
    define('/', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) / rz(y);
      }
    });
    define('%', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) % rz(y);
      }
    });
    define('<', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) < rz(y));
      }
    });
    define('<=', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) <= rz(y));
      }
    });
    define('>', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) > rz(y));
      }
    });
    define('>=', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) >= rz(y));
      }
    });
    define('floor', function(x) {
      return Math.floor(rz(x));
    });
    define('ceil', function(x) {
      return Math.ceil(rz(x));
    });
    define('min', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return Math.min(rz(x), rz(y));
      }
    });
    define('max', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return Math.max(rz(x), rz(y));
      }
    });
    define('round', function(x) {
      return Math.round(rz(x));
    });
    define('abs', function(x) {
      return Math.abs(rz(x));
    });
    define('sqrt', function(x) {
      return Math.sqrt(rz(x));
    });
    define('acos', function(x) {
      return Math.acos(rz(x));
    });
    define('asin', function(x) {
      return Math.asin(rz(x));
    });
    define('atan', function(x) {
      return Math.atan(rz(x));
    });
    define('atan2', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return Math.atan2(rz(x), rz(y));
      }
    });
    define('cos', function(x) {
      return Math.cos(rz(x));
    });
    define('sin', function(x) {
      return Math.sin(rz(x));
    });
    define('tan', function(x) {
      return Math.tan(rz(x));
    });
    define('rand', function() {
      return makeSyncMonad(function(env, cont) {
        return cont(Math.random());
      });
    });
    define('randInt', function(low, high) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          return cont(Math.floor(rz(low) + Math.random() * rz(high)));
        });
      }
    });
    define('^', function(x, y) {
      return Math.pow(rz(x), rz(y));
    });
    define('number', function(n) {
      return Number(n);
    });
    define('_show', function(data) {
      var ref1;
      if ((ref1 = typeof rz(data)) === 'string' || ref1 === 'number' || ref1 === 'boolean') {
        return JSON.stringify(rz(data));
      } else if (getType(rz(data)) === 'err') {
        return rz(L_errMsg)(data);
      } else {
        return String(rz(data));
      }
    });
    define('strString', function(data) {
      return String(rz(data));
    });
    define('_strAsc', function(str) {
      return rz(str).charCodeAt(0);
    });
    define('_strChr', function(i) {
      return String.fromCharCode(rz(i));
    });
    define('_strAt', function(str, index) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(str)[strCoord(rz(str), rz(index))];
      }
    });
    define('_strStartsWith', function(str, prefix) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(str).substring(0, rz(prefix).length) === rz(prefix));
      }
    });
    define('_strLen', function(str) {
      return rz(str).length;
    });
    define('_strToLowerCase', function(str) {
      return rz(str).toLowerCase();
    });
    define('_strToUpperCase', function(str) {
      return rz(str).toUpperCase();
    });
    define('_strReplace', function(str, pat, repl) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(str).replace(rz(pat), rz(repl));
      }
    });
    strCoord = function(str, coord) {
      if (coord < 0) {
        return str.length + coord;
      } else {
        return coord;
      }
    };
    define('_strSubstring', function(str, start, end) {
      var a, b;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        a = strCoord(rz(str), rz(start));
        b = strCoord(rz(str), rz(end));
        if (b < a && rz(end) === 0) {
          b = rz(str).length;
        }
        return rz(str).substring(a, b);
      }
    });
    define('_strSplit', function(str, pat) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return consFrom(rz(str).split(rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
      }
    });
    define('_strCat', function(list) {
      return _.map(rz(list).toArray(), function(el) {
        if (typeof el === 'string') {
          return el;
        } else {
          return rz(L_show)(lz(el));
        }
      }).join('');
    });
    define('_strAdd', function(s1, s2) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(s1) + rz(s2);
      }
    });
    define('_strMatch', function(str, pat) {
      var groups, m, pos;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        m = rz(str).match((rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
        if (m) {
          groups = [];
          pos = 1;
          while (m[pos]) {
            groups.push(m[pos++]);
          }
          if (typeof m.index !== 'undefined') {
            return consFrom([m[0], consFrom(groups), m.index, m.input]);
          } else {
            return consFrom([m[0], consFrom(groups)]);
          }
        } else if (L_nil) {
          return rz(L_nil);
        } else {
          return Nil;
        }
      }
    });
    define('_strToList', function(str) {
      return strToList(rz(str));
    });
    strToList = function(str) {
      if (str === '') {
        return Nil;
      } else {
        return cons(str[0], strToList(str.substring(1)));
      }
    };
    define('_strFromList', function(list) {
      return strFromList(rz(list));
    });
    strFromList = function(list) {
      if (list instanceof Leisure_nil) {
        return '';
      } else {
        return head(list) + strFromList(tail(list));
      }
    };
    define('_regexp', function(str) {
      return new RegExp(rz(str));
    });
    define('_regexpFlags', function(str, flags) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new RegExp(rz(str), rz(flags));
      }
    });
    define('_jsonParse', function(str, failCont, successCont) {
      var err, p;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        try {
          p = JSON.parse(rz(str));
          return rz(successCont)(lz(p));
        } catch (_error) {
          err = _error;
          return rz(failCont)(lz(err));
        }
      }
    });
    define('jsonStringify', function(obj, failCont, successCont) {
      var err, s;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        try {
          s = JSON.stringify(rz(obj));
          return rz(successCont)(lz(s));
        } catch (_error) {
          err = _error;
          return rz(failCont)(lz(err));
        }
      }
    });
    define('getProperties', function(func) {
      var ref1;
      if ((ref1 = rz(func)) != null ? ref1.properties : void 0) {
        return rz(func).properties;
      } else {
        return rz(L_nil);
      }
    });
    define('setProperty', function(func, name, value) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var f, ref1;
          f = rz(func);
          f.properties = rz(L_aconsf)(name, value, lz((ref1 = f.properties) != null ? ref1 : rz(L_nil)));
          return cont(f.properties);
        });
      }
    });
    define('log', function(str, res) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        console.log(String(rz(str)));
        return rz(res);
      }
    });
    define('logStack', function(str, res) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        console.log(new Error(rz(str)).stack);
        return rz(res);
      }
    });
    define('breakpoint', function(x) {
      console.log('Break point ', rz(x));
      return rz(x);
    });
    makeMonad = function(guts) {
      var m;
      m = function() {
        throw new Error("ILLEGAL CALL TO MONAD FUNCTION!");
      };
      m.__proto__ = Monad.prototype;
      m.cmd = guts;
      m.type = 'monad';
      return m;
    };
    makeSyncMonad = function(guts) {
      var m;
      m = makeMonad(guts);
      m.sync = true;
      return m;
    };
    nextMonad = function(cont) {
      return cont;
    };
    replaceErr = function(err, msg) {
      err.message = msg;
      return err;
    };
    defaultEnv.write = function(str) {
      return process.stdout.write(str);
    };
    defaultEnv.err = function(err) {
      var ref1;
      return this.write("ENV Error: " + ((ref1 = err.stack) != null ? ref1 : err));
    };
    defaultEnv.prompt = function() {
      throw new Error("Environment does not support prompting!");
    };
    monadModeSync = false;
    getMonadSyncMode = function() {
      return monadModeSync;
    };
    withSyncModeDo = function(newMode, block) {
      var err, oldMode, ref1;
      oldMode = monadModeSync;
      monadModeSync = newMode;
      try {
        return block();
      } catch (_error) {
        err = _error;
        return console.log("ERR: " + ((ref1 = err.stack) != null ? ref1 : err));
      } finally {

      }
    };
    runMonad = function(monad, env, cont) {
      env = env != null ? env : root.defaultEnv;
      return withSyncModeDo(true, function() {
        return newRunMonad(monad, env, cont, []);
      });
    };
    isMonad = function(m) {
      return typeof m === 'function' && (m.cmd != null);
    };
    continueMonads = function(contStack, env) {
      return function(result) {
        return withSyncModeDo(false, function() {
          return newRunMonad(result, env, null, contStack);
        });
      };
    };
    asyncMonad = {
      toString: function() {
        return "<asyncMonadResult>";
      }
    };
    warnAsync = false;
    setWarnAsync = function(state) {
      return warnAsync = state;
    };
    newRunMonad = function(monad, env, cont, contStack) {
      var err, ref1, result;
      if (cont) {
        contStack.push(cont);
      }
      try {
        while (true) {
          if (monad instanceof Monad2) {
            return runMonad2(monad, env, continueMonads(contStack, env), []);
          } else if (isMonad(monad)) {
            if (monad.binding) {
              (function(bnd) {
                return contStack.push(function(x) {
                  return rz(bnd)(lz(x));
                });
              })(monad.binding);
              monad = rz(monad.monad);
              continue;
            } else if (!monad.sync) {
              monadModeSync = false;
              if (warnAsync) {
                console.log("async monad");
              }
              monad.cmd(env, continueMonads(contStack, env));
              return asyncMonad;
            }
            result = monad.cmd(env, identity);
          } else {
            monadModeSync = true;
            result = monad;
          }
          if (!contStack.length) {
            return result;
          }
          monad = contStack.pop()(result);
        }
      } catch (_error) {
        err = _error;
        err = replaceErr(err, "\nERROR RUNNING MONAD, MONAD: " + monad + ", ENV: " + env + "...\n" + err.message);
        console.log((ref1 = err.stack) != null ? ref1 : err);
        if (env.errorHandlers.length) {
          return env.errorHandlers.pop()(err);
        }
      }
    };
    callBind = function(value, contStack) {
      var func, tmp, val;
      func = contStack.pop();
      val = lz(value);
      tmp = L_bind()(val)(lz(func));
      if (isMonad(tmp) && (tmp.monad === val || tmp.monad === value)) {
        console.log("peeling bind");
        return func(value);
      } else {
        return tmp;
      }
    };
    Monad = (function() {
      function Monad() {}

      Monad.prototype.toString = function() {
        return "Monad: " + (this.cmd.toString());
      };

      return Monad;

    })();
    (typeof global !== "undefined" && global !== null ? global : window).L_runMonads = function(monadArray, env) {
      monadArray.reverse();
      newRunMonad(0, env != null ? env : defaultEnv, null, monadArray);
      return monadArray;
    };
    ensureLeisureClass('unit');
    Leisure_unit = (function(superClass) {
      extend(Leisure_unit, superClass);

      function Leisure_unit() {
        return Leisure_unit.__super__.constructor.apply(this, arguments);
      }

      Leisure_unit.prototype.toString = function() {
        return 'unit';
      };

      return Leisure_unit;

    })(LeisureObject);
    _unit = mkProto(Leisure_unit, setType((function(_x) {
      return rz(_x);
    }), 'unit'));
    define('define', function(name, arity, src, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          nakedDefine(rz(name), def, rz(arity), rz(src));
          return cont(_unit);
        });
      }
    });
    define('newDefine', function(name, arity, src, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          nakedDefine(rz(name), def, rz(arity), rz(src), null, null, true);
          return cont(_unit);
        });
      }
    });
    runMonad2 = function(monad, env, cont) {
      var hasInnerArg, inner, innerArg, result, sync;
      if (monad instanceof Monad2) {
        return monad.cmd(env, cont);
      } else if (isMonad(monad)) {
        if (monad.binding != null) {
          sync = true;
          inner = null;
          hasInnerArg = false;
          innerArg = null;
          result = runMonad2(rz(monad.monad), env, function(x) {
            if (sync) {
              return inner = function() {
                return runMonad2(rz(monad.binding)(lz(x)), env, function(y) {
                  if (sync) {
                    hasInnerArg = true;
                    return innerArg = y;
                  } else {
                    return cont(y);
                  }
                });
              };
            } else {
              return runMonad2(rz(monad.binding)(lz(x)), env, cont);
            }
          });
          if (inner) {
            result = inner();
            if (hasInnerArg) {
              result = cont(innerArg);
            }
          }
          sync = false;
          return result;
        } else {
          return monad.cmd(env, cont);
        }
      } else {
        return cont(monad);
      }
    };
    Monad2 = (function(superClass) {
      extend(Monad2, superClass);

      function Monad2(name1, cmd, cmdToString) {
        this.name = name1;
        this.cmd = cmd;
        this.cmdToString = cmdToString;
        if (typeof this.name === 'function') {
          this.cmdToString = this.cmd;
          this.cmd = this.name;
          this.name = null;
        }
        if (!this.cmdToString) {
          this.cmdToString = (function(_this) {
            return function() {
              return (name ? name + ": " : '') + _this.cmd.toString();
            };
          })(this);
        }
      }

      Monad2.prototype.toString = function() {
        return "Monad2: " + (this.cmdToString());
      };

      return Monad2;

    })(Monad);
    define('defer', function(v) {
      return new Monad2((function(env, cont) {
        return setTimeout((function() {
          return cont(rz(v));
        }), 1);
      }), function() {
        return "defer " + (rz(v));
      });
    });
    define('bind2', bind2 = function(m, binding) {
      var newM;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        newM = rz(m);
        if ((newM instanceof Monad2) || (isMonad(newM))) {
          return new Monad2('bind', (function(env, cont) {
            var hasInnerArg, inner, innerArg, result, sync;
            sync = true;
            inner = null;
            innerArg = null;
            hasInnerArg = false;
            result = runMonad2(newM, env, function(value) {
              if (sync) {
                return inner = function() {
                  return runMonad2(rz(binding)(lz(value)), env, function(y) {
                    if (sync) {
                      hasInnerArg = true;
                      return innerArg = y;
                    } else {
                      return cont(y);
                    }
                  });
                };
              } else {
                return runMonad2(rz(binding)(lz(value)), env, cont);
              }
            });
            if (inner) {
              result = inner();
              if (hasInnerArg) {
                result = cont(innerArg);
              }
            }
            sync = false;
            return result;
          }), function() {
            return "bind (" + (rz(m)) + ")";
          });
        } else {
          return rz(binding)(m);
        }
      }
    });
    newbind = false;
    if (newbind) {
      define('bind', bind2);
    } else {
      define('bind', function(m, binding) {
        var bindMonad;
        if (isPartial(arguments)) {
          return partialCall(arguments);
        } else {
          if (isMonad(rz(m))) {
            bindMonad = makeMonad(function(env, cont) {});
            bindMonad.monad = m;
            bindMonad.binding = binding;
            return bindMonad;
          } else {
            return rz(binding)(m);
          }
        }
      });
    }
    values = {};
    define('protect', function(value) {
      return makeMonad(function(env, cont) {
        var hnd;
        hnd = function(err) {
          var ref1, ref2;
          console.log("PROTECTED ERROR: " + ((ref1 = err.stack) != null ? ref1 : err));
          return cont(left((ref2 = err.stack) != null ? ref2 : err));
        };
        env.errorHandlers.push(hnd);
        return runMonad(rz(value), env, (function(result) {
          if (env.errorHandlers.length) {
            if (env.errorHandlers[env.errorHandlers.length - 1] === hnd) {
              env.errorHandlers.pop();
            } else if (_.contains(env.errorHandlers, hnd)) {
              while (env.errorHandlers[env.errorHandlers.length - 1] !== hnd) {
                env.errorHandlers.pop();
              }
            }
          }
          return cont(right(result));
        }), []);
      });
    });
    actors = {};
    define('actor', function(name, func) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        actors[name] = func;
        func.env = {
          values: {}
        };
        return func.env.__proto__ = defaultEnv;
      }
    });
    define('send', function(name, msg) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return setTimeout((function() {
          return runMonad(rz(actors[name])(msg), rz(actors[name]).env);
        }), 1);
      }
    });
    define('hasValue', function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(values[rz(name)] != null));
      });
    });
    define('getValueOr', function(name, defaultValue) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var ref1;
          return cont((ref1 = values[rz(name)]) != null ? ref1 : rz(defaultValue));
        });
      }
    });
    define('getValue', function(name) {
      return makeSyncMonad(function(env, cont) {
        if (!(rz(name) in values)) {
          throw new Error("No value named '" + (rz(name)) + "'");
        }
        return cont(values[rz(name)]);
      });
    });
    define('setValue', function(name, value) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          values[rz(name)] = rz(value);
          return cont(_unit);
        });
      }
    });
    define('deleteValue', function(name) {
      return makeSyncMonad(function(env, cont) {
        delete values[rz(name)];
        return cont(_unit);
      });
    });
    setValue = function(key, value) {
      return values[key] = value;
    };
    getValue = function(key) {
      return values[key];
    };
    define('envHas', function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(env.values[rz(name)] != null));
      });
    });
    define('envGetOr', function(name, defaultValue) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var ref1;
          return cont((ref1 = env.values[rz(name)]) != null ? ref1 : rz(defaultValue));
        });
      }
    });
    define('envGet', function(name) {
      return makeSyncMonad(function(env, cont) {
        if (!(rz(name) in env.values)) {
          throw new Error("No value named '" + (rz(name)) + "'");
        }
        return cont(env.values[rz(name)]);
      });
    });
    define('envSet', function(name, value) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          env.values[rz(name)] = rz(value);
          return cont(_unit);
        });
      }
    });
    define('envDelete', function(name) {
      return makeSyncMonad(function(env, cont) {
        delete env.values[rz(name)];
        return cont(_unit);
      });
    });
    setValue('macros', Nil);
    define('defMacro', function(name, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          values.macros = cons(cons(rz(name), rz(def)), values.macros);
          return cont(_unit);
        });
      }
    });
    define('funcList', makeSyncMonad(function(env, cont) {
      return cont(consFrom(global.leisureFuncNames.toArray().sort()));
    }));
    define('funcs', makeSyncMonad(function(env, cont) {
      console.log("Leisure functions:\n" + (_(global.leisureFuncNames.toArray()).sort().join('\n')));
      return cont(_unit);
    }));
    define('funcSrc', function(func) {
      var info;
      if (typeof rz(func) === 'function') {
        info = functionInfo[rz(func).leisureName];
        if (info != null ? info.src : void 0) {
          return some(info.src);
        } else {
          return none;
        }
      }
    });
    define('ast2Json', function(ast) {
      return JSON.stringify(ast2Json(rz(ast)));
    });
    define('override', function(name, newFunc) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var n, oldDef;
          n = "L_" + (nameSub(rz(name)));
          oldDef = global[n];
          if (!oldDef) {
            throw new Error("No definition for " + (rz(name)));
          }
          global[n] = function() {
            return rz(newFunc)(oldDef);
          };
          return cont(_unit);
        });
      }
    });
    define('gensym', makeSyncMonad(function(env, cont) {
      return cont("G" + (gensymCounter++));
    }));
    define('print', function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(env.presentValue(rz(msg)));
        return cont(_unit);
      });
    });
    define('print2', function(msg) {
      return new Monad2('print2', (function(env, cont) {
        env.write(env.presentValue(rz(msg)));
        return cont(_unit);
      }), function() {
        return "print2 " + (rz(msg));
      });
    });
    define('write', function(msg) {
      return new Monad2('write', (function(env, cont) {
        env.write(String(rz(msg)));
        return cont(_unit);
      }), function() {
        return "write " + (rz(msg));
      });
    });
    define('prompt2', function(msg) {
      return new Monad2((function(env, cont) {
        return env.prompt(String(rz(msg)), function(input) {
          return cont(input);
        });
      }), function() {
        return "prompt2 " + (rz(msg));
      });
    });
    define('oldWrite', function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(String(rz(msg)));
        return cont(_unit);
      });
    });
    define('readFile', function(name) {
      return makeMonad(function(env, cont) {
        return env.readFile(rz(name), function(err, contents) {
          var ref1;
          return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(contents)));
        });
      });
    });
    define('readDir', function(dir) {
      return makeMonad(function(env, cont) {
        return env.readDir(rz(dir), function(err, files) {
          var ref1;
          return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(files)));
        });
      });
    });
    define('writeFile', function(name, data) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeMonad(function(env, cont) {
          return env.writeFile(rz(name), rz(data), function(err, contents) {
            var ref1;
            return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(contents)));
          });
        });
      }
    });
    define('statFile', function(file) {
      return makeMonad(function(env, cont) {
        return env.statFile(rz(file), function(err, stats) {
          var ref1;
          return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(stats)));
        });
      });
    });
    define('prompt', function(msg) {
      return makeMonad(function(env, cont) {
        return env.prompt(String(rz(msg)), function(input) {
          return cont(input);
        });
      });
    });
    define('rand', makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    }));
    define('js', function(str) {
      return makeSyncMonad(function(env, cont) {
        var err, result;
        try {
          result = eval(rz(str));
          return cont(right(result));
        } catch (_error) {
          err = _error;
          return cont(left(err));
        }
      });
    });
    define('delay', function(timeout) {
      return new Monad2(function(env, cont) {
        return setTimeout((function() {
          return cont(_unit);
        }), rz(timeout));
      });
    });
    define('currentTime', new Monad2(function(env, cont) {
      return cont(Date.now);
    }));
    define('once', makeSyncMonad((function() {
      var ran;
      ran = false;
      return function(env, cont) {
        if (!ran) {
          console.log("RUNNING");
          ran = true;
          return cont(_unit);
        } else {
          return console.log("ALREADY RAN");
        }
      };
    })()));
    define('advise', function(name, alt, arity, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeMonad(function(env, cont) {
          var alts, i, info, newDef, nm;
          info = functionInfo[rz(name)];
          if (!info) {
            info = functionInfo[rz(name)] = {
              src: '',
              arity: -1,
              alts: {},
              altList: []
            };
          }
          if (!info.alts[rz(alt)]) {
            info.altList.push(rz(alt));
          }
          info.alts[rz(alt)] = rz(def);
          alts = (function() {
            var j, len, ref1, results;
            ref1 = info.altList;
            results = [];
            for (j = 0, len = ref1.length; j < len; j++) {
              i = ref1[j];
              results.push(info.alts[i]);
            }
            return results;
          })();
          alts.reverse();
          nm = "L_" + (nameSub(rz(name)));
          newDef = function() {
            var arg, j, len, len1, len2, o, opt, q, res;
            if (arguments.length !== rz(arity)) {
              return Leisure_primCall(arguments.callee, 0, arguments, rz(arity));
            } else {
              for (j = 0, len = alts.length; j < len; j++) {
                alt = alts[j];
                opt = alt;
                for (o = 0, len1 = arguments.length; o < len1; o++) {
                  arg = arguments[o];
                  opt = opt(arg);
                }
                if (getType(opt) === 'some') {
                  return opt(lz(function(x) {
                    return rz(x);
                  }))(lz(_false));
                }
              }
              if (info.mainDef) {
                res = rz(info.mainDef);
                for (q = 0, len2 = arguments.length; q < len2; q++) {
                  arg = arguments[q];
                  res = res(arg);
                }
                return res;
              }
              throw new Error("No default definition for " + (rz(name)));
            }
          };
          functionInfo[name].newArity = true;
          newDef.leisureName = name;
          global[nm] = global.leisureFuncNames[nm] = lz(newDef);
          return cont(def);
        });
      }
    });
    curry = function(arity, func) {
      return function() {
        return lz(function(arg) {
          return lz((subcurry(arity, func, null))(arg));
        });
      };
    };
    subcurry = function(arity, func, args) {
      return lz(function(arg) {
        args = simpyCons(arg, args);
        if (arity === 1) {
          return func(args.toArray().reverse());
        } else {
          return subcurry(arity - 1, func, args);
        }
      });
    };
    presentationReplacements = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '\n': '\\n',
      '\\': '\\\\'
    };
    escapePresentationHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&\n\\]/g, function(c) {
          return presentationReplacements[c];
        });
      } else {
        return str;
      }
    };
    presentationToHtmlReplacements = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '\\n': '\n',
      '\\\\': '\\'
    };
    unescapePresentationHtml = function(str) {
      return str.replace(/&lt;|&gt;|&amp;|\\n|\\/g, function(c) {
        return presentationToHtmlReplacements[c];
      });
    };
    define('escapeHtml', function(h) {
      return escapePresentationHtml(rz(h));
    });
    define('unescapeHtml', function(h) {
      return unescapePresentationHtml(rz(h));
    });
    makeHamt = function(hamt) {
      hamt.leisureType = 'hamt';
      return hamt;
    };
    hamt = makeHamt(Map());
    hamt.leisureDataType = 'hamt';
    define('hamt', hamt);
    define('hamtWith', function(key, value, hamt) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeHamt(rz(hamt).set(rz(key), rz(value)));
      }
    });
    define('hamtSet', function(key, value, hamt) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeHamt(rz(hamt).set(rz(key), rz(value)));
      }
    });
    define('hamtFetch', function(key, hamt) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(hamt).get(rz(key));
      }
    });
    define('hamtGet', function(key, hamt) {
      var v;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        v = rz(hamt).get(rz(key));
        if (v !== void 0) {
          return some(v);
        } else {
          return none;
        }
      }
    });
    define('hamtWithout', function(key, hamt) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeHamt(rz(hamt).remove(rz(key)));
      }
    });
    define('hamtPairs', function(hamt) {
      return nextHamtPair(rz(hamt).entries());
    });
    nextHamtPair = function(entries) {
      var f;
      if (entries.size === 0) {
        return rz(L_nil);
      } else {
        f = entries.first();
        return rz(L_acons)(f[0], f[1], function() {
          return nextHamtPair(entries.rest);
        });
      }
    };
    lacons = function(k, v, list) {
      return rz(L_acons)(lz(k), lz(v), lz(list));
    };
    jsonConvert = function(obj) {
      var i, k, t, v;
      if (obj instanceof Array) {
        return consFrom((function() {
          var j, len, results;
          results = [];
          for (j = 0, len = obj.length; j < len; j++) {
            i = obj[j];
            results.push(jsonConvert(i));
          }
          return results;
        })());
      } else if (typeof obj === 'object') {
        t = rz(L_nil);
        for (k in obj) {
          v = obj[k];
          t = lacons(k, jsonConvert(v), t);
        }
        return t;
      } else {
        return obj;
      }
    };
    define('fromJson', function(obj) {
      return jsonConvert(rz(obj));
    });
    define('parseYaml', function(obj) {
      return safeLoad(rz(obj));
    });
    define('toJsonArray', function(list) {
      var array;
      list = rz(list);
      array = [];
      while (!list.isNil()) {
        array.push(list.head());
        list = list.tail();
      }
      return array;
    });
    define('toJsonObject', function(list) {
      var obj;
      list = rz(list);
      obj = {};
      while (!list.isNil()) {
        head = list.head();
        if (obj[head.head()] == null) {
          obj[head.head()] = head.tail();
        }
        list = list.tail();
      }
      return obj;
    });
    define('jsonToYaml', function(json) {
      var err;
      try {
        return right(dump(rz(json)));
      } catch (_error) {
        err = _error;
        return left(err.stack);
      }
    });
    define('trampolineCall', function(func) {
      var ret;
      ret = rz(func);
      while (true) {
        if (typeof ret === 'function' && ret.trampoline) {
          ret = ret();
        } else {
          return ret;
        }
      }
    });
    define('trampoline', function(func) {
      var arity, f;
      f = rz(func);
      arity = functionInfo[f.leisureName].arity;
      return trampCurry(f, arity);
    });
    trampCurry = function(func, arity) {
      return function(arg) {
        var a, result;
        a = rz(arg);
        if (arity > 1) {
          return trampCurry(func(function() {
            return a;
          }), arity - 1);
        } else {
          result = function() {
            return func(function() {
              return a;
            });
          };
          result.trampoline = true;
          return result;
        }
      };
    };
    define('setNameSpace', function(name) {
      return makeSyncMonad(function(env, cont) {
        var newNameSpace;
        root.currentNameSpace = rz(name);
        newNameSpace = false;
        if (name) {
          newNameSpace = !LeisureNameSpaces[name];
          if (newNameSpace) {
            LeisureNameSpaces[name] = {};
          }
          nsLog("SETTING NAME SPACE: " + name);
        }
        return cont((newNameSpace ? _true : _false));
      });
    });
    define('pushNameSpace', function(newNameSpace) {
      return makeSyncMonad(function(env, cont) {
        var pushed;
        pushed = LeisureNameSpaces[newNameSpace] && !(indexOf.call(root.nameSpacePath, newNameSpace) >= 0);
        if (pushed) {
          root.nameSpacePath.push(newNameSpace);
        }
        return cont((pushed ? _true : _false));
      });
    });
    define('clearNameSpacePath', makeSyncMonad(function(env, cont) {
      root.nameSpacePath = [];
      return cont(_unit);
    }));
    define('resetNameSpaceInfo', makeSyncMonad(function(enf, cont) {
      var old;
      old = [root.nameSpacePath, root.currentNameSpace];
      root.nameSpacePath = ['core'];
      root.currentNameSpace = null;
      nsLog("SETTING NAME SPACE: null");
      return cont(old);
    }));
    define('setNameSpaceInfo', function(info) {
      return makeSyncMonad(function(env, cont) {
        var ref1;
        ref1 = rz(info), root.nameSpacePath = ref1[0], root.currentNameSpace = ref1[1];
        nsLog("SETTING NAME SPACE: " + root.currentNameSpace);
        return cont(_unit);
      });
    });
    ensureLeisureClass('token');
    Leisure_token.prototype.toString = function() {
      return "Token(" + (JSON.stringify(tokenString(this))) + ", " + (posString(tokenPos(this))) + ")";
    };
    tokenString = function(t) {
      return t(lz(function(txt) {
        return function(pos) {
          return rz(txt);
        };
      }));
    };
    tokenPos = function(t) {
      return t(lz(function(txt) {
        return function(pos) {
          return rz(pos);
        };
      }));
    };
    ensureLeisureClass('filepos');
    posString = function(p) {
      if (p instanceof Leisure_filepos) {
        return p(lz(function(file) {
          return function(line) {
            return function(offset) {
              return (rz(file)) + ":" + (rz(line)) + "." + (rz(offset));
            };
          };
        }));
      } else {
        return p;
      }
    };
    ensureLeisureClass('parens');
    Leisure_parens.prototype.toString = function() {
      return "Parens(" + (posString(parensStart(this))) + ", " + (posString(parensEnd(this))) + ", " + (parensContent(this)) + ")";
    };
    parensStart = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(s);
          };
        };
      }));
    };
    parensEnd = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(e);
          };
        };
      }));
    };
    parensContent = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(l);
          };
        };
      }));
    };
    ensureLeisureClass('true');
    Leisure_true.prototype.toString = function() {
      return "true";
    };
    ensureLeisureClass('false');
    Leisure_false.prototype.toString = function() {
      return "false";
    };
    ensureLeisureClass('left');
    Leisure_left.prototype.toString = function() {
      return "Left(" + (this(lz(_identity))(lz(_identity))) + ")";
    };
    ensureLeisureClass('right');
    Leisure_right.prototype.toString = function() {
      return "Right(" + (this(lz(_identity))(lz(_identity))) + ")";
    };
    requireFiles = function(req, cont, verbose) {
      var contStack;
      if (req.length) {
        if (verbose) {
          console.log("REQUIRING FILE: " + req[0]);
        }
        contStack = require(req.shift());
        if (Array.isArray(contStack) && contStack.length) {
          return contStack.unshift(function() {
            return requireFiles(req, cont, verbose);
          });
        } else {
          return requireFiles(req, cont, verbose);
        }
      } else {
        return cont();
      }
    };
    define('funcInfo', function(f) {
      return funcInfo(rz(f));
    });
    define('funcName', function(f) {
      if (rz(f).leisureName) {
        return some(rz(f).leisureName);
      } else {
        return none;
      }
    });
    define('trackCreation', function(flag) {
      return makeSyncMonad(function(env, cont) {
        root.trackCreation = rz(flag)(lz(true))(lz(false));
        return cont(_unit);
      });
    });
    define('trackVars', function(flag) {
      return makeSyncMonad(function(env, cont) {
        root.trackVars = rz(flag)(lz(true))(lz(false));
        return cont(_unit);
      });
    });
    define('getFunction', function(name) {
      var f;
      f = rz(global['L_' + (nameSub(rz(name)))]);
      if (f) {
        return some(f);
      } else {
        return none;
      }
    });
    if (typeof window !== "undefined" && window !== null) {
      window.runMonad = runMonad;
      window.setType = setType;
      window.setDataType = setDataType;
      window.defaultEnv = defaultEnv;
      window.identity = identity;
    }
    return {
      requireFiles: requireFiles,
      _true: _true,
      _false: _false,
      _unit: _unit,
      stateValues: values,
      runMonad: runMonad,
      runMonad2: runMonad2,
      newRunMonad: newRunMonad,
      isMonad: isMonad,
      Monad2: Monad2,
      identity: identity,
      setValue: setValue,
      getValue: getValue,
      makeMonad: makeMonad,
      makeSyncMonad: makeSyncMonad,
      replaceErr: replaceErr,
      left: left,
      right: right,
      getMonadSyncMode: getMonadSyncMode,
      asyncMonad: asyncMonad,
      setWarnAsync: setWarnAsync,
      call: call,
      callMonad: callMonad,
      basicCall: basicCall,
      booleanFor: booleanFor,
      newConsFrom: consFrom,
      escapePresentationHtml: escapePresentationHtml,
      unescapePresentationHtml: unescapePresentationHtml,
      makeHamt: makeHamt,
      jsonConvert: jsonConvert
    };
  });

}).call(this);

//# sourceMappingURL=runtime.js.map
