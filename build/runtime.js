// Generated by CoffeeScript 1.10.0

/*
Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

(licensed with ZLIB license)

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.
 */

(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['./base', './docOrg', './ast', 'lodash', 'immutable', 'lib/js-yaml', 'bluebird'], function(Base, DocOrg, Ast, _, Immutable, Yaml, Bluebird) {
    var LeisureObject, Leisure_unit, List, Map, Monad, Monad2, Monad3, Nil, Promise, Runtime, Set, SimpyCons, _false, _identity, _true, _unit, actors, advise, amtSet, ast2Json, asyncMonad, basicCall, bind, booleanFor, call, callBind, callMonad, checkPartial, cons, consFrom, continueMonads, curry, defaultEnv, define, dump, dumpMonadStack, ensureLeisureClass, envTag, escapePresentationHtml, funcInfo, functionInfo, gensymCounter, getDataType, getMonadSyncMode, getType, getValue, hamt, head, identity, isMonad, isPartial, jsonConvert, lacons, lazy, lc, left, leisureFunctionNamed, leisurify, lz, makeMap, makeMonad, makeSet, makeSyncMonad, makeVector, mkProto, monadModeSync, nFunction, nakedDefine, nameSub, newRunMonad, nextMapPair, nextMonad, nextSetItem, nextVectorItem, noMemo, none, nsLog, parensContent, parensEnd, parensStart, parseYaml, partialCall, posString, presentationReplacements, presentationToHtmlReplacements, readDir, readFile, ref, replaceErr, requireFiles, resolve, right, root, runMonad, runMonad2, rz, setDataType, setType, setValue, setWarnAsync, simpyCons, some, statFile, strCoord, strFromList, strToList, subcurry, tail, tokenPos, tokenString, unescapePresentationHtml, values, vector, warnAsync, withSyncModeDo, writeFile;
    ref = root = Base, readFile = ref.readFile, statFile = ref.statFile, readDir = ref.readDir, writeFile = ref.writeFile, defaultEnv = ref.defaultEnv, SimpyCons = ref.SimpyCons, simpyCons = ref.simpyCons, resolve = ref.resolve, lazy = ref.lazy, nsLog = ref.nsLog, funcInfo = ref.funcInfo;
    parseYaml = DocOrg.parseYaml;
    define = Ast.define, nakedDefine = Ast.nakedDefine, cons = Ast.cons, Nil = Ast.Nil, head = Ast.head, tail = Ast.tail, getType = Ast.getType, getDataType = Ast.getDataType, ast2Json = Ast.ast2Json, ensureLeisureClass = Ast.ensureLeisureClass, LeisureObject = Ast.LeisureObject, mkProto = Ast.mkProto, setType = Ast.setType, setDataType = Ast.setDataType, functionInfo = Ast.functionInfo, nameSub = Ast.nameSub, isPartial = Ast.isPartial, partialCall = Ast.partialCall, leisureFunctionNamed = Ast.leisureFunctionNamed;
    Map = Immutable.Map, Set = Immutable.Set, List = Immutable.List;
    dump = Yaml.dump;
    Promise = Bluebird.Promise;
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    gensymCounter = 0;
    checkPartial = function(func, args) {
      if (typeof func === 'string') {
        func = leisureFunctionNamed(func);
      }
      if (func.length !== args.length) {
        return Leisure_primCall(func, 0, args);
      }
    };
    call = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return basicCall(args, defaultEnv, identity);
    };
    callMonad = function() {
      var args, cont, env, j;
      args = 3 <= arguments.length ? slice.call(arguments, 0, j = arguments.length - 2) : (j = 0, []), env = arguments[j++], cont = arguments[j++];
      return basicCall(args, env, cont);
    };
    basicCall = function(args, env, cont) {
      var arg, j, len, ref1, res;
      res = rz(global["L_" + args[0]]);
      ref1 = args.slice(1);
      for (j = 0, len = ref1.length; j < len; j++) {
        arg = ref1[j];
        res = (function(arg) {
          return res(lz(arg));
        })(arg);
      }
      return runMonad2(res, env, cont);
    };
    consFrom = function(array, i) {
      i = i || 0;
      if (i < array.length) {
        return cons(array[i], consFrom(array, i + 1));
      } else {
        return rz(L_nil);
      }
    };
    noMemo = function(f) {
      Object.defineProperty(f, 'memo', {
        set: function() {}
      });
      return f;
    };
    identity = function(x) {
      return x;
    };
    _identity = function(x) {
      return rz(x);
    };
    _unit = setType((function(x) {
      return rz(x);
    }), 'unit');
    _true = setType((function(a) {
      return function(b) {
        return rz(a);
      };
    }), 'true');
    _false = setType((function(a) {
      return function(b) {
        return rz(b);
      };
    }), 'false');
    left = function(x) {
      return setType((function(lCase) {
        return function(rCase) {
          return rz(lCase)(lz(x));
        };
      }), 'left');
    };
    right = function(x) {
      return setType((function(lCase) {
        return function(rCase) {
          return rz(rCase)(lz(x));
        };
      }), 'right');
    };
    some = function(x) {
      return setType((function(someCase) {
        return function(noneCase) {
          return rz(someCase)(lz(x));
        };
      }), 'some');
    };
    none = setType((function(someCase) {
      return function(noneCase) {
        return rz(noneCase);
      };
    }), 'none');
    booleanFor = function(bool) {
      if (bool) {
        return rz(L_true);
      } else {
        return rz(L_false);
      }
    };
    (function() {
      'use strict';
      define('eq', function(a, b) {
        return checkPartial(L_eq, arguments) || booleanFor(rz(a) === rz(b));
      });
      define('==', function(a, b) {
        return checkPartial(L_$p$p, arguments) || booleanFor(rz(a) === rz(b));
      });
      define('!=', function(a, b) {
        return checkPartial(L_$k$p, arguments) || booleanFor(rz(a) !== rz(b));
      });
      define('hasType', function(data, func) {
        return checkPartial(L_hasType, arguments) || (typeof rz(func) === 'string' ? booleanFor(getType(rz(data)) === rz(func)) : booleanFor(getType(rz(data)) === getDataType(rz(func))));
      });
      define('getDataType', function(func) {
        if (typeof rz(func) === 'string') {
          return rz(func);
        } else {
          return getDataType(rz(func));
        }
      });
      define('assert', function(bool) {
        return function(msg) {
          return function(expr) {
            return rz(bool)(expr)(function() {
              var err;
              err = new Error(rz(msg));
              err.stack = "Leisure stack:\n" + err + "\n   at " + (L$thunkStack.reverse().join('\n   at ')) + "\n\nJS Stack:\n" + err.stack;
              console.error(err.stack);
              throw err;
            });
          };
        };
      });
      define('assertLog', function(bool) {
        return function(msg) {
          return function(expr) {
            return rz(bool)(expr)(function() {
              console.log(new Error(rz(msg)).stack);
              console.log("LOGGED ERROR -- RESUMING EXECUTION...");
              return rz(expr);
            });
          };
        };
      });
      define('trace', function(msg) {
        console.log("STACKTRACE: ", new Error(rz(msg)).stack);
        return msg;
      });
      define('jsTrue', function(x) {
        if (rz(x)) {
          return _true;
        } else {
          return _false;
        }
      });
      return define('error', function(msg) {
        throw new Error(rz(msg));
      });
    })();
    define('+', function(x, y) {
      return checkPartial(L_$o, arguments) || rz(x) + rz(y);
    });
    define('-', function(x, y) {
      return checkPartial(L_$_, arguments) || rz(x) - rz(y);
    });
    define('*', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) * rz(y);
      }
    });
    define('/', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) / rz(y);
      }
    });
    define('%', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(x) % rz(y);
      }
    });
    define('<', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) < rz(y));
      }
    });
    define('<=', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) <= rz(y));
      }
    });
    define('>', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) > rz(y));
      }
    });
    define('>=', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(x) >= rz(y));
      }
    });
    define('floor', function(x) {
      return Math.floor(rz(x));
    });
    define('ceil', function(x) {
      return Math.ceil(rz(x));
    });
    define('min', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return Math.min(rz(x), rz(y));
      }
    });
    define('max', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return Math.max(rz(x), rz(y));
      }
    });
    define('round', function(x) {
      return Math.round(rz(x));
    });
    define('abs', function(x) {
      return Math.abs(rz(x));
    });
    define('sqrt', function(x) {
      return Math.sqrt(rz(x));
    });
    define('acos', function(x) {
      return Math.acos(rz(x));
    });
    define('asin', function(x) {
      return Math.asin(rz(x));
    });
    define('atan', function(x) {
      return Math.atan(rz(x));
    });
    define('atan2', function(x, y) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return Math.atan2(rz(x), rz(y));
      }
    });
    define('cos', function(x) {
      return Math.cos(rz(x));
    });
    define('sin', function(x) {
      return Math.sin(rz(x));
    });
    define('tan', function(x) {
      return Math.tan(rz(x));
    });
    define('rand', function() {
      return makeSyncMonad(function(env, cont) {
        return cont(Math.random());
      });
    });
    define('randInt', function(low, high) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          return cont(Math.floor(rz(low) + Math.random() * rz(high)));
        });
      }
    });
    define('^', function(x, y) {
      return Math.pow(rz(x), rz(y));
    });
    define('number', function(n) {
      return Number(n);
    });
    define('_show', function(data) {
      var ref1;
      if ((ref1 = typeof rz(data)) === 'string' || ref1 === 'number' || ref1 === 'boolean') {
        return JSON.stringify(rz(data));
      } else if (getType(rz(data)) === 'err') {
        return rz(L_errMsg)(data);
      } else {
        return String(rz(data));
      }
    });
    define('strString', function(data) {
      return String(rz(data));
    });
    define('_strAsc', function(str) {
      return rz(str).charCodeAt(0);
    });
    define('_strChr', function(i) {
      return String.fromCharCode(rz(i));
    });
    define('_strAt', function(str, index) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(str)[strCoord(rz(str), rz(index))];
      }
    });
    define('_strStartsWith', function(str, prefix) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return booleanFor(rz(str).substring(0, rz(prefix).length) === rz(prefix));
      }
    });
    define('_strLen', function(str) {
      return rz(str).length;
    });
    define('_strToLowerCase', function(str) {
      return rz(str).toLowerCase();
    });
    define('_strToUpperCase', function(str) {
      return rz(str).toUpperCase();
    });
    define('_strReplace', function(str, pat, repl) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(str).replace(rz(pat), rz(repl));
      }
    });
    strCoord = function(str, coord) {
      if (coord < 0) {
        return str.length + coord;
      } else {
        return coord;
      }
    };
    define('_strSubstring', function(str, start, end) {
      var a, b;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        a = strCoord(rz(str), rz(start));
        b = strCoord(rz(str), rz(end));
        if (b < a && rz(end) === 0) {
          b = rz(str).length;
        }
        return rz(str).substring(a, b);
      }
    });
    define('_strSplit', function(str, pat) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return consFrom(rz(str).split(rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
      }
    });
    define('_strCat', function(list) {
      return _.map(rz(list).toArray(), function(el) {
        if (typeof el === 'string') {
          return el;
        } else {
          return rz(L_show)(lz(el));
        }
      }).join('');
    });
    define('_strAdd', function(s1, s2) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(s1) + rz(s2);
      }
    });
    define('_strMatch', function(str, pat) {
      var groups, m, pos;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        m = rz(str).match((rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
        if (m) {
          groups = [];
          pos = 1;
          while (m[pos]) {
            groups.push(m[pos++]);
          }
          if (typeof m.index !== 'undefined') {
            return consFrom([m[0], consFrom(groups), m.index, m.input]);
          } else {
            return consFrom([m[0], consFrom(groups)]);
          }
        } else if (L_nil) {
          return rz(L_nil);
        } else {
          return Nil;
        }
      }
    });
    define('_strToList', function(str) {
      return strToList(rz(str));
    });
    strToList = function(str) {
      if (str === '') {
        return Nil;
      } else {
        return cons(str[0], strToList(str.substring(1)));
      }
    };
    define('_strFromList', function(list) {
      return strFromList(rz(list));
    });
    strFromList = function(list) {
      if (list instanceof Leisure_nil) {
        return '';
      } else {
        return head(list) + strFromList(tail(list));
      }
    };
    define('_regexp', function(str) {
      return new RegExp(rz(str));
    });
    define('_regexpFlags', function(str, flags) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new RegExp(rz(str), rz(flags));
      }
    });
    define('_jsonParse', function(str, failCont, successCont) {
      var err, error, p;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        try {
          p = JSON.parse(rz(str));
          return rz(successCont)(lz(p));
        } catch (error) {
          err = error;
          return rz(failCont)(lz(err));
        }
      }
    });
    define('jsonStringify', function(obj, failCont, successCont) {
      var err, error, s;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        try {
          s = JSON.stringify(rz(obj));
          return rz(successCont)(lz(s));
        } catch (error) {
          err = error;
          return rz(failCont)(lz(err));
        }
      }
    });
    define('getProperties', function(func) {
      var ref1;
      if ((ref1 = rz(func)) != null ? ref1.properties : void 0) {
        return rz(func).properties;
      } else {
        return rz(L_nil);
      }
    });
    define('setProperty', function(func, name, value) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var f, ref1;
          f = rz(func);
          f.properties = rz(L_aconsf)(name, value, lz((ref1 = f.properties) != null ? ref1 : rz(L_nil)));
          return cont(f.properties);
        });
      }
    });
    define('log', function(str, res) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        console.log(rz(str));
        return rz(res);
      }
    });
    define('logStack', function(str, res) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        console.log(new Error(rz(str)).stack);
        return rz(res);
      }
    });
    define('breakpoint', function(x) {
      console.log('Break point ', rz(x));
      return rz(x);
    });
    makeMonad = function(guts) {
      var m;
      m = function() {
        throw new Error("ILLEGAL CALL TO MONAD FUNCTION!");
      };
      m.__proto__ = Monad.prototype;
      m.cmd = guts;
      m.type = 'monad';
      return m;
    };
    makeSyncMonad = function(guts) {
      var m;
      m = makeMonad(guts);
      m.sync = true;
      return m;
    };
    nextMonad = function(cont) {
      return cont;
    };
    replaceErr = function(err, msg) {
      err.message = msg;
      return err;
    };
    defaultEnv.write = function(str) {
      return process.stdout.write(str);
    };
    defaultEnv.err = function(err) {
      var ref1;
      return this.write("ENV Error: " + ((ref1 = err.stack) != null ? ref1 : err));
    };
    defaultEnv.prompt = function() {
      throw new Error('Environment does not support prompting!');
    };
    monadModeSync = false;
    getMonadSyncMode = function() {
      return monadModeSync;
    };
    withSyncModeDo = function(newMode, block) {
      var err, error, oldMode, ref1;
      oldMode = monadModeSync;
      monadModeSync = newMode;
      try {
        return block();
      } catch (error) {
        err = error;
        return console.log("ERR: " + ((ref1 = err.stack) != null ? ref1 : err));
      } finally {

      }
    };
    runMonad = function(monad, env, cont) {
      env = env != null ? env : root.defaultEnv;
      return withSyncModeDo(true, function() {
        return newRunMonad(monad, env, cont, []);
      });
    };
    isMonad = function(m) {
      return typeof m === 'function' && (m.cmd != null);
    };
    continueMonads = function(contStack, env) {
      return function(result) {
        return withSyncModeDo(false, function() {
          return newRunMonad(result, env, null, contStack);
        });
      };
    };
    asyncMonad = {
      toString: function() {
        return "<asyncMonadResult>";
      }
    };
    warnAsync = false;
    setWarnAsync = function(state) {
      return warnAsync = state;
    };
    newRunMonad = function(monad, env, cont, contStack) {
      var err, error, ref1, result;
      if (cont) {
        contStack.push(cont);
      }
      try {
        while (true) {
          if (monad instanceof Monad2) {
            return runMonad2(monad, env, continueMonads(contStack, env), []);
          } else if (isMonad(monad)) {
            if (monad.binding) {
              (function(bnd) {
                return contStack.push(function(x) {
                  return rz(bnd)(lz(x));
                });
              })(monad.binding);
              monad = rz(monad.monad);
              continue;
            } else if (!monad.sync) {
              monadModeSync = false;
              if (warnAsync) {
                console.log("async monad");
              }
              monad.cmd(env, continueMonads(contStack, env));
              return asyncMonad;
            }
            result = monad.cmd(env, identity);
          } else {
            monadModeSync = true;
            result = monad;
          }
          if (!contStack.length) {
            return result;
          }
          monad = contStack.pop()(result);
        }
      } catch (error) {
        err = error;
        err = replaceErr(err, "\nERROR RUNNING MONAD, MONAD: " + monad + ", ENV: " + env + "...\n" + err.message);
        console.log((ref1 = err.stack) != null ? ref1 : err);
        if (env.errorHandlers.length) {
          return env.errorHandlers.pop()(err);
        }
      }
    };
    callBind = function(value, contStack) {
      var func, tmp, val;
      func = contStack.pop();
      val = lz(value);
      tmp = L_bind()(val)(lz(func));
      if (isMonad(tmp) && (tmp.monad === val || tmp.monad === value)) {
        console.log("peeling bind");
        return func(value);
      } else {
        return tmp;
      }
    };
    Monad = (function() {
      function Monad() {}

      Monad.prototype.toString = function() {
        return "Monad: " + (this.cmd.toString());
      };

      return Monad;

    })();
    (typeof global !== "undefined" && global !== null ? global : window).L_runMonads = function(array, env, cont) {
      return runMonad2(array.slice().reverse().reduce(function(result, element) {
        return bind(element, lz(function(x) {
          return rz(result);
        }));
      }), env != null ? env : root.defaultEnv, cont != null ? cont : resolve);
    };
    ensureLeisureClass('unit');
    Leisure_unit = (function(superClass) {
      extend(Leisure_unit, superClass);

      function Leisure_unit() {
        return Leisure_unit.__super__.constructor.apply(this, arguments);
      }

      Leisure_unit.prototype.toString = function() {
        return 'unit';
      };

      return Leisure_unit;

    })(LeisureObject);
    _unit = mkProto(Leisure_unit, setType((function(_x) {
      return rz(_x);
    }), 'unit'));
    define('define', function(name, arity, src, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          nakedDefine(rz(name), def, rz(arity), rz(src));
          return cont(_unit);
        });
      }
    });
    define('newDefine', function(name, arity, src, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new Monad2(function(env, cont) {
          var ref1;
          if ((ref1 = global.verbose) != null ? ref1.gen : void 0) {
            console.log("DEFINE: " + name);
          }
          nakedDefine(rz(name), def, rz(arity), rz(src), null, null, true);
          return cont(_unit);
        });
      }
    });
    if (global.L_DEBUG) {
      (typeof window !== "undefined" && window !== null ? window : global).runMonad2 = runMonad2 = function(monad, env, cont) {
        var err, error, ref1, st;
        if (monad instanceof Monad2) {
          if (!env) {
            env = {};
          }
          st = (ref1 = env.monadStack) != null ? ref1 : (env.monadStack = []);
          st.push(monad);
          try {
            monad.cmd(env, cont);
            return st.pop();
          } catch (error) {
            err = error;
            dumpMonadStack(err, env);
            throw err;
          }
        } else if (isMonad(monad)) {
          return monad.cmd(env, cont);
        } else {
          return cont(monad);
        }
      };
    } else if ((typeof window !== "undefined" && window !== null ? window : global).L_PROMISE_MONAD) {
      (typeof window !== "undefined" && window !== null ? window : global).runMonad2 = runMonad2 = function(monad, env, cont) {
        if (monad instanceof Monad2) {
          return new window.Promise(function(resolve, reject) {
            return monad.cmd(env, resolve);
          }).then(cont);
        } else if (isMonad(monad)) {
          return monad.cmd(env, cont);
        } else {
          return cont(monad);
        }
      };
    } else {
      (typeof window !== "undefined" && window !== null ? window : global).runMonad2 = runMonad2 = function(monad, env, cont) {
        var promiseSucceed, r, result, sync;
        if ((monad instanceof Monad2) || isMonad(monad)) {
          sync = false;
          promiseSucceed = null;
          r = null;
          result = monad.cmd(env, function(res) {
            sync = true;
            r = cont(res);
            if (promiseSucceed) {
              return promiseSucceed(r);
            } else {
              return r;
            }
          });
          if (sync) {
            return r;
          } else {
            return new Promise(function(succeed, fail) {
              promiseSucceed = succeed;
              return null;
            });
          }
        } else {
          return cont(monad);
        }
      };
    }
    if (global.L_DEBUG) {
      Monad2 = (function(superClass) {
        extend(Monad2, superClass);

        function Monad2(name1, cmd, cmdToString) {
          this.name = name1;
          this.cmd = cmd;
          this.cmdToString = cmdToString;
          this.err = new Error();
          if (typeof this.name === 'function') {
            this.cmdToString = this.cmd;
            this.cmd = this.name;
            this.name = null;
          }
          if (!this.cmdToString) {
            this.cmdToString = (function(_this) {
              return function() {
                return (name ? name + ": " : '') + _this.cmd.toString();
              };
            })(this);
          }
        }

        Monad2.prototype.stack = function() {
          var i, j, n;
          n = 0;
          for (i = j = 0; j < 3; i = ++j) {
            n = this.err.stack.indexOf('\n', n) + 1;
          }
          return this.err.stack.substring(n, this.err.stack.indexOf('\n', n)).trim().substring(3);
        };

        return Monad2;

      })(Monad);
    } else {
      Monad2 = (function(superClass) {
        extend(Monad2, superClass);

        function Monad2(name1, cmd, cmdToString) {
          this.name = name1;
          this.cmd = cmd;
          this.cmdToString = cmdToString;
          if (typeof this.name === 'function') {
            this.cmdToString = this.cmd;
            this.cmd = this.name;
            this.name = null;
          }
          if (!this.cmdToString) {
            this.cmdToString = (function(_this) {
              return function() {
                return (_this.name ? _this.name + ": " : '') + _this.cmd.toString();
              };
            })(this);
          }
        }

        return Monad2;

      })(Monad);
    }
    Monad2.prototype.toString = function() {
      return "Monad2: " + (this.cmdToString());
    };
    Monad3 = (function(superClass) {
      extend(Monad3, superClass);

      function Monad3(name1, cmd, cmdToString) {
        this.name = name1;
        this.cmd = cmd;
        this.cmdToString = cmdToString;
        this.err = new Error();
        if (typeof this.name === 'function') {
          this.cmdToString = this.cmd;
          this.cmd = this.name;
          this.name = null;
          if (!this.cmdToString) {
            this.cmdToString = (function(_this) {
              return function() {
                return (name ? name + ": " : '') + _this.cmd.toString();
              };
            })(this);
          }
        }
      }

      return Monad3;

    })(Monad);
    Monad3.prototype.toString = function() {
      return "Monad3: " + (this.cmdToString());
    };
    dumpMonadStack = function(err, env) {
      var j, len, n, ref1;
      if (global.L_DEBUG && !err.L_LOGGED && env.monadStack) {
        err.L_LOGGED = true;
        console.log('ERROR IN MONAD, STACK...');
        ref1 = env.monadStack;
        for (j = 0, len = ref1.length; j < len; j++) {
          n = ref1[j];
          console.log(n.name + ": " + (n.stack()));
        }
        return console.log();
      }
    };
    define('isMonad', function(m) {
      var val;
      val = rz(m);
      if (isMonad(val) || val instanceof Monad2 || val instanceof Monad3) {
        return _true;
      } else {
        return _false;
      }
    });
    define('dumpStack', new Monad2(function(env, cont) {
      var e;
      e = new Error();
      dumpMonadStack(e, env);
      console.log(e.stack);
      return cont(_unit);
    }));
    define('defer', function(v) {
      return new Monad2((function(env, cont) {
        return setTimeout((function() {
          return cont(rz(v));
        }), 1);
      }), function() {
        return "defer " + (rz(v));
      });
    });
    define('bind', bind = function(m, binding) {
      var bnd;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        bnd = new Monad2('bind', (function(env, cont) {
          var async, b, sync;
          b = bnd;
          while (b instanceof Monad2 && b.isBind) {
            sync = true;
            async = true;
            runMonad2(rz(b.arg), env, function(result) {
              b = rz(b.binding)(lz(result));
              if (sync) {
                return async = false;
              } else {
                return runMonad2(b, env, cont);
              }
            });
            sync = false;
            if (async) {
              return _true;
            }
          }
          return runMonad2(b, env, cont);
        }));
        bnd.isBind = true;
        bnd.arg = m;
        bnd.binding = binding;
        return bnd;
      }
    });
    define('pierce', function(value) {
      return new Monad2('bind', function(env, cont) {
        var ret;
        ret = null;
        runMonad2(rz(value), env, function(r) {
          return ret = cont(r);
        });
        return ret;
      });
    });
    envTag = 0;
    define('tagEnv', new Monad2('tagEnv', function(env, cont) {
      if (!env.tag) {
        env.tag = ++envTag;
      }
      return cont(lz(env.tag));
    }));
    define('currentTag', new Monad2('currentTag', function(env, cont) {
      return cont(lz(envTag));
    }));
    values = {};
    define('primBind', bind);
    define('protect', function(value) {
      return makeMonad(function(env, cont) {
        var hnd;
        hnd = function(err) {
          var ref1, ref2;
          console.log("PROTECTED ERROR: " + ((ref1 = err.stack) != null ? ref1 : err));
          return cont(left((ref2 = err.stack) != null ? ref2 : err));
        };
        env.errorHandlers.push(hnd);
        return runMonad2(rz(value), env, (function(result) {
          if (env.errorHandlers.length) {
            if (env.errorHandlers[env.errorHandlers.length - 1] === hnd) {
              env.errorHandlers.pop();
            } else if (_.inclues(env.errorHandlers, hnd)) {
              while (env.errorHandlers[env.errorHandlers.length - 1] !== hnd) {
                env.errorHandlers.pop();
              }
            }
          }
          return cont(right(result));
        }), []);
      });
    });
    actors = {};
    define('actor', function(name, func) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        actors[name] = func;
        func.env = {
          values: {}
        };
        return func.env.__proto__ = defaultEnv;
      }
    });
    define('send', function(name, msg) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return setTimeout((function() {
          return runMonad2(rz(actors[name])(msg), rz(actors[name]).env);
        }), 1);
      }
    });
    define('hasValue', function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(values[rz(name)] != null));
      });
    });
    define('getValueOr', function(name, defaultValue) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new Monad2(function(env, cont) {
          var ref1;
          return cont((ref1 = values[rz(name)]) != null ? ref1 : rz(defaultValue));
        });
      }
    });
    define('getValueOpt', function(name) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new Monad2(function(env, cont) {
          var v;
          if (v = values[rz(name)]) {
            return cont(some(v));
          } else {
            return cont(none);
          }
        });
      }
    });
    define('getValue', function(name) {
      return new Monad2('getValue', function(env, cont) {
        var v;
        if (v = values[rz(name)]) {
          return cont(v);
        } else {
          return cont(_unit);
        }
      });
    });
    define('setValue', function(name, value) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new Monad2('setValue', function(env, cont) {
          values[rz(name)] = rz(value);
          return cont(_unit);
        });
      }
    });
    define('deleteValue', function(name) {
      return new Monad2(function(env, cont) {
        delete values[rz(name)];
        return cont(_unit);
      });
    });
    setValue = function(key, value) {
      return values[key] = value;
    };
    getValue = function(key) {
      return values[key];
    };
    define('envHas', function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(env.values[rz(name)] != null));
      });
    });
    define('envGetOr', function(name, defaultValue) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var ref1;
          return cont((ref1 = env.values[rz(name)]) != null ? ref1 : rz(defaultValue));
        });
      }
    });
    define('envGet', function(name) {
      return makeSyncMonad(function(env, cont) {
        var ref1;
        return cont((ref1 = env.values[rz(name)]) != null ? ref1 : _unit);
      });
    });
    define('envGetOpt', function(name) {
      return makeSyncMonad(function(env, cont) {
        var v;
        return cont((v = env.values[rz(name)]) ? some(v) : none);
      });
    });
    define('envSet', function(name, value) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          env.values[rz(name)] = rz(value);
          return cont(_unit);
        });
      }
    });
    define('envDelete', function(name) {
      return makeSyncMonad(function(env, cont) {
        delete env.values[rz(name)];
        return cont(_unit);
      });
    });
    setValue('macros', Nil);
    define('defMacro', function(name, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          values.macros = cons(cons(rz(name), rz(def)), values.macros);
          return cont(_unit);
        });
      }
    });
    define('funcList', makeSyncMonad(function(env, cont) {
      return cont(consFrom(global.leisureFuncNames.toArray().sort()));
    }));
    define('funcs', makeSyncMonad(function(env, cont) {
      return cont(lz(global.leisureFuncNames));
    }));
    define('funcSrc', function(func) {
      var info;
      if (typeof rz(func) === 'function') {
        info = functionInfo[rz(func).leisureName];
        if (info != null ? info.src : void 0) {
          return some(info.src);
        } else {
          return none;
        }
      }
    });
    define('ast2Json', function(ast) {
      return JSON.stringify(ast2Json(rz(ast)));
    });
    define('override', function(name, newFunc) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSyncMonad(function(env, cont) {
          var n, oldDef;
          n = "L_" + (nameSub(rz(name)));
          oldDef = global[n];
          if (!oldDef) {
            throw new Error("No definition for " + (rz(name)));
          }
          global[n] = lz(rz(newFunc)(oldDef));
          return cont(_unit);
        });
      }
    });
    define('debug', function() {
      debugger;
      return _unit;
    });
    noMemo(L_debug);
    define('debugX', function(x) {
      debugger;
      return resolve(x);
    });
    define('gensym', makeSyncMonad(function(env, cont) {
      return cont("G" + (gensymCounter++));
    }));
    define('print', function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(env.presentValue(rz(msg)));
        return cont(_unit);
      });
    });
    define('print2', function(msg) {
      return new Monad2('print2', (function(env, cont) {
        env.write(env.presentValue(rz(msg)));
        return cont(_unit);
      }), function() {
        return "print2 " + (rz(msg));
      });
    });
    define('write', function(msg) {
      return new Monad2('write', (function(env, cont) {
        env.write(String(rz(msg)));
        return cont(_unit);
      }), function() {
        return "write " + (rz(msg));
      });
    });
    define('prompt', function(msg) {
      return new Monad2('promptDefault', (function(env, cont) {
        return env.prompt(String(rz(msg)), void 0, function(input) {
          return cont(input ? some(input) : none);
        });
      }), function() {
        return "prompt " + (rz(msg)) + " " + (rz(defaultValue));
      });
    });
    define('promptDefault', function(msg, defaultValue) {
      var r;
      if (r = doPartial(arguments)) {
        return r;
      } else {
        return new Monad2('promptDefault', (function(env, cont) {
          return env.prompt(String(rz(msg)), String(rz(defaultValue)), function(input) {
            return cont(input ? some(input) : none);
          });
        }), function() {
          return "prompt " + (rz(msg)) + " " + (rz(defaultValue));
        });
      }
    });
    define('oldWrite', function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(String(rz(msg)));
        return cont(_unit);
      });
    });
    define('readFile', function(name) {
      return new Monad2('readFile', function(env, cont) {
        return env.readFile(rz(name), function(err, contents) {
          var ref1;
          return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(contents)));
        });
      });
    });
    define('readDir', function(dir) {
      return new Monad2('readDir', function(env, cont) {
        return env.readDir(rz(dir), function(err, files) {
          var ref1;
          return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(files)));
        });
      });
    });
    define('writeFile', function(name, data) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return new Monad2('writeFile', function(env, cont) {
          return env.writeFile(rz(name), rz(data), function(err, contents) {
            var ref1;
            return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(contents)));
          });
        });
      }
    });
    define('statFile', function(file) {
      return makeMonad(function(env, cont) {
        return env.statFile(rz(file), function(err, stats) {
          var ref1;
          return cont((err ? left((ref1 = err.stack) != null ? ref1 : err) : right(stats)));
        });
      });
    });
    define('rand', makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    }));
    define('js', function(str) {
      return makeSyncMonad(function(env, cont) {
        var ref1;
        return ((ref1 = Leisure.setLounge) != null ? ref1 : function(e, cont) {
          return cont();
        })(env, function() {
          var err, error;
          try {
            return cont(right(leisurify(eval(rz(str)))));
          } catch (error) {
            err = error;
            return cont(left(err));
          }
        });
      });
    });
    leisurify = function(value) {
      if (typeof value === 'function') {
        if (!value.memo) {
          value.memo = nFunction(value.length, function() {
            var valueArgs;
            valueArgs = arguments;
            return new Monad2(function(env, cont) {
              return cont(value.apply(null, _.map(valueArgs, function(x) {
                return rz(x);
              })));
            });
          });
        }
        return value.memo;
      } else {
        return value;
      }
    };
    nFunction = function(nArgs, def) {
      var i;
      return (eval("(function (def) {\n  return function (" + (((function() {
        var j, ref1, results;
        results = [];
        for (i = j = 0, ref1 = nArgs; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
          results.push("arg" + i);
        }
        return results;
      })()).join(', ')) + ") {\n    return isPartial(arguments) ? partialCall(arguments) : def.apply(null, arguments);\n  };\n})"))(def);
    };
    define('delay', function(timeout) {
      return new Monad2(function(env, cont) {
        return setTimeout((function() {
          return cont(_unit);
        }), rz(timeout));
      });
    });
    define('currentTime', new Monad2(function(env, cont) {
      return cont(Date.now);
    }));
    define('once', makeSyncMonad((function() {
      var ran;
      ran = false;
      return function(env, cont) {
        if (!ran) {
          console.log("RUNNING");
          ran = true;
          return cont(_unit);
        } else {
          return console.log("ALREADY RAN");
        }
      };
    })()));
    advise = function(name, alt, arity, def) {
      var alts, i, info, newDef, nm;
      info = functionInfo[name];
      if (!info) {
        info = functionInfo[name] = {
          src: '',
          arity: -1,
          alts: {},
          altList: []
        };
      }
      if (!info.alts[alt]) {
        info.altList.push(alt);
      }
      info.alts[alt] = def;
      alts = (function() {
        var j, len, ref1, results;
        ref1 = info.altList;
        results = [];
        for (j = 0, len = ref1.length; j < len; j++) {
          i = ref1[j];
          results.push(info.alts[i]);
        }
        return results;
      })();
      alts.reverse();
      nm = "L_" + (nameSub(name));
      newDef = function() {
        var arg, j, len, len1, len2, o, opt, q, res;
        if (arguments.length !== arity) {
          return Leisure_primCall(arguments.callee, 0, arguments, arity);
        } else {
          for (j = 0, len = alts.length; j < len; j++) {
            alt = alts[j];
            opt = alt;
            for (o = 0, len1 = arguments.length; o < len1; o++) {
              arg = arguments[o];
              opt = opt(arg);
            }
            if (getType(opt) === 'some') {
              return opt(lz(function(x) {
                return rz(x);
              }))(lz(_false));
            }
          }
          if (info.mainDef) {
            res = info.mainDef;
            for (q = 0, len2 = arguments.length; q < len2; q++) {
              arg = arguments[q];
              res = res(arg);
            }
            return res;
          }
          throw new Error("No default definition for " + name);
        }
      };
      functionInfo[name].newArity = true;
      LeisureFunctionInfo.def = newDef;
      newDef.leisureName = name;
      global[nm] = global.leisureFuncNames[nm] = lz(newDef);
      return def;
    };
    define('advise', function(name, alt, arity, def) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeMonad(function(env, cont) {
          return cont(advise(rz(name), rz(alt), rz(arity), rz(def)));
        });
      }
    });
    curry = function(arity, func) {
      return function() {
        return lz(function(arg) {
          return lz((subcurry(arity, func, null))(arg));
        });
      };
    };
    subcurry = function(arity, func, args) {
      return lz(function(arg) {
        args = simpyCons(arg, args);
        if (arity === 1) {
          return func(args.toArray().reverse());
        } else {
          return subcurry(arity - 1, func, args);
        }
      });
    };
    presentationReplacements = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '\n': '\\n',
      '\\': '\\\\'
    };
    escapePresentationHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&\n\\]/g, function(c) {
          return presentationReplacements[c];
        });
      } else {
        return str;
      }
    };
    presentationToHtmlReplacements = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '\\n': '\n',
      '\\\\': '\\'
    };
    unescapePresentationHtml = function(str) {
      return str.replace(/&lt;|&gt;|&amp;|\\n|\\/g, function(c) {
        return presentationToHtmlReplacements[c];
      });
    };
    define('escapeHtml', function(h) {
      return escapePresentationHtml(rz(h));
    });
    define('unescapeHtml', function(h) {
      return unescapePresentationHtml(rz(h));
    });
    makeMap = function(map) {
      var h;
      h = function(f) {
        return f(map);
      };
      h.leisureType = 'hamt';
      return h;
    };
    hamt = makeMap(Map());
    hamt.leisureDataType = 'hamt';
    define('hamt', hamt);
    define('mapSet', function(key, value, map) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeMap(rz(map)(identity).set(rz(key), rz(value)));
      }
    });
    define('mapGet', function(key, map) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return rz(map)(identity).get(rz(key));
      }
    });
    define('mapGetOpt', function(key, map) {
      var v;
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        v = rz(map)(identity).get(rz(key));
        if (v !== void 0) {
          return some(v);
        } else {
          return none;
        }
      }
    });
    define('mapRemove', function(key, map) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeMap(rz(map)(identity).remove(rz(key)));
      }
    });
    define('mapFirst', function(map) {
      var key;
      map = rz(map)(identity);
      key = map.keySeq().first();
      return rz(L_cons)(lz(key))(lz(map.get(key)));
    });
    define('mapRest', function(map) {
      return makeMap(rz(map)(identity).rest());
    });
    define('mapPairs', function(map) {
      var h;
      h = rz(map)(identity);
      return nextMapPair(h, h.reverse().keySeq());
    });
    nextMapPair = function(map, keys) {
      var k;
      if (!keys.size) {
        return rz(L_nil);
      } else {
        k = keys.first();
        return rz(L_acons)(lz(k), lz(map.get(k)), function() {
          return nextMapPair(map, keys.rest());
        });
      }
    };
    define('mapReverse', function(map) {
      return makeMap(rz(map)(identity).reverse());
    });
    makeSet = function(set) {
      var s;
      s = function(f) {
        return f(set);
      };
      s.leisureType = 'amtSet';
      return s;
    };
    amtSet = makeSet(Set());
    amtSet.leisureDataType = 'amtSet';
    define('amtSet', amtSet);
    define('setAdd', function(value, set) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSet(rz(set)(identity).add(rz(value)));
      }
    });
    define('setRemove', function(value, set) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSet(rz(set)(identity)["delete"](rz(value)));
      }
    });
    define('setUnion', function(setA, setB) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSet(rz(setA)(identity).union(rz(setB)(identity)));
      }
    });
    define('setIntersect', function(setA, setB) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSet(rz(setA)(identity).intersect(rz(setB)(identity)));
      }
    });
    define('setSubtract', function(setA, setB) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSet(rz(setA)(identity).subtract(rz(setB)(identity)));
      }
    });
    define('setItems', function(set) {
      return nextSetItem(rz(set)(identity).reverse());
    });
    nextSetItem = function(s) {
      if (!s.size) {
        return rz(L_nil);
      } else {
        return rz(L_cons)(lz(s.first()), function() {
          return nextSetItem(s.rest());
        });
      }
    };
    define('setFirst', function(set) {
      return makeSet(rz(set)(identity).first());
    });
    define('setRest', function(set) {
      return makeSet(rz(set)(identity).rest());
    });
    define('setReverse', function(set) {
      return makeSet(rz(set)(identity).reverse());
    });
    makeVector = function(vec) {
      var v;
      v = function(f) {
        return f(vec);
      };
      v.leisureType = 'vector';
      return v;
    };
    vector = makeVector(List());
    vector.leisureDataType = 'vector';
    define('vector', vector);
    define('vectorPush', function(value, vec) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeVector(rz(vec)(identity).push(rz(value)));
      }
    });
    define('vectorPop', function(value, vec) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeVector(rz(vec)(identity).pop());
      }
    });
    define('vectorShift', function(value, vec) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeVector(rz(vec)(identity).shift());
      }
    });
    define('vectorUnshift', function(value, vec) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeVector(rz(vec)(identity).unshift(rz(value)));
      }
    });
    define('vectorConcatg', function(vecA, vecB) {
      if (isPartial(arguments)) {
        return partialCall(arguments);
      } else {
        return makeSet(rz(vecA)(identity).concat(rz(vecB)(identity)));
      }
    });
    define('vectorItems', function(vec) {
      return nextVectorItem(rz(vec)(identity));
    });
    nextVectorItem = function(v) {
      if (!v.size) {
        return rz(L_nil);
      } else {
        return rz(L_cons)(lz(v.first()), function() {
          return nextVectorItem(v.rest());
        });
      }
    };
    define('vectorFirst', function(vec) {
      return makeVector(rz(vec)(identity).first());
    });
    define('vectorRest', function(vec) {
      return makeVector(rz(vec)(identity).rest());
    });
    define('vectorReverse', function(vec) {
      return makeVector(rz(vec)(identity).reverse());
    });
    lacons = function(k, v, list) {
      return rz(L_acons)(lz(k), lz(v), lz(list));
    };
    jsonConvert = function(obj) {
      var k, t, v;
      if (obj instanceof Array) {
        return consFrom(_.map(obj, jsonConvert));
      } else if (typeof obj === 'object') {
        t = rz(L_nil);
        for (k in obj) {
          v = obj[k];
          t = lacons(k, jsonConvert(v), t);
        }
        return t;
      } else {
        return obj;
      }
    };
    define('fromJson', function(obj) {
      return jsonConvert(rz(obj));
    });
    define('parseYaml', function(obj) {
      return parseYaml(rz(obj));
    });
    define('toJsonArray', function(list) {
      var array;
      list = rz(list);
      array = [];
      while (!list.isNil()) {
        array.push(list.head());
        list = list.tail();
      }
      return array;
    });
    define('toJsonObject', function(list) {
      var obj;
      list = rz(list);
      obj = {};
      while (!list.isNil()) {
        head = list.head();
        if (obj[head.head()] == null) {
          obj[head.head()] = head.tail();
        }
        list = list.tail();
      }
      return obj;
    });
    define('jsonToYaml', function(json) {
      var err, error;
      try {
        return right(dump(rz(json)));
      } catch (error) {
        err = error;
        return left(err.stack);
      }
    });
    define('_withRecur', function(value) {
      var ret;
      ret = rz(value);
      while (getType(ret) === '_recur') {
        ret = ret(lz(_identity));
      }
      return ret;
    });
    define('setNameSpace', function(name) {
      return makeSyncMonad(function(env, cont) {
        var newNameSpace;
        root.currentNameSpace = rz(name);
        newNameSpace = false;
        if (name) {
          newNameSpace = !LeisureNameSpaces[name];
          if (newNameSpace) {
            LeisureNameSpaces[name] = {};
          }
          nsLog("SETTING NAME SPACE: " + name);
        }
        return cont((newNameSpace ? _true : _false));
      });
    });
    define('pushNameSpace', function(newNameSpace) {
      return makeSyncMonad(function(env, cont) {
        var pushed;
        pushed = LeisureNameSpaces[newNameSpace] && !(indexOf.call(root.nameSpacePath, newNameSpace) >= 0);
        if (pushed) {
          root.nameSpacePath.push(newNameSpace);
        }
        return cont((pushed ? _true : _false));
      });
    });
    define('clearNameSpacePath', makeSyncMonad(function(env, cont) {
      root.nameSpacePath = [];
      return cont(_unit);
    }));
    define('resetNameSpaceInfo', makeSyncMonad(function(enf, cont) {
      var old;
      old = [root.nameSpacePath, root.currentNameSpace];
      root.nameSpacePath = ['core'];
      root.currentNameSpace = null;
      nsLog("SETTING NAME SPACE: null");
      return cont(old);
    }));
    define('setNameSpaceInfo', function(info) {
      return makeSyncMonad(function(env, cont) {
        var ref1;
        ref1 = rz(info), root.nameSpacePath = ref1[0], root.currentNameSpace = ref1[1];
        nsLog("SETTING NAME SPACE: " + root.currentNameSpace);
        return cont(_unit);
      });
    });
    ensureLeisureClass('token');
    Leisure_token.prototype.toString = function() {
      return "Token(" + (JSON.stringify(tokenString(this))) + ", " + (posString(tokenPos(this))) + ")";
    };
    tokenString = function(t) {
      return t(lz(function(txt) {
        return function(pos) {
          return rz(txt);
        };
      }));
    };
    tokenPos = function(t) {
      return t(lz(function(txt) {
        return function(pos) {
          return rz(pos);
        };
      }));
    };
    ensureLeisureClass('filepos');
    posString = function(p) {
      if (p instanceof Leisure_filepos) {
        return p(lz(function(file) {
          return function(line) {
            return function(offset) {
              return (rz(file)) + ":" + (rz(line)) + "." + (rz(offset));
            };
          };
        }));
      } else {
        return p;
      }
    };
    ensureLeisureClass('parens');
    Leisure_parens.prototype.toString = function() {
      return "Parens(" + (posString(parensStart(this))) + ", " + (posString(parensEnd(this))) + ", " + (parensContent(this)) + ")";
    };
    parensStart = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(s);
          };
        };
      }));
    };
    parensEnd = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(e);
          };
        };
      }));
    };
    parensContent = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(l);
          };
        };
      }));
    };
    ensureLeisureClass('true');
    Leisure_true.prototype.toString = function() {
      return "true";
    };
    ensureLeisureClass('false');
    Leisure_false.prototype.toString = function() {
      return "false";
    };
    ensureLeisureClass('left');
    Leisure_left.prototype.toString = function() {
      return "Left(" + (this(lz(_identity))(lz(_identity))) + ")";
    };
    ensureLeisureClass('right');
    Leisure_right.prototype.toString = function() {
      return "Right(" + (this(lz(_identity))(lz(_identity))) + ")";
    };
    requireFiles = function(req, cont, verbose) {
      return (req.slice(0).reverse().reduce((function(acc, el) {
        return function() {
          if (verbose) {
            console.log("REQUIRING FILE: " + el);
          }
          return require([el], acc);
        };
      }), cont))();
    };
    define('funcInfo', function(f) {
      return funcInfo(rz(f));
    });
    define('funcName', function(f) {
      if (rz(f).leisureName) {
        return some(rz(f).leisureName);
      } else {
        return none;
      }
    });
    define('trackCreation', function(flag) {
      return makeSyncMonad(function(env, cont) {
        root.trackCreation = rz(flag)(lz(true))(lz(false));
        return cont(_unit);
      });
    });
    define('trackVars', function(flag) {
      return makeSyncMonad(function(env, cont) {
        root.trackVars = rz(flag)(lz(true))(lz(false));
        return cont(_unit);
      });
    });
    define('getFunction', function(name) {
      var f;
      f = rz(global['L_' + (nameSub(rz(name)))]);
      if (f) {
        return some(f);
      } else {
        return none;
      }
    });
    if (typeof window !== "undefined" && window !== null) {
      window.runMonad = runMonad;
      window.setType = setType;
      window.setDataType = setDataType;
      window.defaultEnv = defaultEnv;
      window.identity = identity;
    }
    Runtime = {
      requireFiles: requireFiles,
      _true: _true,
      _false: _false,
      _unit: _unit,
      _identity: _identity,
      some: some,
      none: none,
      stateValues: values,
      runMonad: runMonad,
      runMonad2: runMonad2,
      newRunMonad: newRunMonad,
      isMonad: isMonad,
      Monad2: Monad2,
      identity: identity,
      setValue: setValue,
      getValue: getValue,
      makeMonad: makeMonad,
      makeSyncMonad: makeSyncMonad,
      replaceErr: replaceErr,
      left: left,
      right: right,
      getMonadSyncMode: getMonadSyncMode,
      asyncMonad: asyncMonad,
      setWarnAsync: setWarnAsync,
      call: call,
      callMonad: callMonad,
      basicCall: basicCall,
      booleanFor: booleanFor,
      newConsFrom: consFrom,
      escapePresentationHtml: escapePresentationHtml,
      unescapePresentationHtml: unescapePresentationHtml,
      makeMap: makeMap,
      jsonConvert: jsonConvert,
      lacons: lacons,
      dumpMonadStack: dumpMonadStack,
      define: define,
      isPartial: isPartial,
      partialCall: partialCall,
      bind: bind
    };
    Object.assign(Leisure, {
      stateValues: values,
      runMonad: runMonad2,
      Runtime: Runtime,
      leisureFunctionNamed: leisureFunctionNamed,
      nameSub: nameSub,
      dbg: function() {
        debugger;
      }
    });
    return Runtime;
  });

}).call(this);

//# sourceMappingURL=runtime.js.map
