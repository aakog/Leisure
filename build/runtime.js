// Generated by CoffeeScript 2.2.4
(function() {
  /*
  Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

  (licensed with ZLIB license)

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.

  3. This notice may not be removed or altered from any source distribution.
  */
  'use strict';
  var splice = [].splice,
    indexOf = [].indexOf;

  define(['./base', './docOrg', './ast', 'lodash', 'immutable', 'lib/js-yaml', 'bluebird', 'browser-source-map-support'], function(Base, DocOrg, Ast, _, Immutable, Yaml, Bluebird) {
    var LeisureObject, Leisure_unit, List, Map, Monad2, Monad3, Nil, Promise, Runtime, Set, SimpyCons, _false, _identity, _true, _unit, actors, advise, amtSet, argNames, ast2Json, asyncMonad, basicCall, bind, booleanFor, buildAdvisedFunc, buildAdvisedFuncDef, call, callBind, callMonad, checkPartial, classForType, classNameForType, cons, consFrom, continueMonads, curry, debugTypes, declareTypeFunc, defaultEnv, define, dump, dumpMonadStack, ensureLeisureClass, envTag, escapePresentationHtml, funcInfo, functionInfo, gensymCounter, getDataType, getDebugType, getMonadSyncMode, getType, getValue, hamt, head, identity, io, isIO, isPartial, jsonConvert, lacons, lazy, lc, left, leisureFunctionNamed, leisurify, lz, makeMap, makeMonad, makeSet, makeSyncMonad, makeVector, mapFirst, mapRest, mkProto, monadModeSync, nFunction, nakedDefine, nameSub, newRunMonad, nextMapPair, nextMonad, nextSetItem, nextVectorItem, noMemo, none, nsLog, parensContent, parensEnd, parensStart, parseYaml, partialCall, posString, presentationReplacements, presentationToHtmlReplacements, readDir, readFile, replaceErr, requireFiles, resolve, right, root, runMonad, runMonad2, rz, setDataType, setRest, setType, setValue, setWarnAsync, simpyCons, some, statFile, strCoord, strFromList, strToList, subcurry, tail, tokenPos, tokenString, types, unescapePresentationHtml, unit, values, vector, vectorRest, warnAsync, withSyncModeDo, writeFile;
    if (typeof SourceMapSupport !== "undefined" && SourceMapSupport !== null) {
      SourceMapSupport.install();
    }
    ({readFile, statFile, readDir, writeFile, defaultEnv, SimpyCons, simpyCons, resolve, lazy, nsLog, funcInfo, argNames, getDebugType, debugTypes} = root = Base);
    ({parseYaml} = DocOrg);
    ({define, nakedDefine, cons, Nil, head, tail, getType, getDataType, ast2Json, ensureLeisureClass, LeisureObject, mkProto, setType, setDataType, functionInfo, nameSub, isPartial, partialCall, leisureFunctionNamed, LeisureObject, classNameForType, classForType, types, declareTypeFunc} = Ast);
    ({Map, Set, List} = Immutable);
    ({dump} = Yaml);
    ({Promise} = Bluebird);
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    gensymCounter = 0;
    functionInfo = (typeof window !== "undefined" && window !== null ? window : global).LeisureFunctionInfo;
    //(window ? global).L_PROMISE_MONAD = true

    //########
    // code
    //########
    checkPartial = (typeof window !== "undefined" && window !== null ? window : global).L_checkPartial = function(func, args, traceCreate, traceCall) {
      if (typeof func === 'string') {
        func = leisureFunctionNamed(func);
      }
      if (func.L$info.length !== args.length) {
        return Leisure_primCall(func, 0, args, func.length, traceCreate, traceCall);
      }
    };
    call = function(...args) {
      return basicCall(args, defaultEnv, identity);
    };
    callMonad = function(...args) {
      var cont, env, ref;
      ref = args, [...args] = ref, [env, cont] = splice.call(args, -2);
      return basicCall(args, env, cont);
    };
    basicCall = function(args, env, cont) {
      var arg, j, len, ref, res;
      res = rz(global[`L_${args[0]}`]);
      ref = args.slice(1);
      for (j = 0, len = ref.length; j < len; j++) {
        arg = ref[j];
        res = (function(arg) {
          return res(lz(arg));
        })(arg);
      }
      return runMonad2(res, env, cont);
    };
    consFrom = function(array, i) {
      i = i || 0;
      if (i < array.length) {
        return cons(array[i], consFrom(array, i + 1));
      } else {
        return rz(L_nil);
      }
    };
    noMemo = function(f) {
      Object.defineProperty(f, 'memo', {
        set: function() {}
      });
      return f;
    };
    //###########
    // LOGIC
    //###########
    identity = function(x) {
      return x;
    };
    _identity = function(x) {
      return rz(x);
    };
    _unit = setType((function(x) {
      return rz(x);
    }), 'unit');
    _true = setDataType(setType((function(a) {
      return function(b) {
        return rz(a);
      };
    }), 'true'), 'true');
    _false = setDataType(setType((function(a) {
      return function(b) {
        return rz(b);
      };
    }), 'false'), 'false');
    left = function(x) {
      return setType((function(lCase) {
        return function(rCase) {
          return rz(lCase)(lz(x));
        };
      }), 'left');
    };
    right = function(x) {
      return setType((function(lCase) {
        return function(rCase) {
          return rz(rCase)(lz(x));
        };
      }), 'right');
    };
    some = function(x) {
      return setType((function(someCase) {
        return function(noneCase) {
          return rz(someCase)(lz(x));
        };
      }), 'some');
    };
    none = setType((function(someCase) {
      return function(noneCase) {
        return rz(noneCase);
      };
    }), 'none');
    booleanFor = function(bool) {
      if (bool) {
        return rz(L_true);
      } else {
        return rz(L_false);
      }
    };
    (function() {
      'use strict';
      define('eq', function(a, b) {
        return checkPartial(L_eq, arguments) || booleanFor(rz(a) === rz(b));
      });
      define('==', function(a, b) {
        return checkPartial(L_$p$p, arguments) || booleanFor(rz(a) === rz(b));
      });
      define('!=', function(a, b) {
        return checkPartial(L_$k$p, arguments) || booleanFor(rz(a) !== rz(b));
      });
      define('hasType', function(data, func) {
        var hadFunc, type, typeName;
        return checkPartial(L_hasType, arguments) || (typeName = rz(func), typeof typeName !== 'string' ? (hadFunc = true, typeName = getDataType(rz(func))) : void 0, booleanFor(typeName === 'string' || typeName === 'number' ? typeof rz(data) === typeName : (type = typeName[0] === '*' ? (typeof window !== "undefined" && window !== null ? window : global)[typeName.substring(1)] : types[typeName], !type ? (!hadFunc ? console.log(new Error(`Warning, undeclared type ${typeName}, doing simple string compare`)) : void 0, getType(rz(data)) === typeName) : rz(data) instanceof type)));
      });
      define('getDataType', function(func) {
        if (typeof rz(func) === 'string') {
          return rz(func);
        } else {
          return getDataType(rz(func));
        }
      });
      // using arity makes compiling parseAst.lsr crash
      define('assert', function(bool, msg, expr) {
        return checkPartial(L_assert, arguments) || rz(bool)(expr)(function() {
          var err;
          err = new Error(rz(msg));
          //err.stack = "Leisure stack:\n#{err}\n   at #{L$thunkStack.reverse().join '\n   at '}\n\nJS Stack:\n#{err.stack}"
          console.error(err.stack);
          throw err;
        });
      });
      define('assertLog', function(bool) {
        return function(msg) {
          return function(expr) {
            return rz(bool)(expr)(function() {
              console.log(new Error(rz(msg)).stack);
              console.log("LOGGED ERROR -- RESUMING EXECUTION...");
              return rz(expr);
            });
          };
        };
      });
      define('trace', function(msg) {
        console.log("STACKTRACE: ", new Error(rz(msg)).stack);
        return msg;
      });
      define('jsTrue', function(x) {
        if (rz(x)) {
          return _true;
        } else {
          return _false;
        }
      });
      return define('error', function(msg) {
        throw new Error(rz(msg));
      });
    })();
    //###########
    // MATH
    //###########
    define('+', function(x, y) {
      return checkPartial(L_$o, arguments) || rz(x) + rz(y);
    });
    define('-', function(x, y) {
      return checkPartial(L_$_, arguments) || rz(x) - rz(y);
    });
    define('*', function(x, y) {
      return checkPartial(L_$g, arguments) || rz(x) * rz(y);
    });
    define('/', function(x, y) {
      return checkPartial(L_$f, arguments) || rz(x) / rz(y);
    });
    define('%', function(x, y) {
      return checkPartial(L_$A, arguments) || rz(x) % rz(y);
    });
    define('<', function(x, y) {
      return checkPartial(L_$y, arguments) || booleanFor(rz(x) < rz(y));
    });
    define('<=', function(x, y) {
      return checkPartial(L_$y$p, arguments) || booleanFor(rz(x) <= rz(y));
    });
    define('>', function(x, y) {
      return checkPartial(L_$z, arguments) || booleanFor(rz(x) > rz(y));
    });
    define('>=', function(x, y) {
      return checkPartial(L_$z$p, arguments) || booleanFor(rz(x) >= rz(y));
    });
    define('floor', function(x) {
      return Math.floor(rz(x));
    });
    define('ceil', function(x) {
      return Math.ceil(rz(x));
    });
    define('min', function(x, y) {
      return checkPartial(L_min, arguments) || Math.min(rz(x), rz(y));
    });
    define('max', function(x, y) {
      return checkPartial(L_max, arguments) || Math.max(rz(x), rz(y));
    });
    define('round', function(x) {
      return Math.round(rz(x));
    });
    define('abs', function(x) {
      return Math.abs(rz(x));
    });
    define('sqrt', function(x) {
      return Math.sqrt(rz(x));
    });
    define('acos', function(x) {
      return Math.acos(rz(x));
    });
    define('asin', function(x) {
      return Math.asin(rz(x));
    });
    define('atan', function(x) {
      return Math.atan(rz(x));
    });
    define('atan2', function(x, y) {
      return checkPartial(L_atan2, arguments) || Math.atan2(rz(x), rz(y));
    });
    define('cos', function(x) {
      return Math.cos(rz(x));
    });
    //define 'log', (x)-> Math.log(rz x)
    define('sin', function(x) {
      return Math.sin(rz(x));
    });
    define('tan', function(x) {
      return Math.tan(rz(x));
    });
    define('rand', function() {
      return makeSyncMonad(function(env, cont) {
        return cont(Math.random());
      });
    });
    define('randInt', function(low, high) {
      return checkPartial(L_randInt, arguments) || makeSyncMonad(function(env, cont) {
        return cont(Math.floor(rz(low) + Math.random() * rz(high)));
      });
    });
    define('^', function(x, y) {
      return checkPartial(L_$i, arguments) || Math.pow(rz(x), rz(y));
    });
    define('number', setDataType((function(n) {
      return Number(n);
    }), 'number'));
    //###########
    // STRINGS
    //###########
    define('_show', function(data) {
      var ref;
      if ((ref = typeof rz(data)) === 'string' || ref === 'number' || ref === 'boolean') {
        return JSON.stringify(rz(data));
      } else if (getType(rz(data)) === 'err') {
        return rz(L_errMsg)(data);
      } else {
        return String(rz(data));
      }
    });
    define('strString', function(data) {
      return String(rz(data));
    });
    define('_strAsc', function(str) {
      return rz(str).charCodeAt(0);
    });
    define('_strChr', function(i) {
      return String.fromCharCode(rz(i));
    });
    define('_strAt', function(str, index) {
      return checkPartial(L__strAt, arguments) || rz(str)[strCoord(rz(str), rz(index))];
    });
    define('_strStartsWith', function(str, prefix) {
      return checkPartial(L__strStartsWith, arguments) || booleanFor(rz(str).substring(0, rz(prefix).length) === rz(prefix));
    });
    define('_strLen', function(str) {
      return rz(str).length;
    });
    define('_strTrim', function(str) {
      return String(rz(str)).trim();
    });
    define('_strToLowerCase', function(str) {
      return rz(str).toLowerCase();
    });
    define('_strToUpperCase', function(str) {
      return rz(str).toUpperCase();
    });
    define('_strReverse', function(str) {
      var i, j, ref, result, s;
      s = rz(str);
      result = '';
      for (i = j = ref = s.length - 1; j >= 0; i = j += -1) {
        result += s[i];
      }
      return result;
    });
    define('_strReplace', function(str, pat, repl) {
      return checkPartial(L__strReplace, arguments) || rz(str).replace(rz(pat), rz(repl));
    });
    strCoord = function(str, coord) {
      if (coord < 0) {
        return str.length + coord;
      } else {
        return coord;
      }
    };
    define('_strSubstring', function(str, start, end) {
      var a, b, p;
      if (p = checkPartial(L__strSubstring, arguments)) {
        return p;
      } else {
        a = strCoord(rz(str), rz(start));
        b = strCoord(rz(str), rz(end));
        if (b < a && rz(end) === 0) {
          b = rz(str).length;
        }
        return rz(str).substring(a, b);
      }
    });
    define('_strSplit', function(str, pat) {
      return checkPartial(L__strSplit, arguments) || consFrom(rz(str).split(rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
    });
    define('_strJoin', function(list, sep) {
      return checkPartial(L__strJoin, arguments) || rz(list).toArray().join(rz(sep));
    });
    define('_strCat', function(list) {
      return _.map(rz(list).toArray(), function(el) {
        if (typeof el === 'string') {
          return el;
        } else {
          return rz(L_show)(lz(el));
        }
      }).join('');
    });
    define('_strAdd', function(s1, s2) {
      return checkPartial(L__strAdd, arguments) || rz(s1) + rz(s2);
    });
    define('_strMatch', function(str, pat) {
      var groups, m, p, pos;
      if (p = checkPartial(L__strMatch, arguments)) {
        return p;
      } else {
        m = rz(str).match((rz(pat) instanceof RegExp ? rz(pat) : new RegExp(rz(pat))));
        if (m) {
          groups = [];
          pos = 1;
          while (m[pos]) {
            groups.push(m[pos++]);
          }
          if (typeof m.index !== 'undefined') {
            return consFrom([m[0], consFrom(groups), m.index, m.input]);
          } else {
            return consFrom([m[0], consFrom(groups)]);
          }
        } else if (L_nil) {
          return rz(L_nil);
        } else {
          return Nil;
        }
      }
    });
    define('_strToList', function(str) {
      return strToList(rz(str));
    });
    strToList = function(str) {
      if (str === '') {
        return Nil;
      } else {
        return cons(str[0], strToList(str.substring(1)));
      }
    };
    define('_strFromList', function(list) {
      return strFromList(rz(list));
    });
    strFromList = function(list) {
      if (list instanceof Leisure_nil) {
        return '';
      } else {
        return head(list) + strFromList(tail(list));
      }
    };
    define('_regexp', function(str) {
      return new RegExp(rz(str));
    });
    define('_regexpFlags', function(str, flags) {
      return checkPartial(L__regexpFlags, arguments) || new RegExp(rz(str), rz(flags));
    });
    define('_jsonParse', function(str, failCont, successCont) {
      var err, p;
      if (p = checkPartial(L__jsonParse, arguments)) {
        return p;
      } else {
        try {
          //str = rz str
          //try
          //  p = JSON.parse str
          //catch err
          //  if str.match /^0+[0-9]/
          //    try
          //      p = JSON.parse str.replace /^0+/, ''
          //    catch err
          //  if p then return rz(failCont) lz err
          //rz(successCont) lz p
          p = JSON.parse(rz(str));
          return rz(successCont)(lz(p));
        } catch (error) {
          err = error;
          return rz(failCont)(lz(err));
        }
      }
    });
    define('jsonStringify', function(obj, failCont, successCont) {
      var err, p, s;
      if (p = checkPartial(L_jsonStringify, arguments)) {
        return p;
      } else {
        try {
          s = JSON.stringify(rz(obj));
          return rz(successCont)(lz(s));
        } catch (error) {
          err = error;
          return rz(failCont)(lz(err));
        }
      }
    });
    //###########
    // arrays
    //###########
    define('_sort', function(predicate, list) {
      var pred, result;
      return checkPartial(L__sort, arguments) || (result = rz(list).toArray(), pred = rz(predicate), result.sort(function(a, b) {
        return pred(a)(b)(-1)(1);
      }), consFrom(result));
    });
    //###########
    // properties
    //###########
    define('getProperties', function(func) {
      var ref;
      if ((ref = rz(func)) != null ? ref.properties : void 0) {
        return rz(func).properties;
      } else {
        return rz(L_nil);
      }
    });
    define('setProperty', function(func, name, value) {
      return checkPartial(L_setProperty, arguments) || makeSyncMonad(function(env, cont) {
        var f, ref;
        f = rz(func);
        f.properties = rz(L_aconsf)(name, value, lz((ref = f.properties) != null ? ref : rz(L_nil)));
        return cont(f.properties);
      });
    });
    //###########
    // Diagnostics
    //###########
    define('log', function(str, res) {
      return checkPartial(L_log, arguments) || (console.log(rz(str)), rz(res));
    });
    define('logStack', function(str, res) {
      return checkPartial(L_logStack, arguments) || (console.log(new Error(rz(str)).stack), rz(res));
    });
    // an identity function you can put a breakpoint on
    define('breakpoint', function(x) {
      console.log('Break point ', rz(x));
      return rz(x);
    });
    //###########
    // IO Monads
    //###########

    // Make a new function and hide func and binding in properties on it
    // making them inaccessible to pure Leisure code
    // so people won't accidentally fire off side effects
    makeMonad = function(guts) {
      var m;
      m = function() {
        throw new Error("ILLEGAL CALL TO MONAD FUNCTION!");
      };
      m.__proto__ = io.prototype;
      m.cmd = guts;
      m.type = 'io';
      return m;
    };
    makeSyncMonad = function(guts) {
      var m;
      m = makeMonad(guts);
      m.sync = true;
      return m;
    };
    nextMonad = function(cont) {
      return cont;
    };
    replaceErr = function(err, msg) {
      err.message = msg;
      return err;
    };
    defaultEnv.write = function(str) {
      return process.stdout.write(str);
    };
    defaultEnv.err = function(err) {
      var ref;
      return this.write(`ENV Error: ${(ref = err.stack) != null ? ref : err}`);
    };
    defaultEnv.prompt = function() {
      throw new Error('Environment does not support prompting!');
    };
    monadModeSync = false;
    getMonadSyncMode = function() {
      return monadModeSync;
    };
    withSyncModeDo = function(newMode, block) {
      var err, oldMode, ref;
      oldMode = monadModeSync;
      monadModeSync = newMode;
      try {
        return block();
      } catch (error) {
        err = error;
        return console.log(`ERR: ${(ref = err.stack) != null ? ref : err}`);
      } finally {

      }
    };
    //if !monadModeSync && oldMode then console.log "REENABLING SYNC"
    //monadModeSync = oldMode
    runMonad = function(monad, env, cont) {
      env = env != null ? env : root.defaultEnv;
      return withSyncModeDo(true, function() {
        return newRunMonad(monad, env, cont, []);
      });
    };
    isIO = function(v) {
      return typeof v === 'function' && (v.cmd != null);
    };
    continueMonads = function(contStack, env) {
      return function(result) {
        return withSyncModeDo(false, function() {
          return newRunMonad(result, env, null, contStack);
        });
      };
    };
    asyncMonad = {
      toString: function() {
        return "<asyncMonadResult>";
      }
    };
    warnAsync = false;
    setWarnAsync = function(state) {
      return warnAsync = state;
    };
    newRunMonad = function(monad, env, cont, contStack) {
      var err, ref, result;
      //if monad instanceof Monad2
      //  console.log 'MONAD 2'
      //  return runMonad2 monad, env, cont, contStack
      if (cont) {
        contStack.push(cont);
      }
      try {
        while (true) {
          //monad = L_asIO?()(lz monad) ? monad
          if (monad instanceof Monad2) {
            return runMonad2(monad, env, continueMonads(contStack, env), []);
          } else if (isIO(monad)) {
            if (monad.binding) {
              (function(bnd) {
                return contStack.push(function(x) {
                  return rz(bnd)(lz(x));
                });
              })(monad.binding);
              monad = rz(monad.monad);
              continue;
            } else if (!monad.sync) {
              monadModeSync = false;
              //console.log "turned off sync"
              if (warnAsync) {
                console.log("async monad");
              }
              monad.cmd(env, continueMonads(contStack, env));
              return asyncMonad;
            }
            result = monad.cmd(env, identity);
          } else {
            monadModeSync = true;
            result = monad;
          }
          if (!contStack.length) {
            return result;
          }
          monad = contStack.pop()(result);
        }
      } catch (error) {
        err = error;
        err = replaceErr(err, `\nERROR RUNNING MONAD, MONAD: ${monad}, ENV: ${env}...\n${err.message}`);
        console.log((ref = err.stack) != null ? ref : err);
        if (env.errorHandlers.length) {
          return env.errorHandlers.pop()(err);
        }
      }
    };
    callBind = function(value, contStack) {
      var func, tmp, val;
      func = contStack.pop();
      val = lz(value);
      tmp = L_bind()(val)(lz(func));
      if (isIO(tmp) && (tmp.monad === val || tmp.monad === value)) {
        console.log("peeling bind");
        return func(value);
      } else {
        return tmp;
      }
    };
    //if isIO(tmp) && tmp?.binding? then func value else tmp
    io = class io extends LeisureObject {
      toString() {
        return `Monad: ${this.cmd.toString()}`;
      }

    };
    declareTypeFunc('io', io);
    (typeof global !== "undefined" && global !== null ? global : window).L_runMonads = function(array, env, cont) {
      return runMonad2(array.slice().reverse().reduce(function(result, element) {
        return bind(element, lz(function(x) {
          return rz(result);
        }));
      }), env != null ? env : root.defaultEnv, cont != null ? cont : resolve);
    };
    ensureLeisureClass('unit');
    Leisure_unit = class Leisure_unit extends LeisureObject {
      toString() {
        return 'unit';
      }

    };
    _unit = mkProto(Leisure_unit, setType((function(_x) {
      return rz(_x);
    }), 'unit'));
    unit = function() {
      return L_unit || _unit;
    };
    define('define', function(name, arity, src, def) {
      return checkPartial(L_define, arguments) || makeSyncMonad(function(env, cont) {
        nakedDefine(rz(name), def, rz(arity), rz(src));
        return cont(unit());
      });
    });
    //  define 'newDefine', (name, arity, src, def)-> checkPartial(L_newDefine, arguments) ||
    //    new Monad2 (env, cont)->
    //      if global.verbose?.gen then console.log "DEFINE: #{name}"
    //      nakedDefine rz(name), def, rz(arity), rz(src), null, null, true
    //      cont unit()
    define('newDefine', function(name, arity, src, def, debugDef) {
      return checkPartial(L_newDefine, arguments) || new Monad2(function(env, cont) {
        var ref;
        if ((ref = global.verbose) != null ? ref.gen : void 0) {
          console.log(`DEFINE: ${name}`);
        }
        nakedDefine(rz(name), def, rz(arity), rz(src), null, null, true, false, getDebugType(), debugDef);
        //nakedDefine rz(name), def, rz(arity), rz(src), null, null, true
        return cont(unit());
      });
    });
    //  runMonads = (monads, i, arg)->
    //    if i < monads.length
    //      console.log "running monad #{i}"
    //      setTimeout (-> newRunMonad monads[i](arg), defaultEnv, ((x)-> runMonads monads, i + 1, x), []), 1

    //  global.L_runMonads = (monadArray)->
    //    console.log "RUNNING #{monadArray.length} monads, ..."
    //    runMonads monadArray, 0, 0
    //    monadArray
    if (global.L_DEBUG) {
      (typeof window !== "undefined" && window !== null ? window : global).runMonad2 = runMonad2 = function(monad, env, cont) {
        var err, ref, st;
        if (monad instanceof Monad2) {
          if (!env) {
            env = {};
          }
          st = (ref = env.monadStack) != null ? ref : (env.monadStack = []);
          st.push(monad);
          try {
            monad.cmd(env, cont);
            return st.pop();
          } catch (error) {
            err = error;
            dumpMonadStack(err, env);
            throw err;
          }
        } else if (isIO(monad)) {
          //console.log "OLD MONAD: #{monad}"
          return monad.cmd(env, cont);
        } else {
          return cont(monad);
        }
      };
    } else if ((typeof window !== "undefined" && window !== null ? window : global).L_PROMISE_MONAD) {
      (typeof window !== "undefined" && window !== null ? window : global).runMonad2 = runMonad2 = function(monad, env, cont) {
        if (monad instanceof Monad2) {
          return new window.Promise(function(resolve, reject) {
            return monad.cmd(env, resolve);
          }).then(cont);
        } else if (isIO(monad)) {
          //console.log "OLD MONAD: #{monad}"
          return monad.cmd(env, cont);
        } else {
          return cont(monad);
        }
      };
    } else {
      (typeof window !== "undefined" && window !== null ? window : global).runMonad2 = runMonad2 = function(monad, env, cont) {
        var promiseSucceed, r, result, sync;
        if ((monad instanceof Monad2) || isIO(monad)) {
          sync = false;
          promiseSucceed = null;
          r = null;
          result = monad.cmd(env, function(res) {
            sync = true;
            r = cont(res);
            if (promiseSucceed) {
              return promiseSucceed(r);
            } else {
              return r;
            }
          });
          if (sync) {
            return r;
          } else {
            return new Promise(function(succeed, fail) {
              promiseSucceed = succeed;
              return null;
            });
          }
        } else {
          return cont(monad);
        }
      };
    }
    if (global.L_DEBUG) {
      Monad2 = class Monad2 extends io {
        constructor(mname1, cmd, cmdToString) {
          super();
          this.mname = mname1;
          this.cmd = cmd;
          this.cmdToString = cmdToString;
          this.err = new Error();
          if (typeof this.mname === 'function') {
            this.cmdToString = this.cmd;
            this.cmd = this.mname;
            this.mname = null;
          }
          if (!this.cmdToString) {
            this.cmdToString = () => {
              return (name ? `${mname}: ` : '') + this.cmd.toString();
            };
          }
        }

        stack() {
          var i, j, n;
          n = 0;
          for (i = j = 0; j < 3; i = ++j) {
            n = this.err.stack.indexOf('\n', n) + 1;
          }
          return this.err.stack.substring(n, this.err.stack.indexOf('\n', n)).trim().substring(3);
        }

      };
    } else {
      Monad2 = class Monad2 extends io {
        constructor(mname1, cmd, cmdToString) {
          super();
          this.mname = mname1;
          this.cmd = cmd;
          this.cmdToString = cmdToString;
          if (typeof this.mname === 'function') {
            this.cmdToString = this.cmd;
            this.cmd = this.mname;
            this.mname = null;
          }
          if (!this.cmdToString) {
            this.cmdToString = () => {
              return (this.mname ? `${this.mname}: ` : '') + this.cmd.toString();
            };
          }
        }

      };
    }
    Monad2.prototype.toString = function() {
      return `Monad2: ${this.cmdToString()}`;
    };
    Monad3 = class Monad3 extends io {
      constructor(mname1, cmd, cmdToString) {
        super();
        this.mname = mname1;
        this.cmd = cmd;
        this.cmdToString = cmdToString;
        this.err = new Error();
        if (typeof this.mname === 'function') {
          this.cmdToString = this.cmd;
          this.cmd = this.mname;
          this.mname = null;
          if (!this.cmdToString) {
            this.cmdToString = () => {
              return (name ? `${mname}: ` : '') + this.cmd.toString();
            };
          }
        }
      }

    };
    Monad3.prototype.toString = function() {
      return `Monad3: ${this.cmdToString()}`;
    };
    dumpMonadStack = function(err, env) {
      var j, len, n, ref;
      if (global.L_DEBUG && !err.L_LOGGED && env.monadStack) {
        err.L_LOGGED = true;
        console.log('ERROR IN MONAD, STACK...');
        ref = env.monadStack;
        for (j = 0, len = ref.length; j < len; j++) {
          n = ref[j];
          console.log(`${n.mname}: ${n.stack()}`);
        }
        return console.log();
      }
    };
    define('isIO', function(m) {
      var val;
      val = rz(m);
      if (isIO(val) || val instanceof Monad2 || val instanceof Monad3) {
        return _true;
      } else {
        return _false;
      }
    });
    define('dumpStack', new Monad2(function(env, cont) {
      var e;
      e = new Error();
      dumpMonadStack(e, env);
      console.log(e.stack);
      return cont(unit());
    }));
    //  define 'return', (v)-> new Monad2 ((env, cont)-> cont rz v), -> "return #{rz v}"
    define('defer', function(v) {
      return new Monad2((function(env, cont) {
        return setTimeout((function() {
          return cont(rz(v));
        }), 1);
      }), function() {
        return `defer ${rz(v)}`;
      });
    });
    define('bind', bind = function(m, binding) {
      var bnd, p;
      if (p = checkPartial(L_bind, arguments)) {
        return p;
      } else {
        bnd = new Monad2('bind', (function(env, cont) {
          var async, b, sync;
          b = bnd;
          while (b instanceof Monad2 && b.isBind) {
            sync = true;
            async = true;
            runMonad2(rz(b.arg), env, function(result) {
              b = rz(b.binding)(lz(result));
              if (sync) {
                return async = false;
              } else {
                return runMonad2(b, env, cont);
              }
            });
            sync = false;
            if (async) {
              return _true;
            }
          }
          return runMonad2(b, env, cont);
        }));
        bnd.isBind = true;
        bnd.arg = m;
        bnd.binding = binding;
        return bnd;
      }
    });
    define('pierce', function(value) {
      return new Monad2('bind', function(env, cont) {
        var ret;
        ret = null;
        runMonad2(rz(value), env, function(r) {
          return ret = cont(r);
        });
        return ret;
      });
    });
    envTag = 0;
    define('tagEnv', new Monad2('tagEnv', function(env, cont) {
      if (!env.tag) {
        env.tag = ++envTag;
      }
      return cont(lz(env.tag));
    }));
    define('currentTag', new Monad2('currentTag', function(env, cont) {
      return cont(lz(envTag));
    }));
    values = {};
    define('primBind', bind);
    
    // Error handling

    define('protect', function(value) {
      return makeMonad(function(env, cont) {
        var hnd;
        hnd = function(err) {
          var ref, ref1;
          console.log(`PROTECTED ERROR: ${(ref = err.stack) != null ? ref : err}`);
          return cont(left((ref1 = err.stack) != null ? ref1 : err));
        };
        env.errorHandlers.push(hnd);
        return runMonad2(rz(value), env, (function(result) {
          //console.log "PROTECT CONTINUING WITH RESULT: #{result}"
          if (env.errorHandlers.length) {
            if (env.errorHandlers[env.errorHandlers.length - 1] === hnd) {
              env.errorHandlers.pop();
            } else if (_.inclues(env.errorHandlers, hnd)) {
              while (env.errorHandlers[env.errorHandlers.length - 1] !== hnd) {
                env.errorHandlers.pop();
              }
            }
          }
          return cont(right(result));
        }), []);
      });
    });
    
    // ACTORS

    // To create an actor:
    //   actor name function
    //     -- function takes one arg, to process messages
    //     -- if function returns a monad, it executes the monad

    // To send a message:
    //   send name message
    //     -- send message to the named actor

    actors = {};
    define('actor', function(name, func) {
      return checkPartial(L_actor, arguments) || (actors[name] = func, func.env = {
        values: {}
      }, func.env.__proto__ = defaultEnv);
    });
    define('send', function(name, msg) {
      return checkPartial(L_send, arguments) || setTimeout((function() {
        return runMonad2(rz(actors[name])(msg), rz(actors[name]).env);
      }), 1);
    });
    //#####
    //# global values
    //#####
    define('hasValue', function(name) {
      return makeSyncMonad(function(env, cont) {
        return cont(booleanFor(values[rz(name)] != null));
      });
    });
    define('getValueOr', function(name, defaultValue) {
      return checkPartial(L_getValueOr, arguments) || new Monad2(function(env, cont) {
        var ref;
        return cont((ref = values[rz(name)]) != null ? ref : rz(defaultValue));
      });
    });
    define('getValueOpt', function(name) {
      return checkPartial(L_getValueOpt, arguments) || new Monad2(function(env, cont) {
        var v;
        if (v = values[rz(name)]) {
          return cont(some(v));
        } else {
          return cont(none);
        }
      });
    });
    define('getValue', function(name) {
      return new Monad2('getValue', function(env, cont) {
        var v;
        if (v = values[rz(name)]) {
          return cont(v);
        } else {
          return cont(unit());
        }
      });
    });
    // New getValue for when the option monad is integrated with the parser
    //define 'getValue', (name)->
    //  makeSyncMonad (env, cont)->
    //    cont (if !(rz(name) of values) then none else some values[rz name])
    define('setValue', function(name, value) {
      return checkPartial(L_setValue, arguments) || new Monad2('setValue', function(env, cont) {
        values[rz(name)] = rz(value);
        return cont(unit());
      });
    });
    define('deleteValue', function(name) {
      return new Monad2(function(env, cont) {
        delete values[rz(name)];
        return cont(unit());
      });
    });
    setValue = function(key, value) {
      return values[key] = value;
    };
    getValue = function(key) {
      return values[key];
    };
    //#####
    //# local values
    //#####
    define('envHas', function(name) {
      return makeSyncMonad(function(env, cont) {
        var ref;
        return cont(booleanFor(((ref = env.values) != null ? ref[rz(name)] : void 0) != null));
      });
    });
    define('envGetOr', function(name, defaultValue) {
      return checkPartial(L_envGetOr, arguments) || makeSyncMonad(function(env, cont) {
        var ref, ref1;
        return cont((ref = (ref1 = env.values) != null ? ref1[rz(name)] : void 0) != null ? ref : rz(defaultValue));
      });
    });
    define('envGet', function(name) {
      return makeSyncMonad(function(env, cont) {
        var ref, ref1;
        return cont((ref = (ref1 = env.values) != null ? ref1[rz(name)] : void 0) != null ? ref : unit());
      });
    });
    define('envGetOpt', function(name) {
      return makeSyncMonad(function(env, cont) {
        var ref, v;
        return cont((v = (ref = env.values) != null ? ref[rz(name)] : void 0) != null ? some(v) : none);
      });
    });
    define('envSet', function(name, value) {
      return checkPartial(L_envSet, arguments) || makeSyncMonad(function(env, cont) {
        if (env.values == null) {
          env.values = {};
        }
        env.values[rz(name)] = rz(value);
        return cont(unit());
      });
    });
    define('envDelete', function(name) {
      return makeSyncMonad(function(env, cont) {
        if (env.values != null) {
          delete env.values[rz(name)];
        }
        return cont(unit());
      });
    });
    setValue('macros', Nil);
    define('defMacro', function(name, def) {
      return checkPartial(L_defMacro, arguments) || makeSyncMonad(function(env, cont) {
        values.macros = cons(cons(rz(name), rz(def)), values.macros);
        return cont(unit());
      });
    });
    define('funcList', makeSyncMonad(function(env, cont) {
      return cont(consFrom(global.leisureFuncNames.toArray().sort()));
    }));
    define('funcs', makeSyncMonad(function(env, cont) {
      return cont(lz(global.leisureFuncNames));
    }));
    define('funcSrc', function(func) {
      var info, ref;
      if (typeof rz(func) === 'function') {
        info = functionInfo[(ref = rz(func).L$info) != null ? ref.name : void 0];
        if (info != null ? info.src : void 0) {
          return some(info.src);
        } else {
          return none;
        }
      }
    });
    define('ast2Json', function(ast) {
      return JSON.stringify(ast2Json(rz(ast)));
    });
    define('override', function(name, newFunc) {
      return checkPartial(L_override, arguments) || makeSyncMonad(function(env, cont) {
        var n, oldDef;
        n = `L_${nameSub(rz(name))}`;
        oldDef = global[n];
        if (!oldDef) {
          throw new Error(`No definition for ${rz(name)}`);
        }
        global[n] = lz(rz(newFunc)(oldDef));
        return cont(unit());
      });
    });
    //######################
    // type cases
    //######################
    define('_defTypeCase', function(funcName, type, func) {
      var args, cl, dispFunc, dispatch, n, oldDef;
      return checkPartial(L__defTypeCase, arguments) || ((function() {
        var ref, ref1, ref2;
        funcName = rz(funcName);
        type = rz(type);
        func = rz(func);
        n = `L_${nameSub(funcName)}`;
        oldDef = (ref = (ref1 = functionInfo[funcName]) != null ? ref1.mainDef : void 0) != null ? ref : global[n];
        if (!(cl = classForType(type))) {
          throw new Error(`Attempt to define a type case for a nonexistent type: ${type}`);
        }
        if (!((ref2 = functionInfo[funcName]) != null ? ref2.typeCase : void 0)) {
          args = argNames(oldDef != null ? oldDef : func);
          dispatch = `"use strict";\n(function(${args.join(', ')}) {\n  return (resolve(${args[0]}).${n} || LeisureObject.prototype.${n} || function(){throw new Error("No typecase for ${funcName}." + L_getType(${args[0]}))}).apply(null, arguments);\n})`;
          dispFunc = lz(eval(dispatch));
          if (!global[n]) {
            nakedDefine(funcName, dispFunc, args.length, dispatch);
          } else {
            global[n] = global.leisureFuncs[n] = functionInfo[funcName].mainDef = dispFunc;
            if (!dispFunc.L$info) {
              dispFunc.L$info = {};
            }
            dispFunc.L$info.length = args.length;
            if (functionInfo[funcName].altList.length) {
              buildAdvisedFunc(funcName);
            }
          }
          functionInfo[funcName].typeCase = true;
          LeisureObject.prototype[n] = oldDef;
        }
        cl.prototype[n] = func;
        return unit();
      })());
    });
    define('_declareType', function(subtype, supertype) {
      var nilSupertype, subcl, supercl;
      return checkPartial(L__declareType, arguments) || ((function() {
        subtype = rz(subtype);
        supertype = rz(supertype);
        nilSupertype = supertype === 0;
        if (!nilSupertype && !(supercl = classForType(supertype))) {
          throw new Error(`Attempt to extend a nonexistant type: ${supertype}`);
        }
        if (subcl = classForType(subtype)) {
          if (supercl && subcl.prototype.__proto__ !== supercl.prototype) {
            subcl.prototype.__proto__ = supercl.prototype;
          }
        } else {
          subcl = ensureLeisureClass(subtype, !nilSupertype && supertype);
        }
        //if supercl
        //  subcl.prototype = Object.create(supercl.prototype)
        //  subcl.prototype.constructor = subcl
        return unit();
      })());
    });
    //######################
    // IO
    //######################

    //  define 'trace', (msg)->
    //    makeSyncMonad (env, cont)->
    //      cont (root.E = new Error(msg)).stack
    define('debug', function() {
      debugger;
      return unit();
    });
    noMemo(L_debug);
    define('debugX', function(x) {
      debugger;
      return resolve(x);
    });
    //define 'debug', new Monad2 'debug', (env, cont)->
    //    debugger
    //    cont unit()

    // TODO make this use eval.litcoffee's gensym
    define('gensym', makeSyncMonad(function(env, cont) {
      return cont(`G${gensymCounter++}`);
    }));
    define('print', function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(env.presentValue(rz(msg)));
        return cont(unit());
      });
    });
    define('print2', function(msg) {
      return new Monad2('print2', (function(env, cont) {
        env.write(env.presentValue(rz(msg)));
        return cont(unit());
      }), function() {
        return `print2 ${rz(msg)}`;
      });
    });
    define('write', function(msg) {
      return new Monad2('write', (function(env, cont) {
        env.write(String(rz(msg)));
        return cont(unit());
      }), function() {
        return `write ${rz(msg)}`;
      });
    });
    define('prompt', function(msg) {
      return new Monad2('promptDefault', (function(env, cont) {
        return env.prompt(String(rz(msg)), void 0, function(input) {
          return cont(input ? some(input) : none);
        });
      }), function() {
        return `prompt ${rz(msg)} ${rz(defaultValue)}`;
      });
    });
    define('promptDefault', function(msg, defaultValue) {
      var r;
      if (r = doPartial(arguments)) {
        return r;
      } else {
        return new Monad2('promptDefault', (function(env, cont) {
          return env.prompt(String(rz(msg)), String(rz(defaultValue)), function(input) {
            return cont(input ? some(input) : none);
          });
        }), function() {
          return `prompt ${rz(msg)} ${rz(defaultValue)}`;
        });
      }
    });
    define('oldWrite', function(msg) {
      return makeSyncMonad(function(env, cont) {
        env.write(String(rz(msg)));
        return cont(unit());
      });
    });
    define('readFile', function(name) {
      return new Monad2('readFile', function(env, cont) {
        return env.readFile(rz(name), function(err, contents) {
          var ref;
          return cont((err ? left((ref = err.stack) != null ? ref : err) : right(contents)));
        });
      });
    });
    define('readDir', function(dir) {
      return new Monad2('readDir', function(env, cont) {
        return env.readDir(rz(dir), function(err, files) {
          var ref;
          return cont((err ? left((ref = err.stack) != null ? ref : err) : right(files)));
        });
      });
    });
    define('writeFile', function(name, data) {
      return checkPartial(L_writeFile, arguments) || new Monad2('writeFile', function(env, cont) {
        return env.writeFile(rz(name), rz(data), function(err, contents) {
          var ref;
          return cont((err ? left((ref = err.stack) != null ? ref : err) : right(contents)));
        });
      });
    });
    define('statFile', function(file) {
      return makeMonad(function(env, cont) {
        return env.statFile(rz(file), function(err, stats) {
          var ref;
          return cont((err ? left((ref = err.stack) != null ? ref : err) : right(stats)));
        });
      });
    });
    define('rand', makeSyncMonad(function(env, cont) {
      return cont(Math.random());
    }));
    define('js', function(str) {
      return makeSyncMonad(function(env, cont) {
        var ref;
        return ((ref = Leisure.setLounge) != null ? ref : function(e, cont) {
          return cont();
        })(env, function() {
          var err;
          try {
            return cont(right(leisurify(eval(rz('"use strict";\n' + str)))));
          } catch (error) {
            err = error;
            return cont(left(err));
          }
        });
      });
    });
    leisurify = function(value) {
      if (typeof value === 'function') {
        if (!value.memo) {
          value.memo = nFunction(value.length, function() {
            var valueArgs;
            valueArgs = arguments;
            return new Monad2(function(env, cont) {
              return cont(value(...(_.map(valueArgs, function(x) {
                return rz(x);
              }))));
            });
          });
        }
        return value.memo;
      } else {
        return value;
      }
    };
    nFunction = function(nArgs, def) {
      var i;
      return (eval(`(function (def) {\n  return function (${((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = nArgs; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(`arg${i}`);
        }
        return results;
      })()).join(', ')}) {\n    return checkPartial(f, arguments) || def.apply(null, arguments);\n  };\n  //var f = function (${((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = nArgs; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
          results.push(`arg${i}`);
        }
        return results;
      })()).join(', ')}) {\n  //  return checkPartial(f, arguments) || def.apply(null, arguments);\n  //};\n  //return f;\n})`))(def);
    };
    define('delay', function(timeout) {
      return new Monad2(function(env, cont) {
        return setTimeout((function() {
          return cont(unit());
        }), rz(timeout));
      });
    });
    define('currentTime', new Monad2(function(env, cont) {
      return cont(Date.now);
    }));
    define('once', makeSyncMonad((function() {
      var ran;
      ran = false;
      return function(env, cont) {
        if (!ran) {
          console.log("RUNNING");
          ran = true;
          return cont(unit());
        } else {
          return console.log("ALREADY RAN");
        }
      };
    })()));
    //#################
    // Function advice
    //#################

    // later advice overrides earlier advice
    buildAdvisedFunc = function(name) {
      var currentDef, debugMain, info, main, nm;
      nm = `L_${nameSub(name)}`;
      info = functionInfo[name];
      main = buildAdvisedFuncDef(name, nm, info, info.alts, info.alts, info.mainDef);
      if (info.debugType) {
        debugMain = buildAdvisedFuncDef(name, nm, info, info.debugAlts, info.alts, info.mainDebugDef || info.mainDef);
      }
      currentDef = debugTypes[info.debugType] === 'active' ? debugMain : main;
      return global[nm] = global.leisureFuncNames[nm] = lz(currentDef);
    };
    buildAdvisedFuncDef = function(name, nm, info, alts, fallbackAlts, mainDef) {
      var i, newDef, ref;
      alts = (function() {
        var j, len, ref, results;
        ref = info.altList;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          i = ref[j];
          results.push(alts[i] || fallbackAlts[i]);
        }
        return results;
      })();
      alts.reverse();
      newDef = function() {
        var alt, arg, j, len, len1, len2, o, opt, p, q, res;
        if (p = checkPartial(mainDef, arguments)) {
          return p;
        } else {
          for (j = 0, len = alts.length; j < len; j++) {
            alt = alts[j];
            opt = alt;
// TODO -- once lambdas are properly generated, opt.apply(null, arguments)
            for (o = 0, len1 = arguments.length; o < len1; o++) {
              arg = arguments[o];
              opt = opt(arg);
            }
            if (getType(opt) === 'some') {
              return opt(lz(function(x) {
                return rz(x);
              }))(lz(_false));
            }
          }
          if (mainDef) {
            res = mainDef;
            for (q = 0, len2 = arguments.length; q < len2; q++) {
              arg = arguments[q];
              res = res(arg);
            }
            return res;
          }
          throw new Error(`No default definition for ${name}`);
        }
      };
      newDef.L$info = {
        length: (ref = info.mainDef) != null ? ref.L$info.length : void 0,
        name: name
      };
      functionInfo[name].newArity = true;
      return newDef;
    };
    advise = function(name, alt, arity, def) {
      var info;
      info = functionInfo[name];
      if (!info) {
        info = functionInfo[name] = {
          src: '',
          arity: -1,
          alts: {},
          altList: []
        };
      }
      if (!info.alts[alt]) {
        info.altList.push(alt);
      }
      info.alts[alt] = def;
      buildAdvisedFunc(name);
      return def;
    };
    define('advise', function(name, alt, arity, def) {
      return checkPartial(L_advise, arguments) || makeMonad(function(env, cont) {
        return cont(advise(rz(name), rz(alt), rz(arity), rz(def)));
      });
    });
    curry = function(arity, func) {
      return function() {
        return lz(function(arg) {
          return lz((subcurry(arity, func, null))(arg));
        });
      };
    };
    subcurry = function(arity, func, args) {
      return lz(function(arg) {
        //console.log "Got arg # #{arity}: #{rz arg}"
        args = simpyCons(arg, args);
        if (arity === 1) {
          return func(args.toArray().reverse());
        } else {
          return subcurry(arity - 1, func, args);
        }
      });
    };
    //######################
    // Presentation
    //######################
    presentationReplacements = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '\n': '\\n',
      '\\': '\\\\'
    };
    escapePresentationHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&\n\\]/g, function(c) {
          return presentationReplacements[c];
        });
      } else {
        return str;
      }
    };
    presentationToHtmlReplacements = {
      '&lt;': '<',
      '&gt;': '>',
      '&amp;': '&',
      '\\n': '\n',
      '\\\\': '\\'
    };
    unescapePresentationHtml = function(str) {
      return str.replace(/&lt;|&gt;|&amp;|\\n|\\/g, function(c) {
        return presentationToHtmlReplacements[c];
      });
    };
    define('escapeHtml', function(h) {
      return escapePresentationHtml(rz(h));
    });
    define('unescapeHtml', function(h) {
      return unescapePresentationHtml(rz(h));
    });
    //######################
    // AMTs
    //######################
    makeMap = function(map) {
      var h;
      h = function(f) {
        return f(function() {
          return mapFirst(map);
        })(function() {
          return mapRest(map);
        });
      };
      h.map = map;
      setType(h, 'hamt');
      h.leisureType = 'hamt';
      return h;
    };
    hamt = makeMap(Map());
    setDataType(hamt, 'hamt');
    define('hamt', hamt);
    define('mapSize', function(map) {
      return rz(map).map.size;
    });
    define('mapSet', function(key, value, map) {
      return checkPartial(L_mapSet, arguments) || makeMap(rz(map).map.set(rz(key), rz(value)));
    });
    define('mapGet', function(key, map) {
      var k, m;
      return checkPartial(L_mapGet, arguments) || (m = rz(map).map, k = rz(key), m.has(rz(key)) ? m.get(rz(key)) : Nil);
    });
    define('mapGetOpt', function(key, map) {
      var v;
      return checkPartial(L_mapGetOpt, arguments) || (v = rz(map).map.get(rz(key)), v !== void 0 ? some(v) : none);
    });
    define('mapRemove', function(key, map) {
      return checkPartial(L_mapRemove, arguments) || makeMap(rz(map).map.remove(rz(key)));
    });
    mapFirst = function(map) {
      var entry;
      entry = map.entrySeq().last();
      return rz(L_cons)(lz(entry[0]), lz(entry[1]));
    };
    define('mapFirst', function(map) {
      return mapFirst(rz(map).map);
    });
    mapRest = function(map) {
      return makeMap(map.butLast());
    };
    define('mapRest', function(map) {
      return mapRest(rz(map).map);
    });
    define('mapContains', function(item, map) {
      return checkPartial(L_mapContains, arguments) || booleanFor(rz(map).map.has(rz(item)));
    });
    define('mapPairs', function(map) {
      var h;
      h = rz(map).map.reverse();
      return nextMapPair(h, h.keySeq());
    });
    nextMapPair = function(map, keys) {
      var k;
      if (!keys.size) {
        return rz(L_nil);
      } else {
        k = keys.first();
        return rz(L_cons)(lz(rz(L_cons)(lz(k), lz(map.get(k)))), function() {
          return nextMapPair(map, keys.rest());
        });
      }
    };
    define('mapReverse', function(map) {
      return makeMap(rz(map).map.reverse());
    });
    makeSet = function(set) {
      var s;
      s = function(f) {
        return f(function() {
          return set.first();
        })(function() {
          return setRest(set);
        });
      };
      s.set = set;
      setType(s, 'amtSet');
      s.leisureType = 'amtSet';
      return s;
    };
    amtSet = makeSet(Set());
    setDataType(amtSet, 'amtSet');
    define('amtSet', amtSet);
    define('setSize', function(set) {
      return rz(set).set.size;
    });
    define('setContains', function(item, set) {
      return checkPartial(L_setContains, arguments) || booleanFor(rz(set).set.contains(rz(item)));
    });
    define('setAdd', function(value, set) {
      return checkPartial(L_setAdd, arguments) || makeSet(rz(set).set.add(rz(value)));
    });
    define('setRemove', function(value, set) {
      return checkPartial(L_setRemove, arguments) || makeSet(rz(set).set.delete(rz(value)));
    });
    define('setUnion', function(setA, setB) {
      return checkPartial(L_setUnion, arguments) || makeSet(rz(setA).set.union(rz(setB).set));
    });
    define('setIntersect', function(setA, setB) {
      return checkPartial(L_setIntersect, arguments) || makeSet(rz(setA).set.intersect(rz(setB).set));
    });
    define('setSubtract', function(setA, setB) {
      return checkPartial(L_setSubtract, arguments) || makeSet(rz(setA).set.subtract(rz(setB).set));
    });
    define('setItems', function(set) {
      return nextSetItem(rz(set).set.reverse());
    });
    nextSetItem = function(s) {
      if (!s.size) {
        return rz(L_nil);
      } else {
        return rz(L_cons)(lz(s.first()), function() {
          return nextSetItem(s.rest());
        });
      }
    };
    define('setFirst', function(set) {
      return rz(set).set.first();
    });
    setRest = function(set) {
      return makeSet(set.butLast());
    };
    define('setRest', function(set) {
      return setRest(rz(set).set);
    });
    define('setReverse', function(set) {
      return makeSet(rz(set).set.reverse());
    });
    makeVector = function(vec) {
      var v;
      v = function(f) {
        return f(function() {
          return vec.first();
        })(function() {
          return vectorRest(vec);
        });
      };
      v.vector = vec;
      setType(v, 'vector');
      v.leisureType = 'vector';
      return v;
    };
    vector = makeVector(List());
    setDataType(vector, 'vector');
    define('vector', vector);
    define('vectorSize', function(value, vec) {
      return rz(vec).vector.size;
    });
    define('vectorContains', function(item, vec) {
      return checkPartial(L_vectorContains, arguments) || booleanFor(rz(vec).vector.contains(rz(item)));
    });
    define('vectorPush', function(value, vec) {
      return checkPartial(L_vectorPush, arguments) || makeVector(rz(vec).vector.push(rz(value)));
    });
    define('vectorPop', function(value, vec) {
      return checkPartial(L_vectorPop, arguments) || makeVector(rz(vec).vector.pop());
    });
    define('vectorShift', function(value, vec) {
      return checkPartial(L_vectorShift, arguments) || makeVector(rz(vec).vector.shift());
    });
    define('vectorUnshift', function(value, vec) {
      return checkPartial(L_vectorUnshift, arguments) || makeVector(rz(vec).vector.unshift(rz(value)));
    });
    define('vectorConcat', function(vecA, vecB) {
      return checkPartial(L_vectorConcat, arguments) || makeVector(rz(vecA).vector.concat(rz(vecB).vector));
    });
    define('vectorItems', function(vec) {
      return nextVectorItem(rz(vec).vector);
    });
    nextVectorItem = function(v) {
      if (!v.size) {
        return rz(L_nil);
      } else {
        return rz(L_cons)(lz(v.first()), function() {
          return nextVectorItem(v.rest());
        });
      }
    };
    define('vectorFirst', function(vec) {
      return rz(vec).vector.first();
    });
    vectorRest = function(vec) {
      return makeVector(vec.rest());
    };
    define('vectorRest', function(vec) {
      return vectorRest(rz(vec).vector);
    });
    define('vectorReverse', function(vec) {
      return makeVector(rz(vec).vector.reverse());
    });
    define('vectorRemove', function(item, vec) {
      return checkPartial(L_vectorRemove, arguments) || (item = rz(item), makeVector(rz(vec).vector.filter(function(el) {
        return el !== item;
      })));
    });
    //################
    // YAML and JSON
    //################
    lacons = function(k, v, list) {
      return rz(L_acons)(lz(k), lz(v), lz(list));
    };
    jsonConvert = function(obj) {
      var k, t, v;
      if (obj instanceof Array) {
        return consFrom(_.map(obj, jsonConvert));
      } else if (typeof obj === 'object') {
        t = rz(L_nil);
        for (k in obj) {
          v = obj[k];
          t = lacons(k, jsonConvert(v), t);
        }
        return t;
      } else {
        return obj;
      }
    };
    define('fromJson', function(obj) {
      return jsonConvert(rz(obj));
    });
    define('parseYaml', function(obj) {
      return parseYaml(rz(obj));
    });
    define('toJsonArray', function(list) {
      var array;
      list = rz(list);
      array = [];
      while (!list.isNil()) {
        array.push(list.head());
        list = list.tail();
      }
      return array;
    });
    define('toJsonObject', function(list) {
      var obj;
      list = rz(list);
      obj = {};
      while (!list.isNil()) {
        head = list.head();
        if (obj[head.head()] == null) {
          obj[head.head()] = head.tail();
        }
        list = list.tail();
      }
      return obj;
    });
    define('jsonToYaml', function(json) {
      var err;
      try {
        return right(dump(rz(json)));
      } catch (error) {
        err = error;
        return left(err.stack);
      }
    });
    //######################
    // Control
    //######################
    define('protect', function(value) {
      var err;
      try {
        return right(rz(value));
      } catch (error) {
        err = error;
        return left(err);
      }
    });
    //######################
    // Trampolines
    //######################
    define('_withRecur', function(value) {
      var ret;
      ret = rz(value);
      while (getType(ret) === '_recur') {
        ret = ret(lz(_identity));
      }
      return ret;
    });
    //######################
    // NAME SPACES
    //######################
    define('setNameSpace', function(name) {
      return makeSyncMonad(function(env, cont) {
        var newNameSpace;
        root.currentNameSpace = rz(name);
        newNameSpace = false;
        if (name) {
          newNameSpace = !LeisureNameSpaces[name];
          if (newNameSpace) {
            LeisureNameSpaces[name] = {};
          }
          nsLog(`SETTING NAME SPACE: ${name}`);
        }
        return cont((newNameSpace ? _true : _false));
      });
    });
    define('pushNameSpace', function(newNameSpace) {
      return makeSyncMonad(function(env, cont) {
        var pushed;
        pushed = LeisureNameSpaces[newNameSpace] && !(indexOf.call(root.nameSpacePath, newNameSpace) >= 0);
        if (pushed) {
          root.nameSpacePath.push(newNameSpace);
        }
        return cont((pushed ? _true : _false));
      });
    });
    define('clearNameSpacePath', makeSyncMonad(function(env, cont) {
      root.nameSpacePath = [];
      return cont(unit());
    }));
    define('resetNameSpaceInfo', makeSyncMonad(function(enf, cont) {
      var old;
      old = [root.nameSpacePath, root.currentNameSpace];
      root.nameSpacePath = ['core'];
      root.currentNameSpace = null;
      nsLog("SETTING NAME SPACE: null");
      return cont(old);
    }));
    define('setNameSpaceInfo', function(info) {
      return makeSyncMonad(function(env, cont) {
        //console.log "RESTORING NAME SPACE INFO: #{require('util').inspect rz info}"
        [root.nameSpacePath, root.currentNameSpace] = rz(info);
        nsLog(`SETTING NAME SPACE: ${root.currentNameSpace}`);
        return cont(unit());
      });
    });
    //######################
    // Classes for Printing
    //######################
    ensureLeisureClass('token');
    Leisure_token.prototype.toString = function() {
      return `Token(${JSON.stringify(tokenString(this))}, ${posString(tokenPos(this))})`;
    };
    tokenString = function(t) {
      return t(lz(function(txt) {
        return function(pos) {
          return rz(txt);
        };
      }));
    };
    tokenPos = function(t) {
      return t(lz(function(txt) {
        return function(pos) {
          return rz(pos);
        };
      }));
    };
    ensureLeisureClass('filepos');
    posString = function(p) {
      if (p instanceof Leisure_filepos) {
        return p(lz(function(file) {
          return function(line) {
            return function(offset) {
              return `${rz(file)}:${rz(line)}.${rz(offset)}`;
            };
          };
        }));
      } else {
        return p;
      }
    };
    ensureLeisureClass('parens');
    Leisure_parens.prototype.toString = function() {
      return `Parens(${posString(parensStart(this))}, ${posString(parensEnd(this))}, ${parensContent(this)})`;
    };
    parensStart = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(s);
          };
        };
      }));
    };
    parensEnd = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(e);
          };
        };
      }));
    };
    parensContent = function(p) {
      return p(lz(function(s) {
        return function(e) {
          return function(l) {
            return rz(l);
          };
        };
      }));
    };
    ensureLeisureClass('true');
    Leisure_true.prototype.toString = function() {
      return "true";
    };
    ensureLeisureClass('false');
    Leisure_false.prototype.toString = function() {
      return "false";
    };
    ensureLeisureClass('left');
    Leisure_left.prototype.toString = function() {
      return `Left(${this(lz(_identity))(lz(_identity))})`;
    };
    ensureLeisureClass('right');
    Leisure_right.prototype.toString = function() {
      return `Right(${this(lz(_identity))(lz(_identity))})`;
    };
    //######################
    // LOADING
    //######################
    requireFiles = function(req, cont, verbose) {
      return (req.slice(0).reverse().reduce((function(acc, el) {
        return function() {
          if (verbose) {
            console.log(`REQUIRING FILE: ${el}`);
          }
          return require([el], acc);
        };
      }), cont))();
    };
    //######################
    // Func info
    //######################
    define('funcInfo', function(f) {
      return funcInfo(rz(f));
    });
    define('funcName', function(f) {
      var ref;
      if ((ref = rz(f).L$info) != null ? ref.name : void 0) {
        return some(rz(f).L$info.name);
      } else {
        return none;
      }
    });
    define('getFunction', function(name) {
      var f;
      f = rz(global['L_' + (nameSub(rz(name)))]);
      if (f) {
        return some(f);
      } else {
        return none;
      }
    });
    define('isType', function(f) {
      f = rz(f);
      return booleanFor(typeof f === 'function' && (f.typeFunction || f.dataType));
    });
    define('typeName', function(f) {
      var ref;
      return (ref = rz(f).L$info) != null ? ref.name : void 0;
    });
    //######################
    // Exports
    //######################
    if (typeof window !== "undefined" && window !== null) {
      window.runMonad = runMonad;
      window.setType = setType;
      window.setDataType = setDataType;
      window.defaultEnv = defaultEnv;
      window.identity = identity;
    }
    Runtime = {
      requireFiles,
      _true,
      _false,
      unit,
      _identity,
      some,
      none,
      stateValues: values,
      runMonad,
      runMonad2,
      newRunMonad,
      isIO,
      Monad2,
      identity,
      setValue,
      getValue,
      makeMonad,
      makeSyncMonad,
      replaceErr,
      left,
      right,
      getMonadSyncMode,
      asyncMonad,
      setWarnAsync,
      call,
      callMonad,
      basicCall,
      booleanFor,
      newConsFrom: consFrom,
      escapePresentationHtml,
      unescapePresentationHtml,
      makeMap,
      jsonConvert,
      lacons,
      dumpMonadStack,
      define,
      isPartial,
      partialCall,
      bind,
      buildAdvisedFuncDef
    };
    Object.assign(Leisure, {
      stateValues: values,
      runMonad: runMonad2,
      Runtime,
      leisureFunctionNamed,
      nameSub,
      dbg: function() {
        debugger;
      }
    });
    return Runtime;
  });

}).call(this);

//# sourceMappingURL=runtime.js.map
