// Generated by CoffeeScript 2.4.1
(function() {
  // Editing support for Leisure

  // This file customizes the editor so it can handle Leisure files.  Here is the Leisure
  // block structure:  ![Block structure](private/doc/blockStructure.png)
  'use strict';
  var indexOf = [].indexOf,
    splice = [].splice,
    slice1 = [].slice;

  define(['./base', './org', './docOrg', './ast', './utilities', './eval', './leisure-support', './editor', 'lodash', 'jquery', './ui', './db', 'handlebars', './lib/prism', './advice', 'lib/js-yaml', 'bluebird', 'immutable', 'fingertree', './tangle', 'lib/sha1'], function(Base, Org, DocOrg, Ast, Utilities, Eval, LeisureSupport, Editor, _, $, UI, DB, Handlebars, Prism, Advice, Yaml, Bluebird, Immutable, FingerTree, Tangle, SHA1) {
    var BasicEditingOptions, CodeContext, DataIndexer, DataStore, DataStoreEditingOptions, EditorParsedCodeBlock, Fragment, Headline, Html, LeisureEditCore, Map, NMap, Nil, OrgData, OrgEditing, ParsedCodeBlock, Promise, Set, actualSelectionUpdate, addChange, addController, addSelectionBubble, addView, afterMethod, ajaxGet, basicDataFilter, beforeMethod, blockCodeItems, blockElementId, blockEnvMaker, blockIsHidden, blockOrg, blockSource, blockText, blockVars, blockViewType, blocksObserved, breakpoint, bubbleLeftOffset, bubbleTopOffset, changeAdvice, compareSorted, configureMenu, controllerEval, copyBlock, createBlockEnv, createLocalData, defaultEnv, displayError, docBlockOrg, documentParams, dump, editorForToolbar, editorToolbar, escapeAttr, escapeHtml, escapeString, fileTypes, findEditor, followLink, getCodeItems, getDocumentParams, getId, getYaml, greduce, hasCodeAttribute, hasDatabase, headlineRE, initializePendingViews, installSelectionMenu, isContentEditable, isControl, isCss, isDynamic, isObserver, isPrefix, isSilent, isText, isYamlResult, keySplitPat, languageEnvMaker, last, localDb, localStore, localStoreName, makeBlobUrl, makeImageBlob, mergeContext, modifyingKey, monitorSelectionChange, orgDoc, parseOrgDoc, parseOrgMode, parseYaml, posFor, postCallPat, presentHtml, preserveSelection, removeController, removeView, renderView, replaceResult, replacementFor, sanitize, selectionActive, selectionMenu, setError, setLounge, setResult, shouldTangle, showHide, throttledUpdateSelection, toolbarFor, transaction, trickyChange, updateSelection, withContext, withDefaultOptsSet, writeResults;
    ({defaultEnv, CodeContext} = Base);
    ({parseOrgMode, Fragment, Headline, headlineRE} = Org);
    ({
      orgDoc,
      getCodeItems,
      blockSource,
      blockOrg: docBlockOrg,
      ParsedCodeBlock,
      parseYaml
    } = DocOrg);
    ({Nil} = Ast);
    ({ajaxGet} = Utilities);
    ({languageEnvMaker, Html, presentHtml, setLounge, blockVars, blocksObserved, hasCodeAttribute, isYamlResult, escapeString, writeResults} = Eval);
    ({LeisureEditCore, last, DataStore, DataStoreEditingOptions, blockText, posFor, escapeHtml, findEditor, copyBlock, preserveSelection, BasicEditingOptions, modifyingKey} = Editor);
    ({changeAdvice, afterMethod, beforeMethod} = Advice);
    ({addView, removeView, renderView, addController, removeController, withContext, mergeContext, initializePendingViews, escapeAttr} = UI);
    ({hasDatabase, transaction} = DB);
    ({dump} = Yaml);
    ({Map, Set} = Immutable);
    ({Promise} = Bluebird);
    ({shouldTangle} = Tangle);
    selectionActive = true;
    headlineRE = /^(\*+ *)(.*)(\n)$/;
    documentParams = null;
    localStoreName = 'leisureStorage';
    localDb = null;
    localStore = null;
    bubbleTopOffset = -5;
    bubbleLeftOffset = 0;
    keySplitPat = new RegExp(' +');
    postCallPat = /^([^(]*)\((.*)\)/;
    CodeContext.prototype.executeBlock = function(block, cont) {
      return this.executeText(blockSource(block), cont);
    };
    blockOrg = function(data, blockOrText) {
      var ref;
      return docBlockOrg((ref = (typeof blockOrText === 'string' ? data.getBlock(blockOrText) : void 0)) != null ? ref : blockOrText);
    };
    // `OrgData` -- a DataStore that supports block-structured org file data.
    // Each block has type 'headline', 'code', or 'chunk'.  Blocks use nextSibling
    // and previousSibling ids to indicate the tree structure of the org document
    // (there are no direct parent/child links).
    OrgData = class OrgData extends DataStore {
      constructor() {
        //DataStore.apply this, arguments
        super(arguments);
        this.disableObservation = true;
        this.pendingObserves = {};
        this.running = {};
        this.observers = new NMap();
        this.filters = [];
        this.initializeLocalData();
        this.pendingEvals = [];
        this.importPromise = Promise.resolve();
        this.tangles = {};
        this.titleBlocks = new Set();
        this.dataChanges = null;
        this.collaborativeCode = {};
        this.collaborativeBase = {};
        this.closeRegistration();
      }

      change(changes) {
        var ch;
        ch = this.makeChange(changes);
        return this.trigger('change', ch);
      }

      allowObservation(func) {
        var old;
        old = this.disableObservation;
        this.disableObservation = false;
        func();
        return this.disableObservation = old;
      }

      addImported(importFile, type, name) {
        if (typeof importFile === 'string') {
          if (this.importRecords[type][name]) {
            this.importRecords[type][name].push(importFile);
            return console.log(`Warning, conflicting block of type: ${type} imported from ${this.importRecords[type][name]}`);
          } else {
            return this.importRecords[type][name] = [importFile];
          }
        } else {
          return typeof importFile === 'boolean';
        }
      }

      initializeLocalData() {
        this.namedBlocks = {};
        this.localBlocks = {};
        this.indexer = new DataIndexer();
        this.imported = {
          css: {},
          view: {},
          control: {},
          data: {}
        };
        // At this point, there is no conflict handling for imports that use the
        // same names for blocks other than printing a warning.
        this.importedData = {};
        this.importRecords = {
          data: {},
          view: {},
          controller: {},
          importedFiles: {}
        };
        return transaction(this.localDocumentId()).getAll().then((allData) => {
          var deletes, j, len, name, results1;
          this.localBlocks = _.keyBy(allData, '_id');
          deletes = [];
          for (name in this.localBlocks) {
            if (!this.namedBlocks[name] || !(this.getBlockNamed(name)).local) {
              deletes.push(name);
            }
          }
          results1 = [];
          for (j = 0, len = deletes.length; j < len; j++) {
            name = deletes[j];
            results1.push(this.deleteLocalBlock(name));
          }
          return results1;
        });
      }

      replaceText(repl) {
        super.replaceText(repl);
        this.runTextFilters(repl);
        return this.scheduleEvals();
      }

      getImage(name, cont, fail) {
        return this.getFile(name, (function(contents) {
          var url;
          if (url = makeImageBlob(name, contents)) {
            return cont(url);
          } else {
            return fail(`Couldn't create image for ${{name}}`);
          }
        }), fail);
      }

      getBlock(thing, changes) {
        var ref, ref1;
        if (typeof thing === 'object') {
          return thing;
        } else {
          return (ref = (ref1 = changes != null ? changes.sets[thing] : void 0) != null ? ref1 : super.getBlock(thing)) != null ? ref : this.imported.data[thing];
        }
      }

      changesFor(first, oldBlocks, newBlocks) {
        var changes;
        changes = super.changesFor(first, oldBlocks, newBlocks);
        this.linkAllSiblings(changes);
        return changes;
      }

      // `load` -- not the best use of inheritance here, changes is specifically for P2POrgData :).
      // Let's just call this poetic license for the time being...
      load(name, text, context) {
        this.loadName = name;
        return this.makeChanges(() => {
          var block, changes, filter, id, j, len, newBlocks, ref, ref1, ref2;
          this.initializeLocalData();
          this.loading = true;
          this.suppressTriggers(() => {
            return super.load(name, text);
          });
          ref = this.filters;
          for (j = 0, len = ref.length; j < len; j++) {
            filter = ref[j];
            filter.clear(this);
          }
          newBlocks = this.blockList();
          changes = {
            sets: this.blocks,
            oldBlocks: [],
            newBlocks: newBlocks,
            first: this.first
          };
          this.linkAllSiblings(changes);
          ref1 = changes.sets;
          for (id in ref1) {
            block = ref1[id];
            this.checkImports(block);
          }
          this.runTextFilters(context);
          ref2 = changes.sets;
          for (id in ref2) {
            block = ref2[id];
            this.runFilters(null, block, context);
            this.checkChange(null, block);
          }
          this.scheduleEvals().then(() => {
            return this.trigger('load');
          });
          return this.loading = false;
        });
      }

      loadTangles(tangleText) {
        return eval(tangleText);
      }

      addTangle(block, code) {
        console.log(`ADDING TANGLE: ${block.hash}`);
        return this.tangles[block.hash] = code != null ? code : block;
      }

      hasTangle(block) {
        return this.getTangle(block);
      }

      getTangle(block) {
        var ref;
        return this.tangles[(ref = block.hash) != null ? ref : block.hash = SHA1.hash(block.text)];
      }

      tangleAddData(block, data) {
        this.addTangle(block);
        if (block.codeName) {
          return this.importedData[block.codeName] = block;
        }
      }

      tangleAddView(block, code) {
        this.addTangle(block);
        return this.checkViewChange(null, block, true);
      }

      tangleAddController(block, code) {
        return this.addTangle(block, code);
      }

      tangleAddObserver(block, code) {
        return this.addTangle(block, code);
      }

      tangleAddDef(block, code) {
        return this.addTangle(block, code);
      }

      setBlock(id, block) {
        return this.makeChanges(() => {
          this.runFilters(this.getBlock(id), block);
          return super.setBlock(id, block);
        });
      }

      contextForBlock(id, context) {
        var start;
        if (start = this.offsetForBlock(id)) {
          context.start = start;
          context.end = start + this.getBlock(id).text.length;
          return context;
        }
      }

      deleteBlock(id) {
        return this.makeChanges(() => {
          this.runFilters(this.getBlock(id), null);
          return super.deleteBlock(id);
        });
      }

      addFilter(filter) {
        return this.filters.push(filter);
      }

      removeFilter(filter) {
        return _.remove(this.filters, function(i) {
          return i === filter;
        });
      }

      runFilters(oldBlock, newBlock, context) {
        var filter, j, len, ref, results1;
        ref = this.filters;
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          filter = ref[j];
          results1.push(filter.replaceBlock(this, oldBlock, newBlock, context));
        }
        return results1;
      }

      runTextFilters(context) {
        var filter, j, len, ref, results1;
        if (context) {
          ref = this.filters;
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            filter = ref[j];
            results1.push(typeof filter.replaceText === "function" ? filter.replaceText(this, context) : void 0);
          }
          return results1;
        }
      }

      parseBlocks(text) {
        return parseOrgDoc(text);
      }

      nextSibling(thing, changes) {
        var ref;
        return this.getBlock((ref = this.getBlock(thing, changes)) != null ? ref.nextSibling : void 0, changes);
      }

      previousSibling(thing, changes) {
        return this.getBlock(this.getBlock(thing, changes).previousSibling, changes);
      }

      reducePreviousSiblings(thing, changes, func, arg) {
        return greduce(this.getBlock(thing, changes), changes, func, arg, (b) => {
          return this.getBlock(b.previousSibling, changes);
        });
      }

      reduceNextSiblings(thing, changes, func, arg) {
        return greduce(this.getBlock(thing, changes), changes, func, arg, (b) => {
          return this.getBlock(b.nextSibling, changes);
        });
      }

      lastSibling(thing, changes) {
        return this.reduceNextSiblings(thing, changes, (function(x, y) {
          return y;
        }), null);
      }

      firstSibling(thing, changes) {
        return this.reducePreviousSiblings(thing, changes, (function(x, y) {
          return y;
        }), null);
      }

      parent(thing, changes) {
        var ref;
        return this.getBlock((ref = this.firstSibling(thing, changes)) != null ? ref.prev : void 0, changes);
      }

      properties(thing) {
        var bl, props;
        props = {};
        bl = this.getBlock(thing);
        if (bl.type !== 'headline') {
          if (bl.type === 'code') {
            _.defaults(props, bl.codeAttributes);
            _.defaults(props, bl.properties);
          } else if (bl.type === 'chunk') {
            _.defaults(props, bl.properties);
          }
          bl = this.parent(bl);
        }
        while (bl) {
          this.scrapePropertiesInto(bl, props);
          bl = this.parent(bl);
        }
        return props;
      }

      scrapePropertiesInto(block, props) {
        var child, j, len, ref, results1;
        ref = this.children(block);
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          child = ref[j];
          if (child.type === 'chunk' && child.properties && !_.isEmpty(child.properties)) {
            results1.push(_.defaults(props, child.properties));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      firstChild(thing, changes) {
        var block, n;
        if ((block = this.getBlock(thing, changes)) && (n = this.getBlock(block.next, changes)) && !n.previousSibling) {
          return n;
        }
      }

      lastChild(thing, changes) {
        return this.lastSibling(this.firstChild(thing, changes), changes);
      }

      children(thing, changes) {
        var c;
        c = [];
        this.reduceNextSiblings(this.firstChild(thing, changes), changes, (function(x, y) {
          return c.push(y);
        }), null);
        return c;
      }

      // `nextRight` returns the next thing in the tree after this subtree, which is just the
      // next sibling if there is one, otherwise it's the closest "right uncle" of this node
      nextRight(thing, changes) {
        var sib;
        while (thing) {
          if (sib = this.nextSibling(thing, changes)) {
            return sib;
          }
          thing = this.parent(thing, changes);
        }
        return null;
      }

      // `linkAllSiblings` -- modify changes so that the sibling links will be correct when the changes are applied.
      linkAllSiblings(changes) {
        var block, cur, emptyNexts, id, parent, results1, sibling, stack;
        stack = [];
        parent = null;
        sibling = null;
        emptyNexts = {};
        cur = this.getBlock(changes.first, changes);
        while (cur) {
          if (cur.nextSibling) {
            emptyNexts[cur._id] = cur;
          }
          if (cur.type === 'headline') {
            while (parent && cur.level <= parent.level) {
              [parent, sibling] = stack.pop();
            }
          } else if (cur.type === 'chunk' && (cur.properties != null) && parent && !_(parent.propertiesBlocks).includes(cur._id)) {
            if (!parent.propertiesBlocks) {
              parent.propertiesBlocks = [];
            }
            parent.propertiesBlocks.push(cur._id);
          }
          if (sibling) {
            delete emptyNexts[sibling._id];
            if (sibling.nextSibling !== cur._id) {
              addChange(sibling, changes).nextSibling = cur._id;
            }
            if (cur.previousSibling !== sibling._id) {
              addChange(cur, changes).previousSibling = sibling._id;
            }
          } else if (cur.previousSibling) {
            delete addChange(cur, changes).previousSibling;
          }
          sibling = cur;
          if (cur.type === 'headline') {
            stack.push([parent, sibling]);
            parent = cur;
            sibling = null;
          }
          cur = this.getBlock(cur.next, changes);
        }
        results1 = [];
        for (id in emptyNexts) {
          block = emptyNexts[id];
          results1.push(delete addChange(block, changes).nextSibling);
        }
        return results1;
      }

      // `makeChange` -- handle incoming changes (local or remote).  This is for computations
      // that must be done regardless of the source of changes
      makeChange(changes) {
        var block, id, ref, ref1;
        ref = changes.sets;
        for (id in ref) {
          block = ref[id];
          this.checkImports(block);
        }
        ref1 = this.removesAndSets(changes);
        for (id in ref1) {
          block = ref1[id];
          if (block) {
            this.checkChange(this.getBlock(id), block != null ? block : null);
          }
        }
        return super.makeChange(changes);
      }

      removesAndSets({sets, removes}) {
        var blocks, id;
        blocks = {};
        for (id in removes) {
          blocks[id] = false;
        }
        Object.assign(blocks, sets);
        return blocks;
      }

      processDefaults(lorgText) {
        var block, id, j, len, viewBlocks;
        viewBlocks = parseOrgDoc(lorgText);
        id = 0;
        for (j = 0, len = viewBlocks.length; j < len; j++) {
          block = viewBlocks[j];
          block._id = `default-${id++}`;
          this.checkChange(null, block, true);
        }
        return this.scheduleEvals();
      }

      checkChange(oldBlock, newBlock, isDefault) {
        this.checkIndexChange(oldBlock, newBlock, isDefault);
        this.checkPropChange(oldBlock, newBlock, isDefault);
        this.checkCssChange(oldBlock, newBlock, isDefault);
        this.checkCodeChange(oldBlock, newBlock, isDefault);
        this.checkChannelChange(oldBlock, newBlock);
        this.checkViewChange(oldBlock, newBlock, isDefault);
        return this.checkControlChange(oldBlock, newBlock, isDefault);
      }

      checkIndexChange(oldBlock, newBlock, isDefault) {
        var j, k, key, keys, l, len, len1, ref, ref1, ref2, ref3, results1;
        if (newBlock) {
          if (keys = this.indexer.keysFor(newBlock)) {
            newBlock.keys = keys;
          } else {
            delete newBlock.keys;
          }
        }
        if (!(_.isEqual(newBlock != null ? newBlock.keys : void 0, oldBlock != null ? oldBlock.keys : void 0))) {
          if (oldBlock != null ? oldBlock.keys : void 0) {
            k = (ref = newBlock != null ? newBlock.keys : void 0) != null ? ref : [];
            ref1 = oldBlock.keys;
            for (j = 0, len = ref1.length; j < len; j++) {
              key = ref1[j];
              if (!(indexOf.call(k, key) >= 0)) {
                this.deleteBlockKey({
                  id: oldBlock._id,
                  key: key
                });
              }
            }
          }
          if (newBlock.keys) {
            k = (ref2 = oldBlock != null ? oldBlock.keys : void 0) != null ? ref2 : [];
            ref3 = newBlock.keys;
            results1 = [];
            for (l = 0, len1 = ref3.length; l < len1; l++) {
              key = ref3[l];
              if (!(indexOf.call(k, key) >= 0)) {
                results1.push(this.addBlockKey({
                  id: newBlock._id,
                  key: key
                }));
              }
            }
            return results1;
          }
        }
      }

      addBlockKey(k) {
        return this.indexer.addBlockKey(k);
      }

      deleteBlockKey(k) {
        return this.indexer.deleteBlockKey(k);
      }

      find(index, key) {
        return this.indexer.find(index, key);
      }

      queueEval(func) {
        var opts;
        opts = defaultEnv.opts;
        return this.pendingEvals.push(function() {
          return withDefaultOptsSet(opts, func);
        });
      }

      runOnImport(func) {
        if (this.importPromise.isResolved) {
          func();
          return this.importPromise;
        } else {
          return this.importPromise.then(() => {
            func();
            return null;
          });
        }
      }

      scheduleEvals() {
        return this.runOnImport(() => {
          var e, func, j, len;
          if (this.pendingEvals.length) {
            e = this.pendingEvals;
            this.pendingEvals = [];
            for (j = 0, len = e.length; j < len; j++) {
              func = e[j];
              func();
            }
          }
          if (!_.isEmpty(this.pendingObserves)) {
            return this.allowObservation(() => {
              var blocked, k, oldRunning, p, results1;
              blocked = {};
              oldRunning = {};
              try {
                results1 = [];
                while (!_.isEmpty(this.pendingObserves)) {
                  p = this.pendingObserves;
                  this.pendingObserves = {};
                  results1.push(this.withLounge(() => {
                    return preserveSelection(() => {
                      var block, blockId, obs, ref, results2, subject;
                      results2 = [];
                      for (blockId in p) {
                        subject = p[blockId];
                        if (!this.running[blockId] && (block = this.getBlock(blockId))) {
                          blocked[blockId] = true;
                          oldRunning[blockId] = this.running[blockId];
                          this.running[blockId] = true;
                          if ((ref = (obs = block.observer)) != null) {
                            if (typeof ref.observe === "function") {
                              ref.observe(subject);
                            }
                          }
                          if (!this.getBlock(block._id).observer) {
                            results2.push(this.getBlock(block._id).observer = obs);
                          } else {
                            results2.push(void 0);
                          }
                        } else {
                          results2.push(void 0);
                        }
                      }
                      return results2;
                    });
                  }));
                }
                return results1;
              } finally {
                for (k in blocked) {
                  this.running[k] = oldRunning[k];
                }
              }
            });
          }
        });
      }

      withLounge(func) {
        var env;
        env = Object.create(defaultEnv);
        env.data = this;
        return setLounge(env, func);
      }

      triggerUpdate(...channelKeys) {
        var block, id, items, ref, v;
        ref = channelKeys, [...channelKeys] = ref, [block] = splice.call(channelKeys, -1);
        if (items = this.observers.get(...channelKeys)) {
          for (id in items) {
            v = items[id];
            if (v === true && block._id !== id && !this.running[id]) {
              // verify that it's exactly equal to true
              // if not, then it's not really an observer
              this.pendingObserves[id] = block;
            }
          }
        }
        return null;
      }

      checkPropChange(oldBlock, newBlock, isDefault) {
        var newProperties, parent, ref, ref1, sets, t;
        if ((oldBlock != null ? oldBlock.title : void 0) && !newBlock.title) {
          this.titleBlocks.delete(oldBlock._id);
          t = null;
          this.titleBlocks.forEach(function(v) {
            return t = v;
          });
          if (t) {
            document.title = t;
          } else {
            document.title = document.location;
          }
        } else if (newBlock.title) {
          this.titleBlocks.add(newBlock._id);
          this.title = document.title = newBlock.title;
        }
        if (!isDefault && !(newBlock != null ? newBlock.level : void 0) && !_.isEqual(oldBlock != null ? oldBlock.properties : void 0, newBlock != null ? newBlock.properties : void 0) && (parent = this.parent(newBlock != null ? newBlock : oldBlock))) {
          newProperties = _.defaults((ref = this.parseBlocks(parent.text).properties) != null ? ref : {}, (ref1 = newBlock.properties) != null ? ref1 : {});
          if (!_.isEqual(parent.properties, newProperties)) {
            sets = {};
            sets[parent._id] = parent;
            parent.properties = newProperties;
            return setTimeout((() => {
              return this.change({
                first: this.getFirst(),
                sets,
                removes: {},
                oldBlocks: [],
                newBlocks: [parent]
              });
            }), 1);
          }
        }
      }

      checkCssChange(oldBlock, newBlock, isDefault) {
        if (isCss(oldBlock) || isCss(newBlock)) {
          $(`#css-${blockElementId(oldBlock) || blockElementId(newBlock)}`).filter('style').remove();
        }
        if (isCss(newBlock)) {
          return $('head').append(`<style id='css-${blockElementId(newBlock)}'>${blockSource(newBlock)}</style>`);
        }
      }

      checkCodeChange(oldBlock, newBlock, isDefault) {
        var newName, oldName, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, resultType;
        if (newBlock && this.running[newBlock._id]) {
          return;
        }
        oldName = (ref = oldBlock != null ? oldBlock.codeName : void 0) != null ? ref : (oldBlock != null ? oldBlock.type : void 0) === 'headline' && (oldBlock != null ? (ref1 = oldBlock.properties) != null ? ref1.name : void 0 : void 0);
        newName = (ref2 = newBlock != null ? newBlock.codeName : void 0) != null ? ref2 : (newBlock != null ? newBlock.type : void 0) === 'headline' && (newBlock != null ? (ref3 = newBlock.properties) != null ? ref3.name : void 0 : void 0);
        if (oldName !== newName) {
          if (oldName) {
            this.deleteBlockName(oldName);
          }
          if (newName && (!isDefault || this.addImported(isDefault, 'data', newName))) {
            this.setBlockName(newName, newBlock._id, isDefault);
          }
        }
        if (isDefault && (newName || ((ref4 = newBlock.codeAttributes) != null ? ref4.observe : void 0))) {
          this.imported.data[newBlock._id] = newBlock;
        }
        if ((oldBlock != null ? oldBlock.local : void 0) && !(newBlock != null ? newBlock.local : void 0)) {
          this.deleteLocalBlock(oldName);
        }
        if ((resultType = (ref5 = newBlock != null ? (ref6 = newBlock.codeAttributes) != null ? (ref7 = ref6.results) != null ? ref7.toLowerCase() : void 0 : void 0 : void 0) === 'def' || ref5 === 'web') || (resultType = ((newBlock != null ? (ref8 = newBlock.codeAttributes) != null ? ref8.observe : void 0 : void 0) != null) && 'observe')) {
          return this.queueEval(() => {
            var r;
            if (resultType === 'observe') {
              this.updateObserver(newBlock, oldBlock);
              this.createObserver(newBlock);
              if (newBlock.codeAttributes.observe === 'system.document') {
                return this.pendingObserves[newBlock._id] = newBlock;
              }
            } else {
              this.openRegistration();
              r = this.executeBlock(newBlock);
              if (r instanceof Promise) {
                return r.finally(() => {
                  return this.closeRegistration();
                });
              } else {
                return this.closeRegistration();
              }
            }
          });
        }
      }

      createObserver(block) {
        var blockId, env, silent, sync;
        env = this.env(block.language);
        blockId = block._id;
        sync = false;
        silent = isSilent(block);
        if (!silent) {
          if (isYamlResult(block)) {
            env.write = function(str) {
              result += str;
              if (result[result.length - 1] !== '\n') {
                result += '\n';
              }
              if (!sync) {
                return this.replaceResult(change._id, result);
              }
            };
          } else {
            env.write = function(str) {
              result += presentHtml(str);
              if (result[result.length - 1] !== '\n') {
                result += '\n';
              }
              if (!sync) {
                return this.replaceResult(change._id, result);
              }
            };
          }
        }
        block.observer = new CodeContext();
        block.observer.data = this;
        return block.observer.observe = (...channelArgs) => {
          var err, ref, res;
          sync = true;
          try {
            res = this.getCode(blockId).call(block.observer, null, ...channelArgs);
            if (!silent) {
              this.replaceResult(blockId, env.formatResult(this.getBlock(blockId), '', res));
            }
          } catch (error1) {
            err = error1;
            if (!silent) {
              this.replaceResult(blockId, `: ${((ref = err.stack) != null ? ref : err.message).replace(/\n/g, '\n: ')}`);
            } else {
              console.error(err);
            }
          }
          return sync = false;
        };
      }

      checkChannelChange(oldBlock, newBlock) {
        var channel, channels, j, len, name, ref, ref1, ref2, type;
        if (!this.disableObservation) {
          this.triggerUpdate('system', 'document', newBlock);
          if (newBlock.type === 'code') {
            this.triggerUpdate('system', 'code', newBlock);
          }
          if (type = (ref = this.getYaml(newBlock)) != null ? ref.type : void 0) {
            this.triggerUpdate('type', type, newBlock);
          }
          if (name = newBlock != null ? newBlock.codeName : void 0) {
            this.triggerUpdate('block', name, newBlock);
          }
          if (channels = newBlock != null ? (ref1 = newBlock.codeAttributes) != null ? ref1.channels : void 0 : void 0) {
            ref2 = channels.split(' ');
            for (j = 0, len = ref2.length; j < len; j++) {
              channel = ref2[j];
              this.triggerUpdate(...(channel.split('.')), newBlock);
            }
          }
          return null;
        }
      }

      updateObserver(block, oldBlock) {
        var ch, j, l, len, len1, obs, oldObs, ref, ref1, ref2, results1;
        obs = this.decodeObservers(block);
        block.observing = obs;
        oldObs = (ref = oldBlock != null ? (ref1 = oldBlock.codeAttributes) != null ? (ref2 = ref1.observe) != null ? ref2.split(' ') : void 0 : void 0 : void 0) != null ? ref : [];
        for (j = 0, len = oldObs.length; j < len; j++) {
          ch = oldObs[j];
          if (!(indexOf.call(obs, ch) >= 0)) {
            this.observers.remove(...(ch.split('.')), getId(oldBlock));
          }
        }
        results1 = [];
        for (l = 0, len1 = obs.length; l < len1; l++) {
          ch = obs[l];
          if (!(indexOf.call(oldObs, ch) >= 0)) {
            results1.push(this.observers.add(...(ch.split('.')), getId(block), true));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }

      getNamedBlockId(name) {
        var ref;
        return (ref = this.namedBlocks[name]) != null ? ref : this.importedData[name];
      }

      setBlockName(name, blockId, isDefault) {
        return (isDefault ? this.importedData : this.namedBlocks)[name] = blockId;
      }

      deleteBlockName(name) {
        delete this.namedBlocks[name];
        return this.deleteLocalBlock(name);
      }

      getBlockNamed(name) {
        var id;
        if (id = this.getNamedBlockId(name)) {
          return this.getLocalBlock(id);
        }
      }

      localDocumentId() {
        return document.location.href;
      }

      getLocalBlock(thing) {
        var blk, local, n;
        if (!(blk = this.getBlock(thing))) {
          return null;
        } else if (!blk.local || !(n = blk.codeName) || blk._id !== this.getNamedBlockId(n)) {
          return blk;
        } else if (local = copyBlock(this.localBlocks[n])) {
          local._id = blk._id;
          return local;
        } else {
          return blk;
        }
      }

      storeLocalBlock(block) {
        var changes, j, len, name, old, oldBlock, ref;
        if (block.local && (name = block.codeName) && block._id === this.getNamedBlockId(name)) {
          old = this.getBlockNamed(name);
          this.localBlocks[name] = block;
          block = copyBlock(block);
          transaction(this.localDocumentId()).put(block);
          changes = {
            first: this.getFirst(),
            oldBlocks: (old ? [old] : []),
            newBlocks: [block],
            sets: {},
            adds: {},
            updates: {},
            removes: {},
            old: []
          };
          changes.sets[block._id] = block;
          ref = changes.oldBlocks;
          for (j = 0, len = ref.length; j < len; j++) {
            oldBlock = ref[j];
            changes.old[oldBlock._id] = oldBlock;
          }
          return this.trigger('change', changes);
        }
      }

      deleteLocalBlock(name) {
        var changes, newBlock, old;
        if (old = this.localBlocks[name]) {
          delete this.localBlocks[name];
          transaction(this.localDocumentId()).delete(name);
          newBlock = this.getBlockNamed(name);
          changes = {
            first: this.getFirst(),
            oldBlocks: [old],
            newBlocks: (newBlock ? [newBlock] : []),
            sets: {},
            adds: {},
            removes: {},
            updates: {},
            old: []
          };
          changes.removes[old._id] = true;
          return this.trigger('change', changes);
        }
      }

      textForDataNamed(name, data, attrs) {
        var item, j, k, len, opts, v;
        opts = '';
        for (k in attrs) {
          v = attrs[k];
          if (_.isArray(v)) {
            for (j = 0, len = v.length; j < len; j++) {
              item = v[j];
              opts += ` :${k} ${item}`;
            }
          } else {
            opts += ` :${k} ${v}`;
          }
        }
        return `${(name ? '#+NAME: ' + name + '\n' : '')}#+BEGIN_SRC yaml${opts}\n${dump(data, _.defaults(attrs != null ? attrs : {}, {
          sortKeys: true,
          flowLevel: 2
        })).trim()}\n#+END_SRC\n`;
      }

      checkViewChange(oldBlock, newBlock, isDefault) {
        var ov, source, vt;
        if (oldBlock && (ov = blockViewType(oldBlock))) {
          removeView(ov);
        }
        if (vt = blockViewType(newBlock)) {
          source = blockSource(newBlock);
          if (!isDefault || this.addImported(isDefault, 'view', vt)) {
            return addView(vt, null, source.substring(0, source.length - 1), isDefault);
          }
        }
      }

      checkControlChange(oldBlock, newBlock, isDefault) {
        if ((isControl(oldBlock) || isControl(newBlock)) && ((oldBlock != null ? oldBlock.type : void 0) !== 'code' || blockSource(oldBlock) !== blockSource(newBlock) || isControl(oldBlock) !== isControl(newBlock))) {
          return this.queueEval(() => {
            return this.changeController(oldBlock, newBlock, isDefault);
          });
        }
      }

      changeController(oldBlock, newBlock, isDefault) {
        var controller, env, ov, vt;
        if (newBlock && this.running[newBlock._id]) {
          return;
        }
        if (oldBlock && (ov = blockViewType(oldBlock, 'control', isDefault))) {
          removeController(ov);
        }
        if (vt = blockViewType(newBlock, 'control')) {
          controller = {};
          if (!isDefault || this.addImported(isDefault, 'controller', vt)) {
            addController(vt, null, controller, isDefault);
            env = this.env(newBlock.language);
            controller.__proto__ = env;
            setLounge(env, () => {
              return this.getCode(newBlock).call(controller);
            });
            return controller.__proto__ = null;
          }
        }
      }

      oldExecuteBlock(block, envConf) {
        var completedFlag, cont, r;
        completedFlag = false;
        cont = null;
        r = this.executeText(block.language, blockSource(block), (function(result) {
          if (!completedFlag) {
            completedFlag = true;
            return result;
          } else {
            return Promise.resolve(result);
          }
        }), (function(env) {
          var ref, ref1, ref2;
          if (typeof envConf === "function") {
            envConf(env);
          }
          if ((ref = typeof newBlock !== "undefined" && newBlock !== null ? (ref1 = newBlock.codeAttributes) != null ? (ref2 = ref1.results) != null ? ref2.toLowerCase() : void 0 : void 0 : void 0) === 'def' || ref === 'silent') {
            return env.silent = true;
          }
        }));
        if (!completedFlag) {
          completedFlag = true;
          return new Promise(function(success) {
            return cont = success;
          });
        } else {
          return r;
        }
      }

      XoldExecuteBlock(block, envConf) {
        return this.executeText(block.language, blockSource(block), null, (function(env) {
          var ref, ref1, ref2;
          if (typeof envConf === "function") {
            envConf(env);
          }
          if ((ref = typeof newBlock !== "undefined" && newBlock !== null ? (ref1 = newBlock.codeAttributes) != null ? (ref2 = ref1.results) != null ? ref2.toLowerCase() : void 0 : void 0 : void 0) === 'def' || ref === 'silent') {
            return env.silent = true;
          }
        }));
      }

      //env.write = (str)-> console.log str)
      executeBlock(block, envConf) {
        var code, env, err;
        env = this.env(block.language, function(env) {
          var ref, ref1, ref2, write;
          if ((ref = typeof newBlock !== "undefined" && newBlock !== null ? (ref1 = newBlock.codeAttributes) != null ? (ref2 = ref1.results) != null ? ref2.toLowerCase() : void 0 : void 0 : void 0) === 'def' || ref === 'web' || ref === 'silent') {
            env.silent = true;
            if (isSilent(newBlock)) {
              write = function() {};
            } else {
              //env.write = (str)-> console.log str
              env.presentValue = function(v) {
                return v;
              };
            }
          }
          return typeof envConf === "function" ? envConf(env) : void 0;
        });
        if (env.executeBlock !== defaultEnv.executeBlock) {
          try {
            return env.executeBlock(block, function(r) {
              return writeResults(env, r);
            });
          } catch (error1) {
            err = error1;
            return env.errorAt(0, String(err));
          }
        } else if (code = this.getCode(block)) {
          if (code instanceof Promise) {
            return code.then(function(func) {
              return setLounge(env, function() {
                return func.call(env);
              });
            }).then(function(result) {
              return writeResults(env, result);
            });
          } else {
            return setLounge(env, function() {
              return writeResults(env, code());
            });
          }
        } else {
          return this.oldExecuteBlock(block, envConf);
        }
      }

      env(language, envConf) {
        var base, env;
        if (env = Object.create(typeof (base = languageEnvMaker(language)) === "function" ? base({
          __proto__: defaultEnv
        }) : void 0)) {
          env.data = this;
          if (typeof envConf === "function") {
            envConf(env);
          }
          return env;
        }
      }

      executeText(language, text, cont, envConf) {
        var ref;
        return (ref = this.env(language, envConf)) != null ? ref.executeText(text, Nil, cont != null ? cont : function(x) {
          return x;
        }) : void 0;
      }

      checkImports(block) {
        var filename, i, newPromise, opts, ref, ref1;
        if ((i = block != null ? (ref = block.properties) != null ? ref.import : void 0 : void 0) && !this.importRecords.importedFiles[filename = block.properties.import]) {
          console.log(`Import: ${(block != null ? (ref1 = block.properties) != null ? ref1.import : void 0 : void 0)}`);
          this.importRecords.importedFiles[filename] = true;
          opts = defaultEnv.opts;
          return this.importPromise = newPromise = this.importPromise.then((() => {
            return new Promise((resolve, reject) => {
              return this.getFile(filename, ((contents) => {
                return withDefaultOptsSet(opts, () => {
                  var id, j, len, oldEvals, oldPromise, ref2;
                  oldPromise = this.importPromise;
                  oldEvals = this.pendingEvals;
                  this.pendingEvals = [];
                  this.importPromise = Promise.resolve();
                  id = 0;
                  ref2 = this.parseBlocks(contents);
                  for (j = 0, len = ref2.length; j < len; j++) {
                    block = ref2[j];
                    block._id = `imported-${filename}-${id++}`;
                    block.imported = true;
                    this.checkChange(null, block, filename);
                  }
                  return this.scheduleEvals().then(() => {
                    this.pendingEvals = oldEvals;
                    if (!oldPromise.isResolved()) {
                      if (!this.importPromise.isResolved) {
                        this.importPromise = this.importPromise.then(function() {
                          return oldPromise;
                        });
                      } else {
                        this.importPromise = oldPromise;
                      }
                    }
                    return resolve();
                  });
                });
              }), (e) => {
                return reject(displayError(e));
              });
            });
          }));
        }
      }

      getFile(filename, cont, fail) {
        var p;
        p = ajaxGet(new URL(filename, this.loadName).toString());
        if (cont || fail) {
          return p.then(cont, fail);
        } else {
          return p;
        }
      }

      decodeObservers(block) {
        var bv, finalObs, j, len, ob, obs, ref, ref1, ref2, ref3, v;
        finalObs = [];
        obs = (ref = (ref1 = block.codeAttributes) != null ? (ref2 = ref1.observe) != null ? ref2.split(' ') : void 0 : void 0) != null ? ref : [];
        for (j = 0, len = obs.length; j < len; j++) {
          ob = obs[j];
          if (ob === 'vars' || ob === '') {
            bv = blockVars(this, (ref3 = block.codeAttributes) != null ? ref3.var : void 0);
            finalObs.push(...((function() {
              var l, len1, ref4, results1;
              ref4 = bv[3];
              results1 = [];
              for (l = 0, len1 = ref4.length; l < len1; l++) {
                v = ref4[l];
                results1.push(`block.${bv[4][v]}`);
              }
              return results1;
            })()));
          } else if (ob.indexOf('.') === -1) {
            finalObs.push(`block.${ob}`);
          } else {
            finalObs.push(ob);
          }
        }
        return finalObs;
      }

      runBlock(block, func) {
        var id, r;
        id = getId(block);
        r = this.running[id];
        this.running[id] = true;
        try {
          return func();
        } finally {
          this.running[id] = r;
        }
      }

      replaceResult(block, str) {
        block = this.getBlock((typeof block === 'string' ? block : block._id));
        return this.runBlock(block, () => {
          return replaceResult(this, this, block, str);
        });
      }

      clearError(block) {
        var error, results, start;
        block = this.getBlock((typeof block === 'string' ? block : block._id));
        ({error, results} = blockCodeItems(this, block));
        if (error) {
          start = this.offsetForBlock(block) + error.offset;
          return this.runBlock(block, () => {
            return this.replaceText({
              start,
              end: start + error.text.length,
              text: '',
              source: 'code'
            }, true);
          });
        }
      }

      getYaml(block) {
        return getYaml(this.getBlock(block));
      }

      getCode(block, env) {
        var code, tangle;
        block = this.getBlock(block);
        if (block.code) {
          return block.code;
        } else {
          tangle = this.getTangle(block);
          code = (typeof tangle === 'function' ? (console.error("GOT TANGLED CODE", block._id), tangle) : isText(block) ? function(cont) {
            if (cont) {
              return cont.call(this, [blockSource(block)]);
            } else {
              return [blockSource(block)];
            }
          } : block.language === 'yaml' ? function(cont) {
            var yaml;
            yaml = (!block.computedYaml && block.yaml) || parseYaml(blockSource(block));
            if (cont) {
              return cont.call(this, [yaml]);
            } else {
              return [yaml];
            }
          } : (env = env != null ? env : this.env(block.language)) ? env.compileBlock(block) : void 0);
          if (code instanceof Promise) {
            return code.then((code) => {
              return block.code = this.addPostProcessing(block, code);
            });
          } else if (code) {
            return block.code = this.addPostProcessing(block, code);
          }
        }
      }

      addPostProcessing(block, func) {
        var argNames, blockName, data, m, ref, ref1;
        if (m = (ref = block.codeAttributes) != null ? (ref1 = ref.post) != null ? ref1.match(postCallPat) : void 0 : void 0) {
          [blockName, argNames] = slice1.call(m, -2);
          argNames = argNames.trim().split('\s*,\s*');
          blockName = blockName.trim();
          data = this;
          return function(cont, ...args) {
            var postProcessor;
            if (postProcessor = data.getCode(data.getBlockNamed(blockName))) {
              return func.call(this, (function(result) {
                var arg, argBlock, argData, blockArgs;
                if (result.length === 1) {
                  result = result[0];
                }
                blockArgs = [];
                if (typeof Lounge !== "undefined" && Lounge !== null) {
                  Lounge.blockVars = blockArgs;
                }
                return postProcessor.call(this, cont, ...((function() {
                  var j, len, ref2, results1;
                  results1 = [];
                  for (j = 0, len = argNames.length; j < len; j++) {
                    arg = argNames[j];
                    if (Number(arg) == arg || (ref2 = arg[0], indexOf.call("'\"", ref2) >= 0)) {
                      blockArgs.push(null);
                      results1.push(JSON.parse(arg));
                    } else {
                      if (arg === '*this*') {
                        argBlock = block;
                        argData = result;
                      } else {
                        argBlock = data.getBlockNamed(arg);
                        argData = data.getYaml(argData);
                      }
                      blockArgs.push(argBlock);
                      results1.push(argData);
                    }
                  }
                  return results1;
                })()));
              }), ...args);
            }
          };
        } else {
          return func;
        }
      }

      blockBounds(name) {
        var block;
        if (!(block = typeof name === 'string' ? this.getBlockNamed(name) : name)) {
          throw new Error(`No block named ${name}`);
        }
        return this.baseBlockBounds(block);
      }

      baseBlockBounds(block) {
        var end, start;
        start = this.offsetForBlock(block);
        end = start + block.text.length;
        return {
          start,
          end,
          gStart: start,
          gEnd: end
        };
      }

      verifyDataObject(opType, obj) {
        var ref;
        if (!((ref = typeof obj) === 'object' || ref === 'string' || ref === 'number' || ref === 'boolean')) {
          throw new Error(`Attempt to ${opType} value that is not an object.`);
        }
      }

      appendDataToHeadline(parent, name, value, codeOpts) {
        return this.appendData('headline', parent, name, value, codeOpts);
      }

      appendDataAfter(parent, name, value, codeOpts) {
        return this.appendData('block', parent, name, value, codeOpts);
      }

      appendData(parentType, parent, name, value, codeOpts) {
        var b, block;
        [block] = this.parseBlocks(this.textForDataNamed(name, value, codeOpts));
        this.checkCollaborating(block);
        if (name && this.getData(name)) {
          throw new Error(`Attempt to add block with duplicate name: ${name}`);
        }
        if (b = this.blockBounds((parentType === 'block' ? parent : this.lastChild(this.getNamedBlockId(parent))))) {
          return this.replaceText({
            start: b.end,
            end: b.end,
            source: 'code',
            text: block.text
          });
        } else {
          throw new Error(`Attempt to append a block after nonexistant block: ${parent}`);
        }
      }

      getLocalData(name) {
        var block;
        if (block = this.getBlockNamed(name)) {
          if (!block.local) {
            throw new Error("Attempt to use getLocalData with a shared block");
          }
          return this.getYaml(block);
        }
      }

      getData(name, skipCheck) {
        var block;
        if (block = this.getBlockNamed(name)) {
          if (!skipCheck) {
            this.checkCollaborating(block);
          }
          return this.getYaml(block);
        }
      }

      setLocalData(name, value, codeOpts) {
        var block;
        if (!(block = this.getBlockNamed(name))) {
          throw new Error(`No block named ${name}`);
        }
        if (!block.local) {
          throw new Error("Attempt to use setLocalData with a shared block");
        }
        return this.baseSetData(block, value, codeOpts);
      }

      setData(name, value, codeOpts) {
        var block;
        if (!(block = this.getBlockNamed(name))) {
          throw new Error(`No block named ${name}`);
        }
        this.checkCollaborating(block);
        return this.baseSetData(block, value, codeOpts);
      }

      baseSetData(block, value, codeOpts) {
        var b, name, newBlock, ref;
        name = block.codeName;
        this.verifyDataObject(`set ${name} to `, value);
        codeOpts = _.merge({}, (ref = block.codeAttributes) != null ? ref : {}, codeOpts != null ? codeOpts : {});
        [newBlock] = this.parseBlocks(this.textForDataNamed(name, value, codeOpts));
        if (newBlock.local) {
          newBlock._id = block._id;
          return this.storeLocalBlock(newBlock);
        } else {
          b = this.baseBlockBounds(block);
          b.text = newBlock.text;
          b.source = 'code';
          return this.replaceText(b);
        }
      }

      removeData(name) {
        var block;
        if (!(block = this.getBlockNamed(name))) {
          throw new Error(`No block named ${name}`);
        }
        return this.baseRemoveData(block);
      }

      baseRemoveData(block) {
        var b;
        this.checkCollaborating();
        b = this.baseBlockBounds(block);
        b.text = '';
        b.source = 'code';
        return this.replaceText(b);
      }

      hasCollaborativeCode(name) {
        return this.collaborativeCode[name];
      }

      openRegistration() {
        return this.registerCollaborativeCode = this.registrationCode;
      }

      closeRegistration() {
        return this.registerCollaborativeCode = function() {
          throw new Error("Attempt to register collaborative code after registration is closed");
        };
      }

      registrationCode(name, func) {
        if (typeof name === 'function') {
          func = name;
          name = func.name;
        }
        this.collaborativeBase[name] = func;
        return this.collaborativeCode[name] = (...args) => {
          return this.doCollaboratively(name, args);
        };
      }

      _runCollaborativeCode(name, slaveId, args) {
        return new Promise((succeed, fail) => {
          var code, err;
          try {
            this.inCollaboration = true;
            if (code = this.collaborativeBase[name]) {
              return succeed(code({
                options: this,
                slaveId
              }, ...args));
            } else {
              throw new Error(`No collaborative code named '${name}'`);
            }
          } catch (error1) {
            err = error1;
            return fail(err);
          } finally {
            this.inCollaboration = false;
          }
        });
      }

      doCollaboratively(name, args) {
        return this._runCollaborativeCode(name, null, args);
      }

      checkCollaborating(optBlock) {
        if (optBlock != null ? optBlock.local : void 0) {
          throw new Error("Attempt to use local block in collaborative code");
        } else if (!this.inCollaboration) {
          throw new Error("Not running collboartively");
        }
      }

    };
    DataIndexer = class DataIndexer {
      constructor(indexes) {
        this.indexes = indexes;
        if (!this.indexes) {
          this.indexes = FingerTree.fromArray([], {
            identity: function() {
              return [];
            },
            measure: function(v) {
              return v.key;
            },
            sum: function(a, b) {
              if (compareSorted(a, b) < 1) {
                return b;
              } else {
                return a;
              }
            }
          });
        }
      }

      copy() {
        return new DataIndexer(this.indexes);
      }

      keysFor(block) {
        var index, k, key, ref, yaml;
        return block.keys = ((index = (ref = block.codeAttributes) != null ? ref.index : void 0) && (yaml = getYaml(block)) ? ((function() {
          var j, len, ref1, results1;
          ref1 = (function() {
            var l, len, ref1, results2;
            ref1 = index.split(',');
            results2 = [];
            for (l = 0, len = ref1.length; l < len; l++) {
              k = ref1[l];
              results2.push(k.trim().split(keySplitPat));
            }
            return results2;
          })();
          results1 = [];
          for (j = 0, len = ref1.length; j < len; j++) {
            key = ref1[j];
            if (key.length === 2) {
              results1.push([key[0].trim(), key[1].trim(), block._id]);
            }
          }
          return results1;
        })()).sort(compareSorted) : void 0);
      }

      addBlockKey(k) {
        var first, rest;
        [first, rest] = this.indexes.split(function(m) {
          return m >= k.key;
        });
        return this.indexes = first.concat(rest.addFirst(k));
      }

      deleteBlockKey(k) {
        var first, found, r, rest;
        [first, rest] = this.indexes.split(function(m) {
          return m === k.key;
        });
        r = rest;
        while (!r.isEmpty() && (found = r.peekFirst() && found.key === k.key && found.id === k.id)) {
          r = r.removeFirst();
        }
        if (r !== rest) {
          return this.indexes = first.concat(rest);
        }
      }

      find(index, key) {
        var first, k, rest, result;
        k = [index];
        result = [];
        if (key) {
          k.push(key);
        }
        [first, rest] = this.indexes.split(function(m) {
          return compareSorted(k, m) < 1;
        });
        while (!rest.isEmpty() && isPrefix(k, rest.peekFirst().key)) {
          result.push(rest.peekFirst().id);
          rest = rest.removeFirst();
        }
        return result;
      }

    };
    getYaml = function(block) {
      var firstResult, ref, results;
      return _.cloneDeep((ref = block.yaml) != null ? ref : (block.yaml = isYamlResult(block) ? (({results} = blockCodeItems(this, block)), results ? (firstResult = results.text.indexOf('\n') + 1, parseYaml(results.text.substring(firstResult).replace(/(^|\n): /gm, '$1'))) : void 0) : null));
    };
    parseOrgDoc = function(text) {
      if (text === '') {
        return [];
      } else {
        return orgDoc(parseOrgMode(text.replace(/\r\n/g, '\n')), true);
      }
    };
    fileTypes = {
      jpg: 'image/jpeg',
      jpeg: 'image/jpeg',
      png: 'image/png',
      gif: 'image/gif',
      bmp: 'image/bmp',
      xpm: 'image/xpm',
      svg: 'image/svg+xml'
    };
    makeImageBlob = function(name, contents) {
      var m;
      if (m = name.match(/\.(jpg|jpeg|png|gif|bmp|xpm|svg)$/)) {
        return makeBlobUrl(contents, `image/${fileTypes[m[0]]}`);
      }
    };
    makeBlobUrl = function(contents, type) {
      var blob, byteArrays, i, offset, slice;
      byteArrays = (function() {
        var j, ref, results1;
        results1 = [];
        for (offset = j = 0, ref = contents.length; j < ref; offset = j += 512) {
          slice = contents.slice(offset, offset + 512);
          results1.push(new Uint8Array((function() {
            var l, results2;
            results2 = [];
            for (i = l = 0; l < 512; i = ++l) {
              results2.push(slice.charCodeAt(i));
            }
            return results2;
          })()));
        }
        return results1;
      })();
      blob = new Blob(byteArrays, {
        type: type
      });
      return URL.createObjectURL(blob);
    };
    EditorParsedCodeBlock = class EditorParsedCodeBlock extends ParsedCodeBlock {
      constructor(data, block) {
        super(data.getBlock(block) || block);
        this.data = data;
      }

      clone() {
        return new EditorParsedCodeBlock(this.data, this.block);
      }

      save(withUpdates) {
        var replaceBlock, start;
        start = this.data.offsetForBlock(this.block._id);
        replaceBlock = () => {
          return this.data.replaceText({
            start,
            end: start + this.data.getBlock(this.block._id).text.length,
            text: this.block.text,
            source: 'code'
          });
        };
        if (withUpdates) {
          return replaceBlock();
        } else {
          return this.data.runBlock(this.block, replaceBlock);
        }
      }

    };
    sanitize = function(str) {
      str = str.replace(/\uFEFF/g, '');
      str = str.replace(/\uA789/g, ':');
      return str = str.replace(/\u2044/g, '\/');
    };
    displayError = function(e) {
      console.log(`Error: ${e}`);
      return e;
    };
    compareSorted = function(a, b) {
      var i, j, ref;
      for (i = j = 0, ref = Math.min(a.length, b.length); (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
        if (a[i] < b[i]) {
          return -1;
        }
        if (a[i] > b[i]) {
          return 1;
        }
      }
      return a.length - b.length;
    };
    isPrefix = function(a, b) {
      var av, i, j, len;
      if (a.length > b.length) {
        return false;
      }
      for (i = j = 0, len = a.length; j < len; i = ++j) {
        av = a[i];
        if (av !== b[i]) {
          return false;
        }
      }
      return true;
    };
    basicDataFilter = {
      //startChange: (data)->
      //endChange: (data)->
      clear: function(data) {},
      replaceBlock: function(data, oldBlock, newBlock) {},
      replaceText: function(data, {start, end, text, source}) {}
    };
    blockElementId = function(block) {
      var ref;
      return block && ((ref = block.codeName) != null ? ref : block._id);
    };
    blockIsHidden = function(block) {
      var ref, ref1;
      return String((ref = block != null ? (ref1 = block.properties) != null ? ref1.hidden : void 0 : void 0) != null ? ref : '').toLowerCase() === 'true';
    };
    // `controllerEval` looks like a useless wrapper for eval, but you can use `apply()`
    // and `call` to set "this" for the code, which you can't do with the primitive `eval()`
    controllerEval = function(txt) {
      return eval(txt);
    };
    isCss = function(block) {
      return (block != null ? block.language : void 0) === 'css';
    };
    isText = function(block) {
      var ref;
      return (ref = block != null ? block.language.trim() : void 0) === 'text' || ref === 'string';
    };
    isControl = function(block) {
      var ref;
      return (block != null ? block.type : void 0) === 'code' && ((ref = block.codeAttributes) != null ? ref.control : void 0);
    };
    blockViewType = function(block, attr = 'defview') {
      var ref, ref1;
      return (ref = (block != null ? block.type : void 0) === 'code' && ((ref1 = block.codeAttributes) != null ? ref1[attr] : void 0)) != null ? ref : null;
    };
    addChange = function(block, changes) {
      if (!changes.sets[block._id]) {
        changes.oldBlocks.push(block);
        changes.newBlocks.push(changes.sets[block._id] = copyBlock(block));
      }
      return changes.sets[block._id];
    };
    greduce = function(thing, changes, func, arg, next) {
      if (typeof changes === 'function') {
        next = arg;
        arg = func;
        func = changes;
      }
      if (thing && typeof arg === 'undefined') {
        arg = thing;
        thing = next(thing);
      }
      while (thing) {
        arg = func(arg, thing);
        thing = next(thing);
      }
      return arg;
    };
    getId = function(thing) {
      if (typeof thing === 'string') {
        return thing;
      } else {
        return thing._id;
      }
    };
    // NMap is a very simple trie.
    NMap = class NMap {
      constructor(items1) {
        this.items = items1;
        if (!this.items) {
          this.items = {};
        }
      }

      clone() {
        return new NMap(_.clone(this.items));
      }

      clear() {
        return this.items = {};
      }

      add(...args) {
        var i, j, pos, ref, ref1, value;
        ref = args, [...args] = ref, [value] = splice.call(args, -1);
        i = this.items;
        for (pos = j = 0, ref1 = args.length - 1; (0 <= ref1 ? j < ref1 : j > ref1); pos = 0 <= ref1 ? ++j : --j) {
          if (!i[args[pos]]) {
            i[args[pos]] = {};
          }
          i = i[args[pos]];
        }
        return i[args[args.length - 1]] = value;
      }

      get(...keys) {
        var i, j, pos, ref;
        i = this.items;
        for (pos = j = 0, ref = keys.length; (0 <= ref ? j < ref : j > ref); pos = 0 <= ref ? ++j : --j) {
          if (!i[keys[pos]]) {
            return null;
          }
          i = i[keys[pos]];
        }
        return i;
      }

      getAll(...keys) {
        return new NMap(this.get(...keys));
      }

      remove(...keys) {
        var collection, i, items, j, l, path, pos, ref;
        path = [];
        items = this.items;
        for (pos = j = 0, ref = keys.length; (0 <= ref ? j < ref : j > ref); pos = 0 <= ref ? ++j : --j) {
          if (!items[keys[pos]]) {
            break;
          }
          path.push(items);
          items = items[keys[pos]];
        }
        for (i = l = path.length - 1; l >= 0; i = l += -1) {
          collection = path[i];
          delete collection[keys[i]];
          if (!_.isEmpty(collection)) {
            break;
          }
        }
        return items[keys[keys.length - 1]];
      }

      toString() {
        return `NMAP ${JSON.stringify(this.items)}`;
      }

    };
    window.NMap = NMap;
    withDefaultOptsSet = function(opts, func) {
      var oldOpts;
      oldOpts = defaultEnv.opts;
      defaultEnv.opts = opts;
      try {
        return func();
      } finally {
        defaultEnv.opts = oldOpts;
      }
    };
    // `OrgEditing` -- editing options for the org editor.
    OrgEditing = class OrgEditing extends DataStoreEditingOptions {
      constructor(data) {
        super(data);
        this.setPrefix('leisureBlock-');
        this.hiding = true;
        this.setMode(Leisure.plainMode);
        this.toggledSlides = {};
      }

      runBlock(block, replace) {
        return this.data.runBlock(block, replace);
      }

      parsedCodeBlock(block) {
        return new EditorParsedCodeBlock(this, this.data.getBlock(block));
      }

      dataChanged(changes) {
        return preserveSelection(() => {
          var slide;
          super.dataChanged(changes);
          initializePendingViews();
          if (this.currentSlide) {
            slide = this.nodeForId(this.currentSlide).closest('[data-view=leisure-top-headline], [data-view=leisure-top-chunk]');
            if (!slide.hasClass('currentSlide')) {
              slide.addClass('currentSlide');
              if (!this.find('firstSlide').length) {
                slide.addClass('firstSlide');
              }
              if (!this.find('lastSlide').length) {
                return slide.addClass('lastSlide');
              }
            }
          }
        });
      }

      dataLoaded() {
        super.dataLoaded();
        return this.rerenderAll();
      }

      load(name, text) {
        return this.withDefaultOpts(() => {
          return super.load(name, text);
        });
      }

      withDefaultOpts(func) {
        return withDefaultOptsSet(this, func);
      }

      renderBlocks() {
        return this.mode.renderBlocks(this, super.renderBlocks());
      }

      setTheme(theme) {
        if (this.theme) {
          this.editor.node.removeClass(this.theme);
        }
        return this.editor.node.addClass(this.theme = theme);
      }

      toggleSlides() {
        return this.mode.setSlideMode(this, !this.showingSlides());
      }

      showingSlides() {
        return this.mode.showingSlides(this);
      }

      hideToolbar() {
        return this.editor.node.prev().addClass('collapse');
      }

      showToolbar() {
        return this.editor.node.prev().removeClass('collapse');
      }

      getLocalBlock(thing) {
        return this.data.getLocalBlock(thing);
      }

      isValidDocOffset(offset) {
        var end, next, start;
        if (this.currentSlide) {
          start = this.data.offsetForBlock(this.currentSlide);
          if (next = this.data.nextSibling(this.currentSlide)) {
            end = this.data.offsetForBlock(next) + next.text.length;
          } else {
            end = start + this.getBlock(this.currentSlide).text.length;
          }
          return (start <= offset && offset < end);
        } else {
          return super.isValidDocOffset(offset);
        }
      }

      rerenderAll() {
        super.rerenderAll();
        return initializePendingViews();
      }

      changed(changes) {
        var block, i, id, j, l, len, len1, len2, nameNodes, nb, newBlock, newBlocks, node, o, observers, oldBlock, oldBlocks, ref, viewNodes;
        ({newBlocks, oldBlocks} = changes);
        if ((newBlocks.length === (ref = oldBlocks.length) && ref === 1)) {
          for (i = j = 0, len = newBlocks.length; j < len; i = ++j) {
            newBlock = newBlocks[i];
            oldBlock = oldBlocks[i];
            //if newBlock.type == 'headline' || oldBlock.type == 'headline' ||
            //newBlock._id != oldBlock._id
            if (trickyChange(oldBlock, newBlock)) {
              return super.changed(changes);
            }
          }
          nb = newBlocks.slice();
          viewNodes = $();
          nameNodes = $();
          for (l = 0, len1 = newBlocks.length; l < len1; l++) {
            block = newBlocks[l];
            viewNodes = viewNodes.add(this.find(`[data-view-block='${block._id}']`));
            viewNodes = this.findViewsForDefiner(block, viewNodes);
            viewNodes = this.findViewsForDefiner(changes.old[block._id], viewNodes);
            observers = this.find(`[data-observe~='${block._id}']`);
            if (block.codeName) {
              nameNodes = viewNodes.add(this.find(`[data-view-block-name~='${block.codeName}']`));
              observers = observers.add(this.find(`[data-observe~='${block.codeName}']`));
            }
            for (o = 0, len2 = observers.length; o < len2; o++) {
              node = observers[o];
              if (id = this.idForNode(node)) {
                nb.push(this.getBlock(id, changes));
              }
            }
          }
          nb = _.values(_.keyBy(nb, '_id'));
          this.mode.renderChanged(this, nb, this.idPrefix, true);
          return this.withNewContext(() => {
            var blk, blkName, data, len3, len4, name, q, ref1, ref2, ref3, results1, s, view;
            ref1 = viewNodes.filter((n) => {
              return !nb[this.idForNode(n)];
            });
            for (q = 0, len3 = ref1.length; q < len3; q++) {
              node = ref1[q];
              node = $(node);
              [view, name] = ((ref2 = $(node).attr('data-requested-view')) != null ? ref2 : '').split('/');
              if ((block = this.blockForNode(node)) && (data = this.data.getYaml(block))) {
                renderView(view, name, data, node, block);
              } else if (block = this.findBlockForResultView(node)) {
                renderView(view, name, false, node, block);
              }
            }
            ref3 = nameNodes.filter((n) => {
              return !nb[this.idForNode(n)];
            });
            results1 = [];
            for (s = 0, len4 = ref3.length; s < len4; s++) {
              node = ref3[s];
              node = $(node);
              results1.push((function() {
                var len5, ref4, ref5, results2, u;
                ref4 = node.attr('data-view-block-name').split(/\s+/);
                results2 = [];
                for (u = 0, len5 = ref4.length; u < len5; u++) {
                  blkName = ref4[u];
                  if (data = this.data.getYaml(blk = this.data.getBlockNamed(blkName))) {
                    [view, name] = ((ref5 = node.attr('data-requested-view')) != null ? ref5 : '').split('/');
                    results2.push(renderView(view, name, data, node, blk, blkName));
                  } else {
                    results2.push(void 0);
                  }
                }
                return results2;
              }).call(this));
            }
            return results1;
          });
        } else {
          return super.changed(changes);
        }
      }

      blockForNode(node) {
        var ref;
        return (ref = this.getBlock(node.attr('data-view-block'))) != null ? ref : this.data.getBlockNamed(node.attr('data-view-block-name'));
      }

      findBlockForResultView(node) {
        var results;
        if ((results = node.closest('.code-results')).length) {
          return this.getBlock(this.idForNode(results[0]));
        }
      }

      find(sel) {
        return $(this.editor.node).find(sel);
      }

      findViewsForDefiner(block, nodes) {
        var attrs, ref, viewType;
        if (block) {
          attrs = block.type === 'code' && block.codeAttributes;
          if (attrs && (viewType = (ref = attrs.control) != null ? ref : attrs.defview)) {
            nodes = nodes.add(this.find(`[data-view='${viewType}']`));
            nodes = nodes.add(this.find(`[data-requested-view='${viewType}']`));
          }
        }
        return nodes;
      }

      withNewContext(func) {
        return mergeContext(Leisure.rootContext, () => {
          UI.context.opts = this;
          UI.context.prefix = this.idPrefix;
          return func();
        });
      }

      initToolbar() {
        this.withNewContext(() => {
          return $(this.editor.node).before(renderView('leisure-toolbar', null, null));
        });
        return initializePendingViews();
      }

      slideFor(thing) {
        var block, parent;
        block = this.data.getBlock(thing);
        while (block && !(block.type === 'headline' && block.level === 1)) {
          parent = this.data.parent(block);
          if (!parent) {
            break;
          }
          block = parent;
        }
        return block;
      }

      slidesFor(blocks) {
        var block, j, len, slide, slides;
        slides = {};
        for (j = 0, len = blocks.length; j < len; j++) {
          block = blocks[j];
          if (slide = this.slideFor(block)) {
            slides[slide._id] = block;
          }
        }
        return slides;
      }

      toggleSlide(id) {
        var block;
        block = this.data.getBlock(id);
        if (((block != null ? block.type : void 0) === 'headline' && block.level === 1) || (block && !block.prev)) {
          if (this.toggledSlides[id]) {
            return delete this.toggledSlides[id];
          } else {
            return this.toggledSlides[id] = true;
          }
        }
      }

      isToggled(thing) {
        var slide;
        return (slide = this.slideFor(thing)) && this.toggledSlides[slide._id];
      }

      removeToggles() {
        return this.toggledSlides = {};
      }

      toggleHidden() {
        this.hiding = !this.hiding;
        return this.rerenderAll();
      }

      hideHiddenSlides() {
        if (!this.hiding) {
          return this.toggleHidden();
        }
      }

      showAllSlides() {
        if (this.hiding) {
          return this.toggleHidden();
        }
      }

      isHidden(thing) {
        return blockIsHidden(this.slideFor(thing));
      }

      canHideSlides() {
        return this.hiding && this.mode === Leisure.fancyMode;
      }

      shouldHide(thing) {
        var slide;
        return this.canHideSlides() && (slide = this.slideFor(thing)) && this.isHidden(slide) && !this.isToggled(slide);
      }

      imageError(img, e) {}

      setEditor(ed) {
        var opts;
        super.setEditor(ed);
        $(ed.node).addClass('leisure-editor');
        addSelectionBubble(ed.node);
        this.setMode(this.mode);
        this.initToolbar();
        this.bindings = {
          __proto__: this.bindings,
          'C-C C-C': ((editor, e, r) => {
            // execute asynchronously because alerts mess with the events
            setTimeout((() => {
              return this.execute();
            }), 1);
            return false;
          })
        };
        this.bindings.PAGEUP = (editor, e, r) => {
          if (this.mode.showPrevSlide(this)) {
            e.preventDefault();
          }
          return false;
        };
        this.bindings.PAGEDOWN = (editor, e, r) => {
          if (this.mode.showNextSlide(this)) {
            e.preventDefault();
          }
          return false;
        };
        opts = this;
        return changeAdvice(ed, true, {
          setHtml: {
            options: function(parent) {
              return function(el, html, outer) {
                var sel;
                sel = ed.node.find("[name='selectionBubble']");
                sel.remove();
                parent(el, html, outer);
                return ed.node.append(sel);
              };
            }
          },
          keyPress: {
            options: function(parent) {
              return function(e) {
                return opts.mode.keyPress(opts, parent, e);
              };
            }
          },
          enter: {
            options: function(parent) {
              return function(e) {
                return opts.mode.enter(opts, parent, e);
              };
            }
          },
          handleDelete: {
            options: function(parent) {
              return function(e, sel, forward) {
                return opts.mode.handleDelete(opts, parent, e, sel, forward);
              };
            }
          },
          setCurrentScript: {
            options: function(parent) {
              return function(script) {
                return Leisure.UI.currentScript = script;
              };
            }
          },
          activateScripts: {
            options: function(parent) {
              return function(jq, context, data, block) {
                if (UI.context) {
                  return UI.activateScripts(jq, UI.context, data, block);
                } else {
                  return parent(jq, data, block);
                }
              };
            }
          }
        });
      }

      setMode(mode) {
        this.mode = mode;
        if (this.mode && this.editor) {
          this.editor.node.attr('data-edit-mode', this.mode.name);
        }
        return this;
      }

      setPrefix(prefix) {
        this.idPrefix = prefix;
        return this.idPattern = new RegExp(`^${prefix}(.*)$`);
      }

      nodeForId(id) {
        return $(`#${this.idPrefix}${id}`);
      }

      idForNode(node) {
        var ref, ref1;
        return (ref = $(node).closest('[data-block]')[0]) != null ? (ref1 = ref.id.match(this.idPattern)) != null ? ref1[1] : void 0 : void 0;
      }

      parseBlocks(text) {
        return this.data.parseBlocks(text);
      }

      renderBlock(block) {
        return this.mode.render(this, block, this.idPrefix);
      }

      replaceTextEffects(start, end, text, skipMode) {
        var changes, newBlocks, oldBlocks, prev, sets;
        ({prev, oldBlocks, newBlocks} = this.data.changesForReplacement(start, end, text));
        if (!oldBlocks) {
          oldBlocks = [];
          newBlocks = [this.data.getBlock(this.data.blockForOffset(start))];
          sets = {};
          sets[newBlocks._id] = newBlocks[0];
          changes = {
            first: this.data.getFirst(),
            oldBlocks,
            newBlocks,
            sets: sets,
            removes: {}
          };
        } else {
          changes = this.changesFor(prev, oldBlocks, newBlocks);
        }
        if (!skipMode) {
          this.mode.handleChanges(this, changes);
        }
        return changes;
      }

      replaceText(repl, skipEffects) {
        var j, len, repls, results1;
        if (!skipEffects && ({repls} = this.replaceTextEffects(repl.start, repl.end, repl.text))) {
          this.withDefaultOpts(() => {
            return this.data.allowObservation(() => {
              return super.replaceText(repl);
            });
          });
          if (repls) {
            results1 = [];
            for (j = 0, len = repls.length; j < len; j++) {
              repl = repls[j];
              results1.push(this.replaceText(repl, true));
            }
            return results1;
          }
        } else {
          return this.data.allowObservation(() => {
            return super.replaceText(repl);
          });
        }
      }

      // `changesFor(first, oldBlocks, newBlocks)` -- compute some effects immediately
      changesFor(first, oldBlocks, newBlocks) {
        var change, changedProperties, changes, child, computedProperties, id, j, l, len, len1, oldBlock, parent, props, ref, ref1, ref2;
        changes = this.data.changesFor(first, oldBlocks, newBlocks);
        changes.repls = [];
        computedProperties = {};
        changedProperties = [];
        ref = changes.sets;
        for (id in ref) {
          change = ref[id];
          oldBlock = this.getBlock(change._id);
          if (this.checkPropertyChange(changes, change, oldBlock)) {
            changedProperties.push(change._id);
          }
          this.checkCodeChange(changes, change, oldBlock, oldBlocks, newBlocks);
        }
//@data.checkChannelChange oldBlock, change, true
        for (j = 0, len = changedProperties.length; j < len; j++) {
          change = changedProperties[j];
          if (parent = (ref1 = this.data.parent(change, changes)) != null ? ref1._id : void 0) {
            if (!computedProperties[parent]) {
              computedProperties[parent] = true;
              props = {};
              ref2 = this.data.children(parent, changes);
              for (l = 0, len1 = ref2.length; l < len1; l++) {
                child = ref2[l];
                props = _.defaults(props, child.properties);
              }
              addChange(this.data.getBlock(parent, changes), changes).properties = props;
            }
          }
        }
        return changes;
      }

      // `change(changes)` -- about to change the data, allow mode to render some things
      change(changes) {
        if (changes) {
          this.mode.handleChanges(this, changes);
        }
        return super.change(changes);
      }

      replaceBlock(block, textOrBlock, source) {
        var offset, text;
        block = this.getBlock(block);
        offset = this.data.offsetForBlock(block);
        text = typeof textOrBlock === 'object' ? textOrBlock.text : textOrBlock;
        return this.replaceText({
          start: offset,
          end: offset + block.text.length,
          text,
          source
        });
      }

      update(block) {
        var oldBlock;
        oldBlock = this.getBlock(block._id);
        if (!_.isEqual(block, oldBlock)) {
          return this.replaceBlock(oldBlock, block.text, 'code');
        }
      }

      changesHidden(changes) {
        var change, j, len, ref;
        if (this.canHideSlides()) {
          ref = changes.oldBlocks;
          for (j = 0, len = ref.length; j < len; j++) {
            change = ref[j];
            if (this.shouldHide(change)) {
              return true;
            }
          }
        }
        return false;
      }

      checkPropertyChange(changes, change, oldBlock) {
        var ref;
        return change.type === 'chunk' && !_.isEqual(change.properties, (ref = this.getBlock(change._id)) != null ? ref.properties : void 0);
      }

      checkCodeChange(changes, change, oldBlock, oldBlocks, newBlocks) {
        var block, envM, err, hasChange, i, j, len, newBlock, newResults, newSource, oldSource, opts, ref, ref1, repl, replaceBlock, result, start, state, values;
        try {
          if (!this.data.running[change._id] && change.type === 'code' && isDynamic(change) && (envM = blockEnvMaker(change))) {
            ({
              source: newSource,
              results: newResults
            } = blockCodeItems(this, change));
            hasChange = !oldBlock || oldBlock.type !== 'code' || !(isDynamic(oldBlock) && !isObserver(oldBlock)) || (oldBlock ? (oldSource = blockSource(oldBlock), newSource.content !== oldSource) : void 0);
            if (hasChange) {
              result = '';
              newBlock = setError(change);
              replaceBlock = function(bl) {
                bl.code = newBlock.code;
                return newBlock = bl;
              };
              state = 'idle';
              opts = this;
              try {
                values = this.data.executeBlock(newBlock, (env) => {
                  env.opts = this;
                  env.data = this.data;
                  env.prompt = function(str, defaultValue, cont) {
                    return cont(prompt(str, defaultValue));
                  };
                  env.errorAt = function(offset, msg) {
                    var cur;
                    cur = newBlock;
                    replaceBlock(setError(cur, offset, msg));
                    if (newBlock !== change && state === 'pending') {
                      return opts.replaceBlock(cur, newBlock.text, 'code');
                    }
                  };
                  return env.write = (str) => {
                    result += presentHtml(str);
                    if (result[result.length - 1] !== '\n') {
                      result += '\n';
                    }
                    if (state === 'pending') {
                      return this.replaceResult(change._id, result);
                    }
                  };
                });
                if (values instanceof Promise) {
                  state = 'pending';
                  return values.then(function(results) {
                    replaceBlock(setResult(newBlock, result));
                    opts.replaceBlock(newBlock._id, newBlock.text, 'code');
                    return state = 'finished';
                  });
                } else {
                  state = 'finished';
                  replaceBlock(setResult(newBlock, result));
                  if (newBlock.text !== change.text) {
                    changes.sets[newBlock._id] = newBlock;
                    ref = changes.newBlocks;
                    for (i = j = 0, len = ref.length; j < len; i = ++j) {
                      block = ref[i];
                      if (block._id === newBlock._id) {
                        changes.newBlocks[i] = newBlock;
                      }
                    }
                    start = this.offsetForNewBlock(newBlock, oldBlocks, newBlocks);
                    changes.repls.push(repl = replacementFor(start, change.text, newBlock.text));
                    return repl.source = 'code';
                  }
                }
              } catch (error1) {
                err = error1;
                return env.errorAt(0, (ref1 = err != null ? err.message : void 0) != null ? ref1 : err);
              }
            }
          }
        } catch (error1) {
          err = error1;
          return null;
        }
      }

      offsetForNewBlock(newBlock, oldBlocks, newBlocks) {
        var block, j, len, start;
        start = oldBlocks.length === 0 ? 0 : this.data.offsetForBlock(oldBlocks[0]);
        for (j = 0, len = newBlocks.length; j < len; j++) {
          block = newBlocks[j];
          if (block._id === newBlock._id) {
            return start;
          }
          start += block.text.length;
        }
        return -1;
      }

      execute() {
        var block, envM;
        block = this.editor.blockForCaret();
        if (block.type === 'code' && (envM = blockEnvMaker(block))) {
          this.data.queueEval(() => {
            this.executeBlock(block, envM, true);
            return this.data.triggerUpdate('system', 'code', block);
          });
          return this.data.scheduleEvals();
        }
      }

      env(language) {
        var env;
        env = this.data.env(language);
        env.opts = this;
        env.prompt = function(str, defaultValue, cont) {
          return cont(prompt(str, defaultValue));
        };
        return env;
      }

      executeBlock(block, envM, isUserEvent) {
        var env, newBlock, opts, result, silent, source, sync;
        if (envM = blockEnvMaker(block)) {
          ({source} = blockCodeItems(this, block));
          result = '';
          sync = true;
          env = envM({
            __proto__: defaultEnv,
            presentHtml: presentHtml,
            opts: opts = this,
            data: this.data
          });
          newBlock = setError(block);
          env.errorAt = function(offset, msg) {
            newBlock = setError(block, offset, msg);
            if (newBlock !== block && !sync) {
              return opts.update(newBlock);
            }
          };
          if (silent = isSilent(block)) {
            env.write = function() {};
          } else {
            env.write = function(str) {
              result += env.presentHtml(str);
              if (!sync) {
                return opts.update(newBlock = setResult(block, result));
              }
            };
            env.writeTraceMessage = function(count, msg) {
              return result += env.presentHtml(new Html(`<a href='javascript:Leisure.traceMessage(${count})'>trace</a>${msg}`));
            };
          }
          env.prompt = function(str, defaultValue, cont) {
            return cont(prompt(str, defaultValue));
          };
          setLounge(env, function() {
            return env.executeBlock(block, function(r) {
              writeResults(env, r);
              if (isUserEvent) {
                return env.userEvent();
              }
            });
          });
          sync = false;
          if (!silent) {
            newBlock = setResult(newBlock, result);
          }
          if (newBlock !== block) {
            return opts.update(newBlock);
          }
        }
      }

      renderImage(src, title) {
        var m, ref;
        if (this.loadName && ((m = src.match(/^file:(\/\/)?(.*)$/)) || !(src.match(/^.*:/)))) {
          src = new URL((ref = m != null ? m[2] : void 0) != null ? ref : src, this.loadName).toString();
        }
        return `<img src='${src}'${title}>`;
      }

      followLink(e) {
        if (e.target.href.match(/^elisp/)) {
          console.log(`Attempt to follow elisp link at ${this.editor.docOffset(e.target, 0)}`);
          alert(`Elisp links not supported:\n${e.target.href}`);
        } else {
          open(e.target.href);
        }
        return false;
      }

      replaceResult(block, str) {
        return replaceResult(this, this.data, block, str);
      }

    };
    trickyChange = function(oldBlock, newBlock) {
      var t;
      return oldBlock._id !== newBlock._id || (indexOf.call((t = [oldBlock.type, newBlock.type]), 'headline') >= 0 && t[0] !== t[1]) || (t[0] === 'headline' && oldBlock.level !== newBlock.level);
    };
    isSilent = function(block) {
      var ref, ref1;
      return block != null ? (ref = block.codeAttributes) != null ? (ref1 = ref.results) != null ? ref1.toLowerCase().match(/\bsilent\b/) : void 0 : void 0 : void 0;
    };
    replaceResult = function(source, data, block, str) {
      var blockId, current, newBlock, observer, observing, repl, start;
      if (typeof block !== 'string') {
        blockId = block._id;
      }
      if (current = data.getBlock(block)) {
        newBlock = setResult(current, str);
        if (current.text !== newBlock.text) {
          start = data.offsetForBlock(current);
          repl = replacementFor(start, current.text, newBlock.text);
          ({observing, observer} = current);
          repl.source = 'code';
          source.replaceText(repl, true);
          if (observer) {
            data.getBlock(block._id).observer = observer;
            return data.getBlock(block._id).observing = observing;
          }
        }
      }
    };
    setResult = function(block, result) {
      var newBlock, ref, ref1, results, text, tmp;
      result = sanitize(result);
      if (block != null ? (ref = block.codeAttributes) != null ? (ref1 = ref.results) != null ? ref1.toLowerCase().match(/\b(def|web|silent)\b/) : void 0 : void 0 : void 0) {
        result = '';
      }
      ({results} = blockCodeItems(this, block));
      if (!results && ((result == null) || result === '')) {
        return block;
      } else {
        newBlock = copyBlock(block);
        text = (result == null) || result === '' ? block.text.substring(0, results.offset) + block.text.substring(results.offset + results.text.length) : results ? block.text.substring(0, results.offset + results.contentPos) + result + block.text.substring(results.offset + results.text.length) : block.text + `#+RESULTS:\n${result}`;
        [tmp] = parseOrgDoc(text);
        Object.assign(newBlock, tmp);
        return newBlock;
      }
    };
    setError = function(block, offset, msg) {
      var err, error, newBlock, results, text, tmp;
      ({error, results} = blockCodeItems(this, block));
      if ((offset == null) && !error) {
        return block;
      } else {
        newBlock = copyBlock(block);
        //msg = if msg then escapeString(msg.trim()) + "\n"
        msg = msg ? escapeString(msg.trim()) : void 0;
        err = `#+ERROR: ${offset}, ${msg}\n`;
        text = error ? offset == null ? block.text.substring(0, error.offset) + block.text.substring(error.offset + error.text.length) : block.text.substring(0, error.offset) + err + block.text.substring(error.offset + error.text.length) : results ? block.text.substring(0, results.offset) + err + block.text.substring(results.offset) : block.text + err;
        [tmp] = parseOrgDoc(text);
        Object.assign(newBlock, tmp);
        return newBlock;
      }
    };
    isDynamic = function(block) {
      return hasCodeAttribute(block, 'results', 'dynamic');
    };
    isObserver = function(block) {
      var ref;
      return block != null ? (ref = block.codeAttributes) != null ? ref.observe : void 0 : void 0;
    };
    blockEnvMaker = function(block) {
      return languageEnvMaker(block.language);
    };
    createBlockEnv = function(block, envMaker) {};
    blockCodeItems = function(data, block) {
      var org;
      if ((block != null ? block.type : void 0) === 'code') {
        org = blockOrg(data, block);
        if (org instanceof Fragment || org instanceof Headline) {
          org = org.children[0];
        }
        return getCodeItems(org);
      } else {
        return {};
      }
    };
    createLocalData = function() {
      return new OrgData();
    };
    installSelectionMenu = function() {
      $(document.body).append("<div id='topCaretBox' contenteditable='false'></div>").append("<div id='bottomCaretBox' contenteditable='false'></div>");
      return monitorSelectionChange();
    };
    selectionMenu = "<div>\n<ul>\n  <li name='insert'><a href='javascript:void(0)'><span>Insert</span></a>\n    <ul>\n      <li><a href='javascript:void(0)'><span>Leisure</span></a></li>\n      <li><a href='javascript:void(0)'><span>YAML</span></a></li>\n      <li><a href='javascript:void(0)'><span>HTML</span></a></li>\n      <li><a href='javascript:void(0)'><span>CoffeeScript</span></a></li>\n      <li><a href='javascript:void(0)'><span>JavaScript</span></a></li>\n    </ul>\n  </li>\n</ul>\n</div>";
    addSelectionBubble = function(node) {
      var bubble;
      bubble = $("<div name='selectionBubble' contenteditable='false'></div>");
      bubble.appendTo(node).html(selectionMenu).on('mouseclick', function() {
        return configureMenu(bubble.find('ul'));
      });
      return bubble.find('ul').menu({
        select: function(event, ui) {
          console.log("MENU SELECT");
          return false;
        }
      });
    };
    configureMenu = function(menu) {
      return console.log("configure menu");
    };
    //if getSelection().type == 'Caret'
    //  [el] = blockElementsForSelection()
    //  bl = getBlock el.id
    //  if bl?.type == 'chunk'
    //    return menu.find("[name='insert']").removeClass 'ui-state-disabled'
    //menu.find("[name='insert']").addClass 'ui-state-disabled'
    actualSelectionUpdate = function() {
      var bubble, c, editor, node, p;
      if (selectionActive) {
        if (editor = findEditor(getSelection().focusNode)) {
          c = editor.domCursorForCaret();
          if (!c.isEmpty() && (p = c.textPosition()) && isContentEditable(c.node)) {
            bubble = editor.node.find("[name='selectionBubble']")[0];
            node = editor.node[0];
            bubble.style.left = `${p.left + bubbleLeftOffset}px`;
            bubble.style.top = `${p.top + node.scrollTop - bubble.offsetHeight - node.offsetTop}px`;
            $(document.body).addClass('selection');
            editor.trigger('selection');
            return;
          }
        }
      }
      $(document.body).removeClass('selection');
      return editor != null ? editor.trigger('selection') : void 0;
    };
    throttledUpdateSelection = _.throttle((function() {
      actualSelectionUpdate();
      return actualSelectionUpdate();
    }), 30, {
      leading: true,
      trailing: true
    });
    updateSelection = function(e) {
      if ($(getSelection().anchorNode).closest('[data-noncontent]').length === 0) {
        return throttledUpdateSelection(e);
      }
    };
    monitorSelectionChange = function() {
      $(document).on('selectionchange', updateSelection);
      return $(window).on('blur focus', function(e) {
        selectionActive = e.type === 'focus';
        return updateSelection();
      });
    };
    toolbarFor = function(el) {
      return $(el).closest('[data-view]')[0];
    };
    editorForToolbar = function(el) {
      return findEditor(toolbarFor(el).nextSibling);
    };
    editorToolbar = function(editorNode) {
      return findEditor(editorNode).node.prev();
    };
    showHide = function(toolbar) {
      var editingOpts;
      editingOpts = editorForToolbar(toolbar).options;
      editingOpts.toggleHidden();
      return editingOpts.hiding;
    };
    breakpoint = function() {
      console.log();
      return console.log("breakpoint");
    };
    isContentEditable = function(node) {
      return (node instanceof Element ? node : node.parentElement).isContentEditable;
    };
    getDocumentParams = function() {
      var j, k, len, param, ref, v;
      if (!documentParams) {
        documentParams = {};
        ref = document.location.search.substring(1).split('&');
        for (j = 0, len = ref.length; j < len; j++) {
          param = ref[j];
          [k, v] = param.split('=');
          documentParams[k.toLowerCase()] = v;
        }
      }
      return documentParams;
    };
    followLink = function(e) {
      var ref;
      return ((ref = Leisure.findEditor(e.target)) != null ? ref.options.followLink(e) : void 0) || false;
    };
    replacementFor = function(start, oldText, newText) {
      var endOff, lim, startOff;
      lim = Math.min(oldText.length, newText.length);
      startOff = endOff = 0;
      while (startOff < lim && oldText[startOff] === newText[startOff]) {
        startOff++;
      }
      if (startOff < lim) {
        lim -= startOff;
        endOff = 0;
        while (endOff < lim && oldText[oldText.length - endOff - 1] === newText[newText.length - endOff - 1]) {
          endOff++;
        }
      }
      return {
        start: start + startOff,
        end: start + oldText.length - endOff,
        text: newText.substring(startOff, newText.length - endOff)
      };
    };
    // Exports
    Object.assign(Leisure, {
      blockCodeItems,
      findEditor,
      showHide,
      toolbarFor,
      editorToolbar,
      editorForToolbar,
      breakpoint,
      blockOrg,
      parseOrgMode,
      followLink,
      defaultEnv,
      preserveSelection,
      rootContext: {},
      isDynamic,
      ParsedCodeBlock,
      setLounge,
      parseYaml,
      blockSource,
      BasicEditingOptions,
      LeisureEditCore,
      DataStore,
      DataStoreEditingOptions,
      Editor,
      CodeContext,
      modifyingKey,
      getId,
      makeBlobUrl,
      makeImageBlob,
      addSelectionBubble,
      Advice,
      Immutable,
      FingerTree
    });
    return {createLocalData, OrgData, OrgEditing, installSelectionMenu, blockOrg, setResult, setError, toolbarFor, editorToolbar, editorForToolbar, blockCodeItems, escapeAttr, blockIsHidden, blockEnvMaker, controllerEval, getDocumentParams, basicDataFilter, replacementFor, parseYaml, makeImageBlob, makeBlobUrl, getId, fileTypes, updateSelection, addSelectionBubble, parseOrgDoc, DataIndexer};
  });

}).call(this);

//# sourceMappingURL=editorSupport.js.map
