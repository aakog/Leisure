// Generated by CoffeeScript 1.10.0
(function() {
  var slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['jquery', './domCursor', './lib/fingertree', 'immutable', './advice', 'lib/bluebird.min'], function(jq, DOMCursor, Fingertree, Immutable, Advice, Bluebird) {
    var BS, BasicEditingOptions, BlockErrors, DEL, DOWN, DataStore, DataStoreEditingOptions, END, ENTER, HOME, LEFT, LeisureEditCore, Observable, PAGEDOWN, PAGEUP, Promise, RIGHT, Set, TAB, UP, _to_ascii, activating, afterMethod, beforeMethod, blockText, changeAdvice, computeNewStructure, copy, copyBlock, defaultBindings, dragRange, escapeHtml, eventChar, findEditor, getEventChar, htmlForNode, idCounter, indexNode, insertAfterSplit, insertInSplit, isAlphabetic, isEditable, keyFuncs, last, link, maxLastKeys, modifiers, modifyingKey, posFor, preserveSelection, preservingSelection, replacements, root, selectRange, shiftKey, shiftUps, specialKeys, treeToArray, validateBatch, wrapDiag;
    selectRange = DOMCursor.selectRange;
    Set = Immutable.Set;
    beforeMethod = Advice.beforeMethod, afterMethod = Advice.afterMethod, changeAdvice = Advice.changeAdvice;
    Promise = Bluebird.Promise;
    maxLastKeys = 4;
    BS = 8;
    ENTER = 13;
    DEL = 46;
    TAB = 9;
    LEFT = 37;
    UP = 38;
    RIGHT = 39;
    DOWN = 40;
    HOME = 36;
    END = 35;
    PAGEUP = 33;
    PAGEDOWN = 34;
    specialKeys = {};
    specialKeys[TAB] = 'TAB';
    specialKeys[ENTER] = 'ENTER';
    specialKeys[BS] = 'BS';
    specialKeys[DEL] = 'DEL';
    specialKeys[LEFT] = 'LEFT';
    specialKeys[RIGHT] = 'RIGHT';
    specialKeys[UP] = 'UP';
    specialKeys[DOWN] = 'DOWN';
    specialKeys[PAGEUP] = 'PAGEUP';
    specialKeys[PAGEDOWN] = 'PAGEDOWN';
    specialKeys[HOME] = 'HOME';
    specialKeys[END] = 'END';
    keyFuncs = {
      backwardChar: function(editor, e, r) {
        e.preventDefault();
        editor.moveSelectionBackward(r);
        return false;
      },
      forwardChar: function(editor, e, r) {
        e.preventDefault();
        editor.moveSelectionForward(r);
        return false;
      },
      previousLine: function(editor, e, r) {
        e.preventDefault();
        editor.moveSelectionUp(r);
        return false;
      },
      nextLine: function(editor, e, r) {
        e.preventDefault();
        editor.moveSelectionDown(r);
        return false;
      },
      stabilizeCursor: function(editor, e, r) {
        setTimeout((function() {
          return editor.domCursorForCaret().moveCaret();
        }), 1);
        return false;
      }
    };
    defaultBindings = {
      'C-Z': function() {
        return alert('UNDO not supported yet');
      },
      'C-S-Z': function() {
        return alert('REDO not supported yet');
      },
      'C-Y': function() {
        return alert('REDO not supported yet');
      },
      'UP': keyFuncs.previousLine,
      'DOWN': keyFuncs.nextLine,
      'LEFT': keyFuncs.backwardChar,
      'RIGHT': keyFuncs.forwardChar,
      'HOME': keyFuncs.stabilizeCursor,
      'END': keyFuncs.stabilizeCursor,
      'C-HOME': keyFuncs.stabilizeCursor,
      'C-END': keyFuncs.stabilizeCursor
    };
    dragRange = null;
    idCounter = 0;
    Observable = (function() {
      function Observable() {
        this.listeners = {};
        this.suppressingTriggers = false;
      }

      Observable.prototype.on = function(type, callback) {
        if (typeof type === 'object') {
          for (type in type) {
            callback = type[type];
            this.on(type(callback));
          }
        } else {
          if (!this.listeners[type]) {
            this.listeners[type] = [];
          }
          this.listeners[type].push(callback);
        }
        return this;
      };

      Observable.prototype.off = function(type, callback) {
        var l;
        if (typeof type === 'object') {
          for (type in type) {
            callback = type[type];
            this.off(type, callback);
          }
        } else {
          if (this.listeners[type]) {
            this.listeners[type] = (function() {
              var j, len, ref, results1;
              ref = this.listeners[type];
              results1 = [];
              for (j = 0, len = ref.length; j < len; j++) {
                l = ref[j];
                if (l !== callback) {
                  results1.push(l);
                }
              }
              return results1;
            }).call(this);
          }
        }
        return this;
      };

      Observable.prototype.trigger = function() {
        var args, j, len, listener, ref, results1, type;
        type = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (!this.suppressingTriggers) {
          ref = this.listeners[type] || [];
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            listener = ref[j];
            results1.push(listener.apply(null, args));
          }
          return results1;
        }
      };

      Observable.prototype.suppressTriggers = function(func) {
        var oldSuppress;
        oldSuppress = this.suppressingTriggers;
        this.suppressingTriggers = true;
        try {
          return func();
        } finally {
          this.suppressingTriggers = oldSuppress;
        }
      };

      return Observable;

    })();
    LeisureEditCore = (function(superClass) {
      extend(LeisureEditCore, superClass);

      function LeisureEditCore(node1, options) {
        this.node = node1;
        this.options = options;
        LeisureEditCore.__super__.constructor.call(this);
        this.editing = false;
        this.node.attr('contenteditable', 'true').attr('spellcheck', 'false');
        this.node.data().editor = this;
        this.curKeyBinding = this.prevKeybinding = null;
        this.bind();
        this.lastKeys = [];
        this.modCancelled = false;
        this.clipboardKey = null;
        this.ignoreModCheck = 0;
        this.movementGoal = null;
        this.options.setEditor(this);
        this.currentSelectedBlock = null;
      }

      LeisureEditCore.prototype.editWith = function(func) {
        this.editing = true;
        try {
          return func();
        } finally {
          this.editing = false;
        }
      };

      LeisureEditCore.prototype.savePosition = function(func) {
        var error, pos;
        if (this.editing) {
          return func();
        } else {
          pos = this.getSelectedDocRange();
          try {
            return func();
          } catch (error) {
            return this.selectDocRange(pos);
          }
        }
      };

      LeisureEditCore.prototype.getCopy = function(id) {
        return copy(this.options.getBlock(id));
      };

      LeisureEditCore.prototype.getText = function() {
        return this.options.getText();
      };

      LeisureEditCore.prototype.blockForCaret = function() {
        return this.blockForNode(this.domCursorForCaret().node);
      };

      LeisureEditCore.prototype.blockForNode = function(node) {
        return this.options.getBlock(this.options.idForNode(node));
      };

      LeisureEditCore.prototype.blockNodeForNode = function(node) {
        return this.options.nodeForId(this.options.idForNode(node));
      };

      LeisureEditCore.prototype.blockTextForNode = function(node) {
        var next, nextPos, parent, ref;
        parent = $(this.blockNodeForNode(node))[0];
        if (next = (ref = this.options.getBlock(this.options.idForNode(node))) != null ? ref.next : void 0) {
          nextPos = this.domCursorForText(this.options.nodeForId(next), 0);
          return this.domCursorForText(parent, 0, parent).getTextTo(nextPos);
        } else {
          return this.domCursorForText(parent, 0, parent).getText();
        }
      };

      LeisureEditCore.prototype.verifyNode = function(node) {
        if (typeof node === 'string') {
          node = this.options.nodeForId(node);
        }
        return this.blockTextForNode(node) === this.options.getBlock(this.options.idForNode(node)).text;
      };

      LeisureEditCore.prototype.verifyAllNodes = function() {
        var badIds, block, node;
        badIds = [];
        block = this.options.getBlock(this.options.getFirst());
        while (block) {
          if ((node = this.options.nodeForId(block._id)[0]) && !this.verifyNode(node)) {
            badIds.push(block._id);
          }
          block = this.options.getBlock(block.next);
        }
        if (badIds.length) {
          return badIds;
        }
      };

      LeisureEditCore.prototype.domCursor = function(node, pos) {
        if (node instanceof jQuery) {
          node = node[0];
          pos = pos != null ? pos : 0;
        } else if (node instanceof DOMCursor) {
          pos = node.pos;
          node = node.node;
        }
        return this.options.domCursor(node, pos);
      };

      LeisureEditCore.prototype.domCursorForText = function(node, pos, parent) {
        var c;
        c = this.domCursor(node, pos).filterTextNodes().firstText();
        if (parent != null) {
          return c.filterParent(parent);
        } else {
          return c;
        }
      };

      LeisureEditCore.prototype.domCursorForTextPosition = function(parent, pos, contain) {
        return this.domCursorForText(parent, 0, (contain ? parent : void 0)).mutable().forwardChars(pos, contain).adjustForNewline();
      };

      LeisureEditCore.prototype.domCursorForCaret = function() {
        var n, r, sel;
        sel = getSelection();
        if (sel.type === 'None') {
          return DOMCursor.emptyDOMCursor;
        } else {
          r = sel.getRangeAt(0);
          n = this.domCursor(r.startContainer, r.startOffset).mutable().filterVisibleTextNodes().filterParent(this.node[0]).firstText();
          if (n.isEmpty() || n.pos <= n.node.length) {
            return n;
          } else {
            return n.next();
          }
        }
      };

      LeisureEditCore.prototype.getTextPosition = function(parent, target, pos) {
        var targ;
        if (parent) {
          targ = this.domCursorForText(target, pos);
          if (!this.options.getContainer(targ.node)) {
            targ = targ.prev();
          }
          return this.domCursorForText(parent, 0, parent).mutable().countChars(targ.node, targ.pos);
        } else {
          return -1;
        }
      };

      LeisureEditCore.prototype.loadURL = function(url) {
        return $.get(url, (function(_this) {
          return function(text) {
            return _this.options.load(text);
          };
        })(this));
      };

      LeisureEditCore.prototype.domCursorForDocOffset = function(dOff) {
        var bOff, node;
        bOff = this.options.blockOffsetForDocOffset(dOff);
        node = this.options.nodeForId(bOff.block);
        return this.domCursorForText(node, 0).mutable().forwardChars(bOff.offset);
      };

      LeisureEditCore.prototype.docOffsetForCaret = function() {
        var range, s;
        s = getSelection();
        if (s.type === 'None') {
          return -1;
        } else {
          range = s.getRangeAt(0);
          return this.docOffset(range.startContainer, range.startOffset);
        }
      };

      LeisureEditCore.prototype.docOffsetForBlockOffset = function(block, offset) {
        return this.options.docOffsetForBlockOffset(block, offset);
      };

      LeisureEditCore.prototype.docOffset = function(node, offset) {
        var startHolder;
        if (node instanceof Range) {
          offset = node.startOffset;
          node = node.startContainer;
        } else if (node instanceof DOMCursor) {
          offset = node.pos;
          node = node.node;
        }
        if (startHolder = this.options.getContainer(node)) {
          return this.options.docOffsetForBlockOffset(this.options.idForNode(startHolder), this.getTextPosition(startHolder, node, offset));
        }
      };

      LeisureEditCore.prototype.getSelectedDocRange = function() {
        var end, length, range, s, start;
        s = getSelection();
        if (s.type === 'None') {
          return {
            type: 'None'
          };
        } else {
          range = s.getRangeAt(0);
          if (start = this.docOffset(range.startContainer, range.startOffset)) {
            if (s.type === 'Caret') {
              length = 0;
            } else {
              end = this.docOffset(range.endContainer, range.endOffset);
              length = Math.abs(start - end);
              start = Math.min(start, end);
            }
            return {
              type: s.type,
              start: start,
              length: length,
              scrollTop: this.node[0].scrollTop,
              scrollLeft: this.node[0].scrollLeft
            };
          } else {
            return {
              type: 'None'
            };
          }
        }
      };

      LeisureEditCore.prototype.selectDocRange = function(range) {
        var start;
        if (range.type !== 'None' && !(start = this.domCursorForDocOffset(range.start).save()).isEmpty()) {
          selectRange(start.range(start.mutable().forwardChars(range.length)));
          this.node[0].scrollTop = range.scrollTop;
          return this.node[0].scrollLeft = range.scrollLeft;
        }
      };

      LeisureEditCore.prototype.getSelectedBlockRange = function() {
        var p, s;
        s = getSelection();
        if (s.type !== 'None' && (p = this.blockOffset(s.getRangeAt(0)))) {
          p.type = s.type;
          p.length = this.selectedText(s).length;
          return p;
        } else {
          return {
            type: 'None'
          };
        }
      };

      LeisureEditCore.prototype.blockOffset = function(node, offset) {
        var startHolder;
        if (node instanceof Range) {
          offset = node.startOffset;
          node = node.startContainer;
        } else if (node instanceof DOMCursor) {
          offset = node.pos;
          node = node.node;
        }
        if (startHolder = this.options.getContainer(node)) {
          return {
            block: this.options.getBlock(this.options.idForNode(startHolder)),
            offset: this.getTextPosition(startHolder, node, offset)
          };
        }
      };

      LeisureEditCore.prototype.blockRangeForOffsets = function(start, length) {
        var block, offset, ref;
        ref = this.options.getBlockOffsetForPosition(start), block = ref.block, offset = ref.offset;
        return {
          block: block,
          offset: offset,
          length: length,
          type: length === 0 ? 'Caret' : 'Range'
        };
      };

      LeisureEditCore.prototype.replace = function(e, br, text, select) {
        if (br.type !== 'None') {
          return this.editWith((function(_this) {
            return function() {
              var pos, start;
              start = _this.options.docOffsetForBlockOffset(br);
              pos = _this.getSelectedDocRange();
              text = text != null ? text : getEventChar(e);
              _this.options.replaceText({
                start: start,
                end: start + br.length,
                text: text,
                source: 'edit'
              });
              if (select) {
                pos.type = text.length === 0 ? 'Caret' : 'Range';
                pos.length = text.length;
              } else {
                pos.type = 'Caret';
                pos.length = 0;
                pos.start += text.length;
              }
              return _this.selectDocRange(pos);
            };
          })(this));
        }
      };

      LeisureEditCore.prototype.backspace = function(event, sel, r) {
        var holderId;
        if (sel.type === 'Range') {
          return this.cutText(event);
        }
        holderId = this.idAtCaret(sel);
        this.currentBlockIds = [holderId];
        return this.handleDelete(event, sel, false);
      };

      LeisureEditCore.prototype.del = function(event, sel, r) {
        var holderId;
        if (sel.type === 'Range') {
          return this.cutText(event);
        }
        holderId = this.idAtCaret(sel);
        this.currentBlockIds = [holderId];
        return this.handleDelete(event, sel, true);
      };

      LeisureEditCore.prototype.idAtCaret = function(sel) {
        return this.options.idForNode(this.options.getContainer(sel.anchorNode));
      };

      LeisureEditCore.prototype.selectedText = function(s) {
        var r;
        r = s.getRangeAt(0);
        if (r.collapsed) {
          return '';
        } else {
          return this.domCursor(r.startContainer, r.startOffset).getTextTo(this.domCursor(r.endContainer, r.endOffset));
        }
      };

      LeisureEditCore.prototype.cutText = function(e) {
        var html, node, sel, text;
        e.preventDefault();
        sel = getSelection();
        if (sel.type === 'Range') {
          html = ((function() {
            var j, len, ref, results1;
            ref = sel.getRangeAt(0).cloneContents().childNodes;
            results1 = [];
            for (j = 0, len = ref.length; j < len; j++) {
              node = ref[j];
              results1.push(htmlForNode(node));
            }
            return results1;
          })()).join('');
          text = this.selectedText(sel);
          this.options.simulateCut({
            html: html,
            text: text
          });
          return this.replace(e, this.getSelectedBlockRange(), '');
        }
      };

      LeisureEditCore.prototype.handleDelete = function(e, s, forward) {
        var r, sel;
        e.preventDefault();
        r = this.getSelectedDocRange();
        if (r.type === 'None' || (r.type === 'Caret' && ((forward && r.start >= this.options.getLength() - 1) || (!forward && r.start === 0)))) {
          return;
        }
        if (r.type === 'Caret') {
          r.length = 1;
          if (!forward) {
            r.start -= 1;
          }
        }
        this.options.replaceText({
          start: r.start,
          end: r.start + r.length,
          text: '',
          source: 'edit'
        });
        sel = this.getSelectedDocRange();
        return this.selectDocRange({
          type: 'Caret',
          start: r.start,
          length: 0,
          scrollTop: sel.scrollTop,
          scrollLeft: sel.scrollLeft
        });
      };

      LeisureEditCore.prototype.bind = function() {
        this.bindDragAndDrop();
        this.bindClipboard();
        this.bindMouse();
        return this.bindKeyboard();
      };

      LeisureEditCore.prototype.bindDragAndDrop = function() {
        this.node.on('dragover', (function(_this) {
          return function(e) {
            _this.options.dragOver(e.originalEvent);
            return true;
          };
        })(this));
        this.node.on('dragenter', (function(_this) {
          return function(e) {
            _this.options.dragEnter(e.originalEvent);
            return true;
          };
        })(this));
        this.node.on('drop', (function(_this) {
          return function(e) {
            var blockId, cutOffset, dr, dropContainer, dropPos, insert, insertOffset, insertText, oe, offset, r, r2, start;
            e.preventDefault();
            oe = e.originalEvent;
            oe.dataTransfer.dropEffect = 'move';
            r = document.caretRangeFromPoint(oe.clientX, oe.clientY);
            dropPos = _this.domCursor(r.startContainer, r.startOffset).moveCaret();
            dropContainer = _this.domCursor(_this.options.getContainer(r.startContainer), 0);
            blockId = _this.options.idForNode(dropContainer.node);
            offset = dropContainer.countChars(dropPos);
            insertText = oe.dataTransfer.getData('text/plain');
            insert = function() {
              return _this.replace(e, {
                type: 'Caret',
                offset: offset,
                block: _this.options.getBlock(blockId),
                length: 0
              }, insertText, false);
            };
            if (dragRange) {
              start = _this.domCursor(_this.options.nodeForId(dragRange.block._id), 0).forwardChars(dragRange.offset);
              r2 = start.range(start.forwardChars(dragRange.length));
              insertOffset = _this.options.getPositionForBlock(_this.options.getBlock(blockId)) + offset;
              cutOffset = _this.options.getPositionForBlock(dragRange.block) + dragRange.offset;
              if ((cutOffset <= insertOffset && insertOffset <= cutOffset + dragRange.length)) {
                oe.preventDefault();
                oe.dataTransfer.dropEffect = 'none';
                return;
              }
              dr = dragRange;
              dragRange = null;
              if (insertOffset <= cutOffset) {
                _this.replace(e, dr, '', false);
                _this.replace(e, _this.blockRangeForOffsets(insertOffset, 0), insertText, false);
              } else {
                insert();
                _this.replace(e, _this.blockRangeForOffsets(cutOffset, dr.length), '', false);
              }
            } else {
              insert();
            }
            return true;
          };
        })(this));
        this.node.on('dragstart', (function(_this) {
          return function(e) {
            var clipboard, node, sel;
            sel = getSelection();
            if (sel.type === 'Range') {
              dragRange = _this.getSelectedBlockRange();
              clipboard = e.originalEvent.dataTransfer;
              clipboard.setData('text/html', ((function() {
                var j, len, ref, results1;
                ref = sel.getRangeAt(0).cloneContents().childNodes;
                results1 = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  node = ref[j];
                  results1.push(htmlForNode(node));
                }
                return results1;
              })()).join(''));
              clipboard.setData('text/plain', _this.selectedText(sel));
              clipboard.effectAllowed = 'copyMove';
              clipboard.dropEffect = 'move';
            }
            return true;
          };
        })(this));
        return this.node[0].addEventListener('dragend', (function(_this) {
          return function(e) {
            var dr, sel;
            if (dr = dragRange) {
              dragRange = null;
              if (e.dataTransfer.dropEffect === 'move') {
                e.preventDefault();
                sel = _this.getSelectedDocRange();
                _this.replace(e, dr, '');
                return _this.selectDocRange(sel);
              }
            }
          };
        })(this));
      };

      LeisureEditCore.prototype.bindClipboard = function() {
        this.node.on('cut', (function(_this) {
          return function(e) {
            var clipboard, node, sel;
            e.preventDefault();
            sel = getSelection();
            if (sel.type === 'Range') {
              clipboard = e.originalEvent.clipboardData;
              clipboard.setData('text/html', ((function() {
                var j, len, ref, results1;
                ref = sel.getRangeAt(0).cloneContents().childNodes;
                results1 = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  node = ref[j];
                  results1.push(htmlForNode(node));
                }
                return results1;
              })()).join(''));
              clipboard.setData('text/plain', _this.selectedText(sel));
              return _this.replace(e, _this.getSelectedBlockRange(), '');
            }
          };
        })(this));
        this.node.on('copy', (function(_this) {
          return function(e) {
            var clipboard, node, sel;
            e.preventDefault();
            sel = getSelection();
            if (sel.type === 'Range') {
              clipboard = e.originalEvent.clipboardData;
              clipboard.setData('text/html', ((function() {
                var j, len, ref, results1;
                ref = sel.getRangeAt(0).cloneContents().childNodes;
                results1 = [];
                for (j = 0, len = ref.length; j < len; j++) {
                  node = ref[j];
                  results1.push(htmlForNode(node));
                }
                return results1;
              })()).join(''));
              return clipboard.setData('text/plain', _this.selectedText(sel));
            }
          };
        })(this));
        return this.node.on('paste', (function(_this) {
          return function(e) {
            e.preventDefault();
            return _this.replace(e, _this.getSelectedBlockRange(), e.originalEvent.clipboardData.getData('text/plain'), false);
          };
        })(this));
      };

      LeisureEditCore.prototype.bindMouse = function() {
        this.node.on('mousedown', (function(_this) {
          return function(e) {
            setTimeout((function() {
              return _this.trigger('moved', _this);
            }), 1);
            return _this.setCurKeyBinding(null);
          };
        })(this));
        return this.node.on('mouseup', (function(_this) {
          return function(e) {
            _this.adjustSelection(e);
            return _this.trigger('moved', _this);
          };
        })(this));
      };

      LeisureEditCore.prototype.bindKeyboard = function() {
        this.node.on('keyup', (function(_this) {
          return function(e) {
            return _this.handleKeyup(e);
          };
        })(this));
        this.node.on('keydown', (function(_this) {
          return function(e) {
            var bound, c, checkMod, r, ref, s;
            _this.modCancelled = false;
            c = eventChar(e);
            if (!_this.addKeyPress(e, c)) {
              return;
            }
            s = getSelection();
            r = s.rangeCount > 0 && s.getRangeAt(0);
            _this.currentBlockIds = _this.blockIdsForSelection(s, r);
            ref = _this.findKeyBinding(e, r), bound = ref[0], checkMod = ref[1];
            if (bound) {
              return _this.modCancelled = !checkMod;
            } else {
              _this.modCancelled = false;
              if (c === ENTER) {
                return _this.enter(e);
              } else if (c === BS) {
                e.preventDefault();
                return _this.backspace(e, s, r);
              } else if (c === DEL) {
                e.preventDefault();
                return _this.del(e, s, r);
              } else if ((modifyingKey(c, e)) && !isAlphabetic(e)) {
                _this.char = getEventChar(e);
                return _this.keyPress(e);
              }
            }
          };
        })(this));
        return this.node.on('keypress', (function(_this) {
          return function(e) {
            return _this.keyPress(e);
          };
        })(this));
      };

      LeisureEditCore.prototype.enter = function(e) {
        e.preventDefault();
        return this.replace(e, this.getSelectedBlockRange(), '\n', false);
      };

      LeisureEditCore.prototype.keyPress = function(e) {
        e.preventDefault();
        return this.replace(e, this.getSelectedBlockRange(), null, false);
      };

      LeisureEditCore.prototype.blockIdsForSelection = function(sel, r) {
        var blocks, cont, cur, end;
        if (!sel) {
          sel = getSelection();
        }
        if (sel.rangeCount === 1) {
          if (!r) {
            r = sel.getRangeAt(0);
          }
          blocks = (cont = this.options.getContainer(r.startContainer)) ? [this.options.idForNode(cont)] : [];
          if (!(r != null ? r.collapsed : void 0)) {
            cur = blocks[0];
            end = this.options.idForNode(this.options.getContainer(r.endContainer));
            while (cur && cur !== end) {
              if (cur = (this.getCopy(cur)).next) {
                blocks.push(cur);
              }
            }
          }
          return blocks;
        }
      };

      LeisureEditCore.prototype.setCurKeyBinding = function(f) {
        this.prevKeybinding = this.curKeyBinding;
        return this.curKeyBinding = f;
      };

      LeisureEditCore.prototype.addKeyPress = function(e, c) {
        var i, j, notShift, ref;
        if (notShift = !shiftKey(c)) {
          e.DE_editorShiftkey = true;
          this.lastKeys.push(modifiers(e, c));
          while (this.lastKeys.length > maxLastKeys) {
            this.lastKeys.shift();
          }
          this.keyCombos = new Array(maxLastKeys);
          for (i = j = 0, ref = Math.min(this.lastKeys.length, maxLastKeys); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            this.keyCombos[i] = this.lastKeys.slice(this.lastKeys.length - i - 1, this.lastKeys.length).join(' ');
          }
          this.keyCombos.reverse();
        }
        return notShift;
      };

      LeisureEditCore.prototype.findKeyBinding = function(e, r) {
        var f, j, k, len, ref;
        ref = this.keyCombos;
        for (j = 0, len = ref.length; j < len; j++) {
          k = ref[j];
          if (f = this.options.bindings[k]) {
            this.lastKeys = [];
            this.keyCombos = [];
            this.setCurKeyBinding(f);
            return [true, f(this, e, r)];
          }
        }
        this.setCurKeyBinding(null);
        return [false];
      };

      LeisureEditCore.prototype.handleKeyup = function(e) {
        if (this.ignoreModCheck = this.ignoreModCheck) {
          this.ignoreModCheck--;
        }
        if (this.clipboardKey || (!e.DE_shiftkey && !this.modCancelled && modifyingKey(eventChar(e), e))) {
          this.options.keyUp();
          return this.clipboardKey = null;
        }
      };

      LeisureEditCore.prototype.adjustSelection = function(e) {
        var pos, r, s;
        if (e.detail === 1) {
          return;
        }
        s = getSelection();
        if (s.type === 'Range') {
          r = s.getRangeAt(0);
          pos = this.domCursor(r.endContainer, r.endOffset).mutable().filterVisibleTextNodes().firstText();
          while (pos.node !== r.startContainer && pos.node.data.trim() === '') {
            pos = pos.prev();
          }
          while (pos.pos > 0 && pos.node.data[pos.pos - 1] === ' ') {
            pos.pos--;
          }
          if ((pos.node !== r.startContainer || pos.pos > r.startOffset) && (pos.node !== r.endContainer || pos.pos < r.endOffset)) {
            r.setEnd(pos.node, pos.pos);
            return selectRange(r);
          }
        }
      };

      LeisureEditCore.prototype.moveSelectionForward = function() {
        return this.showCaret(this.moveForward());
      };

      LeisureEditCore.prototype.moveSelectionDown = function() {
        return this.showCaret(this.moveDown());
      };

      LeisureEditCore.prototype.moveSelectionBackward = function() {
        return this.showCaret(this.moveBackward());
      };

      LeisureEditCore.prototype.moveSelectionUp = function() {
        return this.showCaret(this.moveUp());
      };

      LeisureEditCore.prototype.showCaret = function(pos) {
        if (pos.isEmpty()) {
          pos = pos.prev();
        }
        pos = this.domCursorForCaret();
        pos.moveCaret();
        (pos.node.nodeType === pos.node.TEXT_NODE ? pos.node.parentNode : pos.node).scrollIntoViewIfNeeded();
        return this.trigger('moved', this);
      };

      LeisureEditCore.prototype.moveForward = function() {
        var offset, pos, r, sel, start;
        sel = getSelection();
        offset = sel.type === 'None' ? 0 : (r = sel.getRangeAt(0), offset = r.endContainer === r.startContainer ? this.docOffset(r.endContainer, Math.max(r.startOffset, r.endOffset)) : this.docOffset(r.endContainer, r.endOffset));
        start = pos = this.domCursorForCaret().firstText().save();
        while (!pos.isEmpty() && this.options.isValidDocOffset(offset) && (this.domCursorForCaret().firstText().equals(start) || DOMCursor.isCollapsed(pos.node))) {
          pos = this.domCursorForDocOffset(++offset);
          pos.moveCaret();
        }
        if (pos.isEmpty()) {
          offset = this.options.getLength() - 1;
          pos = this.domCursorForDocOffset(offset).firstText();
          while (!pos.isEmpty() && DOMCursor.isCollapsed(pos.node)) {
            pos = this.domCursorForDocOffset(--offset);
          }
        } else if (!this.options.isValidDocOffset(offset)) {
          pos = start;
        }
        return pos.moveCaret();
      };

      LeisureEditCore.prototype.moveBackward = function() {
        var offset, pos, r, sel, start;
        sel = getSelection();
        offset = sel.type === 'None' ? 0 : (r = sel.getRangeAt(0), offset = r.endContainer === r.startContainer ? this.docOffset(r.endContainer, Math.min(r.startOffset, r.endOffset)) : this.docOffset(r.startContainer, r.startOffset));
        start = pos = this.domCursorForCaret().firstText().save();
        while (!pos.isEmpty() && (this.domCursorForCaret().firstText().equals(start) || DOMCursor.isCollapsed(pos.node))) {
          pos = this.domCursorForDocOffset(--offset);
          pos.moveCaret();
        }
        if (pos.isEmpty()) {
          offset = 0;
          pos = this.domCursorForDocOffset(offset).firstText();
          while (!pos.isEmpty() && DOMCursor.isCollapsed(pos.node)) {
            pos = this.domCursorForDocOffset(++offset);
          }
        }
        return pos.moveCaret();
      };

      LeisureEditCore.prototype.firstText = function() {
        return this.domCursor(this.node, 0).firstText().node;
      };

      LeisureEditCore.prototype.moveDown = function() {
        var docPos, lastPos, line, linePos, lineTop, p, pos, prev, ref;
        linePos = prev = pos = this.domCursorForCaret().save();
        if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
          this.movementGoal = this.options.blockColumn(pos);
          line = 0;
        } else {
          line = (pos.pos === 0 && pos.node === this.firstText() && this.options.blockColumn(pos) < this.movementGoal ? 1 : 0);
        }
        lineTop = posFor(linePos).top;
        lastPos = this.docOffset(pos) - 1;
        while (!(pos = this.moveForward()).isEmpty() && (docPos = this.docOffset(pos)) !== lastPos) {
          lastPos = docPos;
          p = posFor(pos);
          if (lineTop < p.top) {
            line++;
            pos = linePos = p.pos;
            lineTop = p.top;
          }
          if (line === 2) {
            return prev.moveCaret();
          }
          if (line === 1 && this.options.blockColumn(pos) >= this.movementGoal) {
            return this.moveToBestPosition(pos, prev, linePos);
          }
          prev = pos;
        }
        return pos;
      };

      LeisureEditCore.prototype.moveUp = function() {
        var docPos, lastPos, line, linePos, pos, prev, ref;
        linePos = prev = pos = this.domCursorForCaret().save();
        if (!((ref = this.prevKeybinding) === keyFuncs.nextLine || ref === keyFuncs.previousLine)) {
          this.movementGoal = this.options.blockColumn(pos);
        }
        line = 0;
        lastPos = this.options.getLength();
        while (!(pos = this.moveBackward()).isEmpty() && (docPos = this.docOffset(pos)) !== lastPos) {
          lastPos = docPos;
          if (linePos.differentLines(pos)) {
            line++;
            linePos = pos;
          }
          if (line === 2) {
            return prev.moveCaret();
          }
          if (line === 1 && this.options.blockColumn(pos) <= this.movementGoal) {
            return this.moveToBestPosition(pos, prev, linePos);
          }
          prev = pos;
        }
        return pos;
      };

      LeisureEditCore.prototype.moveToBestPosition = function(pos, prev, linePos) {
        if (linePos === pos || Math.abs(this.options.blockColumn(pos) - this.movementGoal) < Math.abs(this.options.blockColumn(prev) - this.movementGoal)) {
          return pos;
        } else {
          return prev.moveCaret();
        }
      };

      LeisureEditCore.prototype.setHtml = function(el, html, outer) {
        var next, par, prev, ref, ref1;
        if (outer) {
          prev = el.previousSibling;
          next = el.nextSibling;
          par = el.parentNode;
          el.outerHTML = html;
          el = (ref = (ref1 = prev != null ? prev.nextSibling : void 0) != null ? ref1 : next != null ? next.previousSibling : void 0) != null ? ref : par != null ? par.firstChild : void 0;
        } else {
          el.innerHTML = html;
        }
        this.activateScripts($(el));
        return el;
      };

      LeisureEditCore.prototype.activateScripts = function(jq) {
        var activating, j, len, newScript, ref, results1, script, text;
        if (!activating) {
          activating = true;
          try {
            ref = jq.find('script');
            results1 = [];
            for (j = 0, len = ref.length; j < len; j++) {
              script = ref[j];
              text = !script.type || script.type.toLowerCase() === 'text/javascript' ? script.textContent : script.type.toLowerCase() === 'text/coffeescript' ? CoffeeScript.compile(script.textContent, {
                bare: true
              }) : script.type.toLowerCase() === 'text/literate-coffeescript' ? CoffeeScript.compile(script.textContent, {
                bare: true,
                literate: true
              }) : void 0;
              if (text) {
                newScript = document.createElement('script');
                newScript.type = 'text/javascript';
                if (script.src) {
                  newScript.src = script.src;
                }
                newScript.textContent = text;
                this.setCurrentScript(newScript);
                script.parentNode.insertBefore(newScript, script);
                results1.push(script.parentNode.removeChild(script));
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          } finally {
            this.setCurrentScript(null);
            activating = false;
          }
        }
      };

      LeisureEditCore.prototype.setCurrentScript = function(script) {
        return LeisureEditCore.currentScript = null;
      };

      return LeisureEditCore;

    })(Observable);
    eventChar = function(e) {
      return e.charCode || e.keyCode || e.which;
    };
    isAlphabetic = function(e) {
      var ref;
      return !e.altKey && !e.ctrlKey && !e.metaKey && ((64 < (ref = eventChar(e)) && ref < 91));
    };
    BasicEditingOptions = (function(superClass) {
      extend(BasicEditingOptions, superClass);

      BasicEditingOptions.prototype.renderBlock = function(block) {
        throw new Error("options.renderBlock(block) is not implemented");
      };

      BasicEditingOptions.prototype.edit = function(prev, oldBlocks, newBlocks) {
        throw new Error("options.edit(func) is not implemented");
      };

      BasicEditingOptions.prototype.simulateCut = function(arg) {
        var html, text;
        html = arg.html, text = arg.text;
      };

      BasicEditingOptions.prototype.dragEnter = function(event) {
        if (!event.dataTransfer.getData) {
          event.preventDefault();
          return event.dropEffect = 'none';
        }
      };

      BasicEditingOptions.prototype.dragOver = function(event) {
        if (!event.dataTransfer.getData) {
          event.preventDefault();
          return event.dropEffect = 'none';
        }
      };

      BasicEditingOptions.prototype.editBlocks = function(blocks, start, length, newContent, select) {
        return this.editor.editBlocks(blocks, start, length, newContent, select);
      };

      function BasicEditingOptions() {
        BasicEditingOptions.__super__.constructor.call(this);
        this.changeContext = null;
        this.initData();
      }

      BasicEditingOptions.prototype.setDiagEnabled = function(flag) {
        changeAdvice(this, flag, {
          renderBlocks: {
            diag: wrapDiag
          },
          changed: {
            diag: wrapDiag
          }
        });
        if (flag) {
          return this.diag();
        }
      };

      BasicEditingOptions.prototype.diag = function() {
        return this.trigger('diag', this.editor.verifyAllNodes());
      };

      BasicEditingOptions.prototype.initData = function() {
        this.blocks = {};
        return this.first = null;
      };

      BasicEditingOptions.prototype.getFirst = function() {
        return this.first;
      };

      BasicEditingOptions.prototype.nodeForId = function(id) {
        return $("#" + id);
      };

      BasicEditingOptions.prototype.idForNode = function(node) {
        return $(node).prop(id);
      };

      BasicEditingOptions.prototype.setEditor = function(editor1) {
        this.editor = editor1;
      };

      BasicEditingOptions.prototype.newId = function() {
        return this.data.newId();
      };

      BasicEditingOptions.prototype.batchReplace = function(replacementFunc, contFunc, errorFunc) {
        var err, error;
        try {
          this.data.batchReplace(replacementFunc());
          return contFunc();
        } catch (error) {
          err = error;
          return errorFunc(err);
        }
      };

      BasicEditingOptions.prototype.replaceBlocks = function(prev, oldBlocks, newBlocks) {
        return this.change(this.data.changesFor(prev, oldBlocks, newBlocks));
      };

      BasicEditingOptions.prototype.changeStructure = function(oldBlocks, newText) {
        return computeNewStructure(this, oldBlocks, newText);
      };

      BasicEditingOptions.prototype.mergeChangeContext = function(obj) {
        var ref;
        return this.changeContext = _.merge({}, (ref = this.changeContext) != null ? ref : {}, obj);
      };

      BasicEditingOptions.prototype.clearChangeContext = function() {
        return this.changeContext = null;
      };

      BasicEditingOptions.prototype.makeStructureChange = function(start, end, text, arg) {
        var newBlocks, offset, oldBlocks, prev;
        oldBlocks = arg.oldBlocks, newBlocks = arg.newBlocks, offset = arg.offset, prev = arg.prev;
        try {
          if (oldBlocks.length || newBlocks.length) {
            return this.edit(prev, oldBlocks.slice(), newBlocks.slice());
          }
        } finally {
          this.clearChangeContext();
        }
      };

      BasicEditingOptions.prototype.change = function(changes) {
        var block, first, id, j, len, removes, sets;
        if (changes) {
          first = changes.first, removes = changes.removes, sets = changes.sets;
          this.first = first;
          for (j = 0, len = removes.length; j < len; j++) {
            id = removes[j];
            this.deleteBlock(id);
          }
          for (id in sets) {
            block = sets[id];
            this.setBlock(id, block);
          }
          return true;
        }
      };

      BasicEditingOptions.prototype.getBlock = function(id) {
        return this.blocks[id];
      };

      BasicEditingOptions.prototype.bindings = defaultBindings;

      BasicEditingOptions.prototype.blockColumn = function(pos) {
        return pos.textPosition().left;
      };

      BasicEditingOptions.prototype.topRect = function() {
        return null;
      };

      BasicEditingOptions.prototype.keyUp = function() {};

      BasicEditingOptions.prototype.domCursor = function(node, pos) {
        return new DOMCursor(node, pos).addFilter(function(n) {
          return (n.hasAttribute('data-noncontent') && 'skip') || true;
        });
      };

      BasicEditingOptions.prototype.getContainer = function(node) {
        if (this.editor.node[0].compareDocumentPosition(node) & Element.DOCUMENT_POSITION_CONTAINED_BY) {
          return $(node).closest('[data-block]')[0];
        }
      };

      BasicEditingOptions.prototype.load = function(name, text) {
        this.options.suppressTriggers((function(_this) {
          return function() {
            return _this.options.data.suppressTriggers(function() {
              return _this.replaceText({
                start: 0,
                end: _this.getLength(),
                text: text,
                source: 'edit'
              });
            });
          };
        })(this));
        this.rerenderAll();
        return this.trigger('load');
      };

      BasicEditingOptions.prototype.rerenderAll = function() {
        return this.editor.setHtml(this.editor.node[0], this.renderBlocks());
      };

      BasicEditingOptions.prototype.blockCount = function() {
        var b, c;
        c = 0;
        for (b in this.blocks) {
          c++;
        }
        return c;
      };

      BasicEditingOptions.prototype.blockList = function() {
        var bl, next, results1;
        next = this.getFirst();
        results1 = [];
        while (next) {
          bl = this.getBlock(next);
          next = bl.next;
          results1.push(bl);
        }
        return results1;
      };

      BasicEditingOptions.prototype.docOffsetForBlockOffset = function(bOff, offset) {
        return this.data.docOffsetForBlockOffset(bOff, offset);
      };

      BasicEditingOptions.prototype.blockOffsetForDocOffset = function(dOff) {
        return this.data.blockOffsetForDocOffset(dOff);
      };

      BasicEditingOptions.prototype.getPositionForBlock = function(block) {
        var cur, offset;
        cur = this.getBlock(this.getFirst());
        offset = 0;
        while (cur._id !== block._id) {
          offset += cur.text.length;
          cur = this.getBlock(cur.next);
        }
        return offset;
      };

      BasicEditingOptions.prototype.getBlockOffsetForPosition = function(pos) {
        var cur;
        cur = this.getBlock(this.getFirst());
        while (pos >= cur.text.length) {
          pos -= cur.text.length;
          cur = this.getBlock(cur.next);
        }
        return {
          block: cur,
          offset: pos
        };
      };

      BasicEditingOptions.prototype.renderBlocks = function() {
        var html, next, ref, result;
        result = '';
        next = this.getFirst();
        while (next && (ref = this.renderBlock(this.getBlock(next)), html = ref[0], next = ref[1], ref)) {
          result += html;
        }
        return result;
      };

      BasicEditingOptions.prototype.getText = function() {
        return this.data.getText();
      };

      BasicEditingOptions.prototype.getLength = function() {
        return this.data.getLength();
      };

      BasicEditingOptions.prototype.isValidDocOffset = function(offset) {
        return (0 <= offset && offset <= this.getLength());
      };

      return BasicEditingOptions;

    })(Observable);
    computeNewStructure = function(access, oldBlocks, newText) {
      var newBlocks, next, offset, oldText, prev, ref, ref1;
      prev = (ref = (ref1 = oldBlocks[0]) != null ? ref1.prev : void 0) != null ? ref : 0;
      oldBlocks = oldBlocks.slice();
      oldText = null;
      offset = 0;
      if (oldBlocks.length) {
        while (oldText !== newText && (oldBlocks[0].prev || last(oldBlocks).next)) {
          oldText = newText;
          if (prev = access.getBlock(oldBlocks[0].prev)) {
            oldBlocks.unshift(prev);
            newText = prev.text + newText;
            offset += prev.text.length;
          }
          if (next = access.getBlock(last(oldBlocks).next)) {
            oldBlocks.push(next);
            newText += next.text;
          }
          newBlocks = access.parseBlocks(newText);
          if ((!prev || prev.text === newBlocks[0].text) && (!next || next.text === last(newBlocks).text)) {
            break;
          }
        }
      }
      if (!newBlocks) {
        newBlocks = access.parseBlocks(newText);
      }
      while (oldBlocks.length && newBlocks.length && oldBlocks[0].text === newBlocks[0].text) {
        offset -= oldBlocks[0].text.length;
        prev = oldBlocks[0]._id;
        oldBlocks.shift();
        newBlocks.shift();
      }
      while (oldBlocks.length && newBlocks.length && last(oldBlocks).text === last(newBlocks).text) {
        oldBlocks.pop();
        newBlocks.pop();
      }
      return {
        oldBlocks: oldBlocks,
        newBlocks: newBlocks,
        offset: offset,
        prev: prev
      };
    };
    copyBlock = function(block) {
      var bl, k, v;
      if (!block) {
        return null;
      } else {
        bl = {};
        for (k in block) {
          v = block[k];
          bl[k] = v;
        }
        return bl;
      }
    };
    activating = false;
    DataStore = (function(superClass) {
      extend(DataStore, superClass);

      function DataStore() {
        DataStore.__super__.constructor.call(this);
        this.blocks = {};
        this.blockIndex = this.newBlockIndex();
        this.changeCount = 0;
        this.clearMarks();
        this.markNames = {};
      }

      DataStore.prototype.load = function(name, text) {
        var block, blockMap, i, j, len, newBlocks, prev, ref;
        blockMap = {};
        newBlocks = this.parseBlocks(text);
        for (i = j = 0, len = newBlocks.length; j < len; i = ++j) {
          block = newBlocks[i];
          block._id = this.newId();
          blockMap[block._id] = block;
          if (prev = newBlocks[i - 1]) {
            prev.next = block._id;
            block.prev = prev._id;
          }
        }
        this.first = (ref = newBlocks[0]) != null ? ref._id : void 0;
        this.blocks = blockMap;
        return this.makeChanges((function(_this) {
          return function() {
            _this.indexBlocks();
            return _this.trigger('load');
          };
        })(this));
      };

      DataStore.prototype.parseBlocks = function(text) {
        throw new Error("options.parseBlocks(text) is not implemented");
      };

      DataStore.prototype.newBlockIndex = function(contents) {
        return Fingertree.fromArray(contents != null ? contents : [], {
          identity: function() {
            return {
              ids: Set(),
              length: 0
            };
          },
          measure: function(v) {
            return {
              ids: Set([v.id]),
              length: v.length
            };
          },
          sum: function(a, b) {
            return {
              ids: a.ids.union(b.ids),
              length: a.length + b.length
            };
          }
        });
      };

      DataStore.prototype.newId = function() {
        return "block" + (idCounter++);
      };

      DataStore.prototype.setDiagEnabled = function(flag) {
        changeAdvice(this, flag, {
          makeChanges: {
            diag: afterMethod(function() {
              if (this.changeCount === 0) {
                return this.diag();
              }
            })
          }
        });
        if (flag) {
          return this.diag();
        }
      };

      DataStore.prototype.getLength = function() {
        return this.blockIndex.measure().length;
      };

      DataStore.prototype.makeChanges = function(func) {
        this.changeCount++;
        try {
          return func();
        } finally {
          this.changeCount--;
        }
      };

      DataStore.prototype.clearMarks = function() {
        return this.marks = Fingertree.fromArray([], {
          identity: function() {
            return {
              names: Set(),
              length: 0
            };
          },
          measure: function(n) {
            return {
              names: Set([n.name]),
              length: n.offset
            };
          },
          sum: function(a, b) {
            return {
              names: a.names.union(b.names),
              length: a.length + b.length
            };
          }
        });
      };

      DataStore.prototype.addMark = function(name, offset) {
        var first, l, n, ref, rest;
        if (this.markNames[name]) {
          this.removeMark(name);
        }
        this.markNames[name] = true;
        ref = this.marks.split(function(m) {
          return m.length >= offset;
        }), first = ref[0], rest = ref[1];
        l = first.measure().length;
        if (!rest.isEmpty()) {
          n = rest.peekFirst();
          rest = rest.removeFirst().addFirst({
            offset: l + n.offset - offset,
            name: n.name
          });
        }
        return this.marks = first.concat(rest.addFirst({
          offset: offset - l,
          name: name
        }));
      };

      DataStore.prototype.removeMark = function(name) {
        var first, n, ref, removed, rest;
        if (this.markNames[name]) {
          delete this.markNames[name];
          ref = this.marks.split(function(m) {
            return m.names.contains(name);
          }), first = ref[0], rest = ref[1];
          if (!rest.isEmpty()) {
            removed = rest.peekFirst();
            rest = rest.removeFirst();
            if (!rest.isEmpty()) {
              n = rest.peekFirst();
              rest = rest.removeFirst().addFirst({
                offset: removed.offset + n.offset,
                name: n.name
              });
            }
          }
          return this.marks = first.concat(rest);
        }
      };

      DataStore.prototype.listMarks = function() {
        var m, n, t;
        m = [];
        t = this.marks;
        while (!t.isEmpty()) {
          n = t.peekFirst();
          m.push(_.defaults({
            location: this.getMarkLocation(n.name)
          }, n));
          t = t.removeFirst();
        }
        return m;
      };

      DataStore.prototype.getMarkLocation = function(name) {
        var first, ref, rest;
        if (this.markNames[name]) {
          ref = this.marks.split(function(m) {
            return m.names.contains(name);
          }), first = ref[0], rest = ref[1];
          if (!rest.isEmpty()) {
            return first.measure().length + rest.peekFirst().offset;
          }
        }
      };

      DataStore.prototype.blockOffsetForMark = function(name) {
        var offset;
        if (offset = this.getMarkLocation(name)) {
          return this.blockOffsetForDocOffset(offset);
        }
      };

      DataStore.prototype.floatMarks = function(start, end, newLength) {
        var first, n, oldLength, ref, rest;
        if (newLength !== (oldLength = end - start)) {
          ref = this.marks.split(function(m) {
            return m.length > start;
          }), first = ref[0], rest = ref[1];
          if (!rest.isEmpty()) {
            n = rest.peekFirst();
            return this.marks = first.concat(rest.removeFirst().addFirst({
              name: n.name,
              offset: n.offset + newLength - oldLength
            }));
          }
        }
      };

      DataStore.prototype.batchReplace = function(replacements) {
        var j, len, ref, repl, results1;
        ref = validateBatch(replacements);
        results1 = [];
        for (j = 0, len = ref.length; j < len; j++) {
          repl = ref[j];
          results1.push(this.replaceText(repl));
        }
        return results1;
      };

      DataStore.prototype.replaceText = function(arg) {
        var end, newBlocks, oldBlocks, prev, ref, start, text;
        start = arg.start, end = arg.end, text = arg.text;
        ref = this.changesForReplacement(start, end, text), prev = ref.prev, oldBlocks = ref.oldBlocks, newBlocks = ref.newBlocks;
        if (oldBlocks) {
          this.change(this.changesFor(prev, oldBlocks.slice(), newBlocks.slice()));
          return this.floatMarks(start, end, text.length);
        }
      };

      DataStore.prototype.guardedReplaceText = function(start, end, text, gStart, gEnd) {
        this.replaceText({
          start: start,
          end: end,
          text: text,
          source: 'edit'
        });
        return Promise.resolve();
      };

      DataStore.prototype.changesForReplacement = function(start, end, text) {
        var blocks, change, newBlocks, newText, offset, oldBlocks, oldText, pos, prev, ref;
        blocks = this.blockOverlapsForReplacement(start, end, text).blocks;
        offset = this.blockOffsetForDocOffset(start).offset;
        oldText = blockText(blocks);
        newText = oldText.substring(0, offset) + text + oldText.substring(end - start + offset);
        pos = this.docOffsetForBlockOffset(blocks[0]._id, start);
        ref = change = computeNewStructure(this, blocks, newText), oldBlocks = ref.oldBlocks, newBlocks = ref.newBlocks, offset = ref.offset, prev = ref.prev;
        if (oldBlocks.length || newBlocks.length) {
          return change;
        } else {
          return {};
        }
      };

      DataStore.prototype.computeRemovesAndNewBlockIds = function(oldBlocks, newBlocks, newBlockMap, removes) {
        var i, j, len, len1, newBlock, o, oldBlock, prev, ref;
        ref = oldBlocks.slice(newBlocks.length, oldBlocks.length);
        for (j = 0, len = ref.length; j < len; j++) {
          oldBlock = ref[j];
          removes[oldBlock._id] = oldBlock;
        }
        prev = null;
        for (i = o = 0, len1 = newBlocks.length; o < len1; i = ++o) {
          newBlock = newBlocks[i];
          if (oldBlock = oldBlocks[i]) {
            newBlock._id = oldBlock._id;
            newBlock.prev = oldBlock.prev;
            newBlock.next = oldBlock.next;
          } else {
            newBlock._id = this.newId();
            if (prev) {
              link(prev, newBlock);
            }
          }
          prev = newBlockMap[newBlock._id] = newBlock;
        }
        return prev;
      };

      DataStore.prototype.patchNewBlocks = function(first, oldBlocks, newBlocks, changes, newBlockMap, removes, prev) {
        var lastBlock, next, oldNext, oldPrev;
        if (!oldBlocks.length && (first = this.getBlock(first))) {
          oldNext = this.getBlock(first.next);
          oldBlocks.unshift(first);
          first = newBlockMap[first._id] = copyBlock(first);
          link(first, newBlocks[0]);
          newBlocks.unshift(first);
          if (oldNext) {
            oldBlocks.push(oldNext);
            oldNext = newBlockMap[oldNext._id] = copyBlock(oldNext);
            link(last(newBlocks), oldNext);
            return newBlocks.push(oldNext);
          }
        } else if (oldBlocks.length !== newBlocks.length) {
          if (!prev && (prev = copyBlock(oldPrev = this.getBlock(oldBlocks[0].prev)))) {
            oldBlocks.unshift(oldPrev);
            newBlocks.unshift(prev);
            newBlockMap[prev._id] = prev;
          }
          lastBlock = last(oldBlocks);
          if (next = copyBlock(oldNext = this.getBlock((lastBlock ? lastBlock.next : this.getFirst())))) {
            oldBlocks.push(oldNext);
            newBlocks.push(next);
            newBlockMap[next._id] = next;
            if (!(next.prev = prev != null ? prev._id : void 0)) {
              changes.first = next._id;
            }
          }
          if (prev) {
            if (!first && ((newBlocks.length && !newBlocks[0].prev) || !oldBlocks.length || !this.getFirst() || removes[this.getFirst()])) {
              changes.first = newBlocks[0]._id;
            }
            return prev.next = next != null ? next._id : void 0;
          }
        }
      };

      DataStore.prototype.changesFor = function(first, oldBlocks, newBlocks) {
        var changes, newBlockMap, prev, removes;
        newBlockMap = {};
        removes = {};
        changes = {
          removes: removes,
          sets: newBlockMap,
          first: this.getFirst(),
          oldBlocks: oldBlocks,
          newBlocks: newBlocks
        };
        prev = this.computeRemovesAndNewBlockIds(oldBlocks, newBlocks, newBlockMap, removes);
        this.patchNewBlocks(first, oldBlocks, newBlocks, changes, newBlockMap, removes, prev);
        this.removeDuplicateChanges(newBlockMap);
        return changes;
      };

      DataStore.prototype.removeDuplicateChanges = function(newBlockMap) {
        var block, dups, id, oldBlock, results1;
        dups = [];
        for (id in newBlockMap) {
          block = newBlockMap[id];
          if ((oldBlock = this.getBlock(id)) && block.text === oldBlock.text && block.next === oldBlock.next && block.prev === oldBlock.prev) {
            dups.push(id);
          }
        }
        results1 = [];
        for (id in dups) {
          results1.push(delete newBlockMap[id]);
        }
        return results1;
      };

      DataStore.prototype.checkChanges = function() {
        if (this.changeCount === 0) {
          throw new Error("Attempt to make a change outside of makeChanges");
        }
      };

      DataStore.prototype.setIndex = function(i) {
        this.checkChanges();
        return this.blockIndex = i;
      };

      DataStore.prototype.getFirst = function() {
        return this.first;
      };

      DataStore.prototype.setFirst = function(firstId) {
        return this.first = firstId;
      };

      DataStore.prototype.getBlock = function(id) {
        return this.blocks[id];
      };

      DataStore.prototype.setBlock = function(id, block) {
        this.checkChanges();
        this.blocks[id] = block;
        return this.indexBlock(block);
      };

      DataStore.prototype.deleteBlock = function(id) {
        this.checkChanges();
        delete this.blocks[id];
        return this.unindexBlock(id);
      };

      DataStore.prototype.eachBlock = function(func) {
        var block;
        block = this.getBlock(this.getFirst());
        while (block && func(block, block._id) !== false) {
          block = this.getBlock(block.next);
        }
        return null;
      };

      DataStore.prototype.indexBlocks = function() {
        var items;
        this.checkChanges();
        items = [];
        this.eachBlock((function(_this) {
          return function(block) {
            return items.push(indexNode(block));
          };
        })(this));
        return this.setIndex(this.newBlockIndex(items));
      };

      DataStore.prototype.splitBlockIndexOnId = function(id) {
        return this.blockIndex.split(function(m) {
          return m.ids.contains(id);
        });
      };

      DataStore.prototype.splitBlockIndexOnOffset = function(offset) {
        return this.blockIndex.split(function(m) {
          return m.length > offset;
        });
      };

      DataStore.prototype.indexBlock = function(block) {
        var first, next, ref, rest, split;
        if (block) {
          this.checkChanges();
          ref = this.splitBlockIndexOnId(block._id), first = ref[0], rest = ref[1];
          if (!rest.isEmpty() && rest.peekFirst().id === block._id && (next = rest.removeFirst()) && (next.isEmpty() ? !block.next : next.peekFirst().id === block.next) && (first.isEmpty() ? !block.prev : first.peekLast().id === block.prev)) {
            return this.setIndex(first.addLast(indexNode(block)).concat(next));
          }
          if (!rest.isEmpty()) {
            this.unindexBlock(block._id);
          }
          if ((split = this.fingerNodeOrder(block.prev, block.next)) && _.isArray(split)) {
            first = split[0], rest = split[1];
            return this.setIndex(first.addLast(indexNode(block)).concat(rest));
          }
          return this.insertAndRepairIndex(block);
        }
      };

      DataStore.prototype.fingerNode = function(id) {
        var node;
        return id && (node = this.splitBlockIndexOnId(id)[1].peekFirst()) && node.id === id && node;
      };

      DataStore.prototype.fingerNodeOrder = function(a, b) {
        var first, ref, ref1, ref2, rest, split;
        return !(a || b) || (!a && b ? this.fingerNode(b) : !b && a ? this.fingerNode(a) : ((ref = split = this.splitBlockIndexOnId(b), first = ref[0], rest = ref[1], ref), !first.isEmpty() && !rest.isEmpty() && ((ref1 = rest.peekFirst()) != null ? ref1.id : void 0) === b && ((ref2 = first.peekLast()) != null ? ref2.id : void 0) === a && split));
      };

      DataStore.prototype.insertAndRepairIndex = function(block) {
        var cur, first, mark, node, prev, ref, ref1, ref2, ref3, rest, results1;
        console.warn("REPAIR");
        node = indexNode(block);
        if (block.next) {
          prev = this.getBlock(block.prev);
          if (!block.prev) {
            this.setIndex(this.blockIndex.addFirst(indexNode(block)));
          } else {
            ref = this.splitBlockIndexOnId(block.next), first = ref[0], rest = ref[1];
            this.setIndex(first.addLast(node).concat(rest));
          }
        } else if (block.prev) {
          ref1 = this.splitBlockIndexOnId(block.prev), first = ref1[0], rest = ref1[1];
          this.setIndex(first.addLast(node).concat(rest));
        } else {
          this.setIndex(this.newBlockIndex([node]));
        }
        mark = block;
        cur = this.getBlock(block.next);
        while (cur && !this.fingerNodeOrder(mark._id, cur._id)) {
          this.unindexBlock(cur._id);
          ref2 = this.splitBlockIndexOnId(mark._id), first = ref2[0], rest = ref2[1];
          this.setIndex(insertAfterSplit(first, indexNode(cur), rest));
          mark = cur;
          cur = this.getBlock(cur.next);
        }
        mark = block;
        cur = this.getBlock(block.prev);
        results1 = [];
        while (cur && !this.fingerNodeOrder(cur._id, mark._id)) {
          this.unindexBlock(cur._id);
          ref3 = this.splitBlockIndexOnId(mark._id), first = ref3[0], rest = ref3[1];
          this.setIndex(insertInSplit(first, indexNode(cur), rest));
          mark = cur;
          results1.push(cur = this.getBlock(cur.prev));
        }
        return results1;
      };

      DataStore.prototype.unindexBlock = function(id) {
        var first, ref, ref1, rest;
        this.checkChanges();
        if (id) {
          ref = this.splitBlockIndexOnId(id), first = ref[0], rest = ref[1];
          if (((ref1 = rest.peekFirst()) != null ? ref1.id : void 0) === id) {
            return this.setIndex(first.concat(rest.removeFirst()));
          }
        }
      };

      DataStore.prototype.docOffsetForBlockOffset = function(block, offset) {
        if (typeof block === 'object') {
          offset = block.offset;
          block = block.block;
        }
        return this.offsetForBlock(block) + offset;
      };

      DataStore.prototype.blockOffsetForDocOffset = function(offset) {
        var results;
        results = this.splitBlockIndexOnOffset(offset);
        if (!results[1].isEmpty()) {
          return {
            block: results[1].peekFirst().id,
            offset: offset - results[0].measure().length
          };
        } else {
          return {
            block: results[0].peekLast().id,
            offset: results[0].removeLast().measure().length
          };
        }
      };

      DataStore.prototype.offsetForBlock = function(blockOrId) {
        var id;
        id = typeof blockOrId === 'string' ? blockOrId : blockOrId._id;
        if (this.getBlock(id)) {
          return this.splitBlockIndexOnId(id)[0].measure().length;
        } else {
          return 0;
        }
      };

      DataStore.prototype.blockForOffset = function(offset) {
        var ref, ref1, results;
        results = this.splitBlockIndexOnOffset(offset);
        return ((ref = (ref1 = results[1]) != null ? ref1.peekFirst() : void 0) != null ? ref : results[0].peekLast).id;
      };

      DataStore.prototype.getDocLength = function() {
        return this.blockIndex.measure().length;
      };

      DataStore.prototype.getDocSubstring = function(start, end) {
        var block, endOffset, startOffset, text;
        startOffset = this.blockOffsetForDocOffset(start);
        endOffset = this.blockOffsetForDocOffset(end);
        block = this.getBlock(startOffset.block);
        text = '';
        while (block._id !== endOffset.block) {
          text += block.text;
          block = this.getBlock(block.next);
        }
        if (startOffset.block === endOffset.block) {
          return block.text.substring(startOffset.offset, endOffset.offset);
        } else {
          return text.substring(startOffset.offset) + block.text.substring(0, endOffset.offset);
        }
      };

      DataStore.prototype.getText = function() {
        var text;
        text = '';
        this.eachBlock(function(block) {
          return text += block.text;
        });
        return text;
      };

      DataStore.prototype.check = function() {
        var bl, first, lastBlock, next, oldBl, prev, seen;
        seen = {};
        first = next = this.getFirst();
        prev = null;
        while (next) {
          prev = next;
          if (seen[next]) {
            throw new Error("cycle in next links");
          }
          seen[next] = true;
          oldBl = bl;
          bl = this.getBlock(next);
          if (!bl) {
            throw new Error("Next of " + oldBl._id + " doesn't exist");
          }
          next = bl.next;
        }
        this.eachBlock(function(block) {
          if (block._id !== first && !seen[block._id]) {
            throw new Error(block._id + " not in next chain");
          }
        });
        seen = {};
        lastBlock = prev;
        while (prev) {
          if (seen[prev]) {
            throw new Error("cycle in prev links");
          }
          seen[prev] = true;
          oldBl = bl;
          bl = this.getBlock(prev);
          if (!bl) {
            throw new Error("Prev of " + oldBl._id + " doesn't exist");
          }
          prev = bl.prev;
        }
        this.eachBlock(function(block) {
          if (block._id !== lastBlock && !seen[block._id]) {
            throw new Error(block._id + " not in prev chain");
          }
        });
        return null;
      };

      DataStore.prototype.blockList = function() {
        var bl, next, results1;
        next = this.getFirst();
        results1 = [];
        while (next) {
          bl = this.getBlock(next);
          next = bl.next;
          results1.push(bl);
        }
        return results1;
      };

      DataStore.prototype.change = function(changes) {
        return this.trigger('change', this.makeChange(changes));
      };

      DataStore.prototype.makeChange = function(arg) {
        var first, newBlocks, oldBlocks, removes, sets;
        first = arg.first, sets = arg.sets, removes = arg.removes, oldBlocks = arg.oldBlocks, newBlocks = arg.newBlocks;
        return this.makeChanges((function(_this) {
          return function() {
            var adds, bl, block, err, error, id, old, ref, result, updates;
            ref = result = {
              adds: {},
              updates: {},
              removes: removes,
              old: {},
              sets: sets,
              oldFirst: _this.getFirst(),
              first: first,
              oldBlocks: oldBlocks,
              newBlocks: newBlocks
            }, adds = ref.adds, updates = ref.updates, old = ref.old;
            _this.setFirst(first);
            for (id in removes) {
              if (bl = _this.getBlock(id)) {
                old[id] = bl;
                _this.deleteBlock(id);
              }
            }
            for (id in sets) {
              block = sets[id];
              if (bl = _this.getBlock(id)) {
                old[id] = bl;
                updates[id] = block;
              } else {
                adds[id] = block;
              }
              _this.setBlock(id, block);
            }
            try {
              _this.check();
            } catch (error) {
              err = error;
              console.log(err);
            }
            return result;
          };
        })(this));
      };

      DataStore.prototype.indexArray = function() {
        return treeToArray(this.blockIndex);
      };

      DataStore.prototype.blockArray = function() {
        var block, blocks;
        blocks = [];
        block = this.getBlock(this.getFirst());
        while (block) {
          blocks.push(block);
          block = this.getBlock(block.next);
        }
        return blocks;
      };

      DataStore.prototype.diag = function() {
        return this.trigger('diag', this.verifyIndex());
      };

      DataStore.prototype.verifyIndex = function() {
        var bArray, blockIds, errs, iArray, j, last, len, node, offset, ref, treeIds;
        iArray = this.indexArray();
        treeIds = _.pluck(iArray, 'id');
        bArray = this.blockArray();
        blockIds = _.pluck(bArray, '_id');
        if (!_.isEqual(treeIds, blockIds)) {
          console.warn("INDEX ERROR:\nEXPECTED: " + (JSON.stringify(blockIds)) + "\nBUT GOT: " + (JSON.stringify(treeIds)));
        }
        last = null;
        errs = new BlockErrors();
        for (j = 0, len = iArray.length; j < len; j++) {
          node = iArray[j];
          if (node.length !== ((ref = this.getBlock(node.id)) != null ? ref.text.length : void 0)) {
            errs.badId(node.id, 'bad index length');
          }
        }
        offset = 0;
        this.eachBlock((function(_this) {
          return function(block) {
            last = block;
            if (!_this.fingerNodeOrder(block.prev, block._id)) {
              errs.badId(block._id, 'bad order');
              console.warn("NODE ORDER WRONG FOR " + block.prev + ", " + block._id);
            }
            if (offset !== _this.offsetForBlock(block._id)) {
              errs.badId(block._id, "offset");
            }
            if (block.prev && _this.blockForOffset(offset - 1) !== block.prev) {
              errs.badId(block._id, "prev");
            }
            if (block.next && _this.blockForOffset(offset + block.text.length) !== block.next) {
              errs.badId(block._id, "next");
            }
            return offset += block.text.length;
          };
        })(this));
        return errs.errors();
      };

      DataStore.prototype.blockOverlapsForReplacement = function(start, end, text) {
        var blocks, cur, endBlock, fullText, offset, startBlock;
        startBlock = this.blockForOffset(start);
        if (!startBlock && start) {
          startBlock = this.blockForOffset(start - 1);
        }
        endBlock = this.blockForOffset(end);
        if (!endBlock && end) {
          endBlock = this.blockForOffset(end - 1);
        }
        blocks = [this.getBlock(startBlock)];
        cur = startBlock;
        while (cur !== endBlock && cur.next) {
          block.push(cur = this.getBlock(cur.next));
        }
        fullText = blockText(blocks);
        offset = this.offsetForBlock(blocks[0]);
        return {
          blocks: blocks,
          blockText: fullText,
          newText: fullText.substring(0, start - offset) + text + (fullText.substring(end - offset))
        };
      };

      return DataStore;

    })(Observable);
    validateBatch = function(guardedReplacements) {
      var first, j, len, repl, repls;
      if (!guardedReplacements.length) {
        return guardedReplacements;
      } else {
        repls = _.sortBy(guardedReplacements, function(x) {
          return -x.gEnd;
        });
        first = repls[0].gEnd;
        for (j = 0, len = repls.length; j < len; j++) {
          repl = repls[j];
          if (first < repl.gEnd) {
            throw new Error("Attempt to perform overlapping replacements in batch");
          }
          first = repl.gStart;
        }
        return repls;
      }
    };
    BlockErrors = (function() {
      function BlockErrors() {
        this.order = [];
        this.ids = {};
      }

      BlockErrors.prototype.isEmpty = function() {
        return !this.order.length;
      };

      BlockErrors.prototype.badId = function(id, msg) {
        if (!this.ids[id]) {
          this.order.push(id);
          return this.ids[id] = msg;
        } else {
          return this.ids[id] += ", " + msg;
        }
      };

      BlockErrors.prototype.errors = function() {
        var id, j, len, ref, results1;
        if (!this.isEmpty()) {
          ref = this.order;
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            id = ref[j];
            results1.push([id, "(" + this.ids[id] + ")"]);
          }
          return results1;
        }
      };

      return BlockErrors;

    })();
    treeToArray = function(tree) {
      var nodes;
      nodes = [];
      while (!tree.isEmpty()) {
        nodes.push(tree.peekFirst());
        tree = tree.removeFirst();
      }
      return nodes;
    };
    indexNode = function(block) {
      return {
        id: block._id,
        length: block.text.length
      };
    };
    insertInSplit = function(first, middle, rest) {
      if (first.isEmpty()) {
        return rest.addFirst(middle);
      } else if (rest.isEmpty()) {
        return first.addLast(middle);
      } else {
        return first.addLast(middle).concat(rest);
      }
    };
    insertAfterSplit = function(first, afterMiddle, rest) {
      var next;
      next = rest.removeFirst().addFirst(afterMiddle);
      if (first.isEmpty()) {
        return next.addFirst(rest.peekFirst());
      } else {
        return first.addLast(rest.peekFirst()).concat(next);
      }
    };
    DataStoreEditingOptions = (function(superClass) {
      extend(DataStoreEditingOptions, superClass);

      function DataStoreEditingOptions(data) {
        this.data = data;
        DataStoreEditingOptions.__super__.constructor.call(this);
        this.callbacks = {};
        this.addDataCallbacks({
          change: (function(_this) {
            return function(changes) {
              return _this.dataChanged(changes);
            };
          })(this),
          load: (function(_this) {
            return function() {
              return _this.dataLoaded();
            };
          })(this)
        });
      }

      DataStoreEditingOptions.prototype.addDataCallbacks = function(cb) {
        var func, results1, type;
        results1 = [];
        for (type in cb) {
          func = cb[type];
          results1.push(this.data.on(type, this.callbacks[type] = func));
        }
        return results1;
      };

      DataStoreEditingOptions.prototype.dataChanged = function(changes) {
        return preserveSelection((function(_this) {
          return function() {
            return _this.changed(changes);
          };
        })(this));
      };

      DataStoreEditingOptions.prototype.dataLoaded = function() {
        return this.trigger('load');
      };

      DataStoreEditingOptions.prototype.cleanup = function() {
        return this.data.off(this.callbacks);
      };

      DataStoreEditingOptions.prototype.initData = function() {};

      DataStoreEditingOptions.prototype.load = function(name, text) {
        return this.data.load(name, text);
      };

      DataStoreEditingOptions.prototype.edit = function(prev, oldBlocks, newBlocks) {
        return this.replaceBlocks(prev, oldBlocks, newBlocks);
      };

      DataStoreEditingOptions.prototype.replaceText = function(repl) {
        return this.data.replaceText(repl);
      };

      DataStoreEditingOptions.prototype.getBlock = function(id) {
        return this.data.getBlock(id);
      };

      DataStoreEditingOptions.prototype.getFirst = function(first) {
        return this.data.getFirst();
      };

      DataStoreEditingOptions.prototype.change = function(changes) {
        if (changes) {
          return this.data.change(changes);
        }
      };

      DataStoreEditingOptions.prototype.changed = function(changes) {
        return this.rerenderAll();
      };

      return DataStoreEditingOptions;

    })(BasicEditingOptions);
    isEditable = function(n) {
      n = n.nodeType === n.TEXT_NODE ? n.parentNode : n;
      return n.isContentEditable;
    };
    link = function(prev, next) {
      prev.next = next._id;
      return next.prev = prev._id;
    };
    blockText = function(blocks) {
      var block;
      return ((function() {
        var j, len, results1;
        results1 = [];
        for (j = 0, len = blocks.length; j < len; j++) {
          block = blocks[j];
          results1.push(block.text);
        }
        return results1;
      })()).join('');
    };
    _to_ascii = {
      '188': '44',
      '109': '45',
      '190': '46',
      '191': '47',
      '192': '96',
      '220': '92',
      '222': '39',
      '221': '93',
      '219': '91',
      '173': '45',
      '187': '61',
      '186': '59',
      '189': '45'
    };
    shiftUps = {
      "96": "~",
      "49": "!",
      "50": "@",
      "51": "#",
      "52": "$",
      "53": "%",
      "54": "^",
      "55": "&",
      "56": "*",
      "57": "(",
      "48": ")",
      "45": "_",
      "61": "+",
      "91": "{",
      "93": "}",
      "92": "|",
      "59": ":",
      "39": "\"",
      "44": "<",
      "46": ">",
      "47": "?"
    };
    htmlForNode = function(n) {
      if (n.nodeType === n.TEXT_NODE) {
        return escapeHtml(n.data);
      } else {
        return n.outerHTML;
      }
    };
    getEventChar = function(e) {
      var c, shifton;
      if (e.originalEvent.type === 'keypress') {
        return String.fromCharCode(eventChar(e));
      } else {
        c = e.charCode || e.keyCode || e.which;
        shifton = e.shiftKey || !!(e.modifiers & 4);
        if (_to_ascii.hasOwnProperty(c)) {
          c = _to_ascii[c];
        }
        if (!shifton && (c >= 65 && c <= 90)) {
          c = String.fromCharCode(c + 32);
        } else if (e.shiftKey && shiftUps.hasOwnProperty(c)) {
          c = shiftUps[c];
        } else {
          c = String.fromCharCode(c);
        }
        return c;
      }
    };
    shiftKey = function(c) {
      return (15 < c && c < 19);
    };
    modifiers = function(e, c) {
      var res;
      res = specialKeys[c] || String.fromCharCode(c);
      if (e.altKey) {
        res = "M-" + res;
      }
      if (e.metaKey) {
        res = "M-" + res;
      }
      if (e.ctrlKey) {
        res = "C-" + res;
      }
      if (e.shiftKey) {
        res = "S-" + res;
      }
      return res;
    };
    modifyingKey = function(c, e) {
      return !e.altKey && !e.metaKey && !e.ctrlKey && (((47 < c && c < 58)) || c === 32 || c === ENTER || c === BS || c === DEL || ((64 < c && c < 91)) || ((95 < c && c < 112)) || ((185 < c && c < 193)) || ((218 < c && c < 223)));
    };
    last = function(array) {
      return array.length && array[array.length - 1];
    };
    posFor = function(pos) {
      var p, result;
      if (result = (pos.pos === pos.node.length && pos.node.data[pos.pos - 1] === '\n' && !(p = pos.save().next()).isEmpty() ? p : pos).textPosition()) {
        result.pos = p != null ? p : pos;
        return result;
      }
    };
    replacements = {
      '<': "&lt;",
      '>': "&gt;",
      '&': "&amp;"
    };
    escapeHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&]/g, function(c) {
          return replacements[c];
        });
      } else {
        return str;
      }
    };
    copy = function(obj) {
      var bl, k, v;
      if (obj) {
        bl = {};
        for (k in obj) {
          v = obj[k];
          bl[k] = v;
        }
        return bl;
      }
    };
    findEditor = function(node) {
      var ref, target;
      target = $(node);
      while (target.length && !($(target).data().editor instanceof LeisureEditCore)) {
        target = $(target).parent();
      }
      return (ref = target.data()) != null ? ref.editor : void 0;
    };
    preservingSelection = null;
    preserveSelection = function(func) {
      var editor;
      if (preservingSelection) {
        return func(preservingSelection);
      } else if (editor = findEditor(getSelection().anchorNode)) {
        preservingSelection = editor.getSelectedDocRange();
        try {
          return func(preservingSelection);
        } finally {
          editor.selectDocRange(preservingSelection);
          preservingSelection = null;
        }
      } else {
        return func({
          type: 'None',
          scrollTop: 0,
          scrollLeft: 0
        });
      }
    };
    wrapDiag = function(parent) {
      return function() {
        var args, r;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        r = parent.apply(this, args);
        this.diag();
        return r;
      };
    };
    return root = {
      LeisureEditCore: LeisureEditCore,
      Observable: Observable,
      BasicEditingOptions: BasicEditingOptions,
      DataStore: DataStore,
      DataStoreEditingOptions: DataStoreEditingOptions,
      defaultBindings: defaultBindings,
      last: last,
      link: link,
      blockText: blockText,
      posFor: posFor,
      escapeHtml: escapeHtml,
      copy: copy,
      findEditor: findEditor,
      copyBlock: copyBlock,
      preserveSelection: preserveSelection,
      treeToArray: treeToArray,
      computeNewStructure: computeNewStructure,
      validateBatch: validateBatch,
      getEventChar: getEventChar
    };
  });

}).call(this);

//# sourceMappingURL=editor.js.map
