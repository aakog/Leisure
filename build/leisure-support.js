// Generated by CoffeeScript 1.9.3
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['./base', './ast', './runtime', './gen', './eval'], function(Base, Ast, Runtime, Gen, Eval) {
    var Monad2, Nil, Node, _false, _identity, _true, _unit, acons, baseElements, baseStrokeWidth, cons, createNode, defaultEnv, define, evalLeisure, foldLeft, getMaxStrokeWidth, getSvgElement, getType, getValue, isNil, jsonConvert, lazy, lc, lz, makeHamt, makeSyncMonad, newConsFrom, none, primFoldLeft, primSvgMeasure, ref, resolve, root, runMods, runMonad, runMonad2, rz, setValue, some, svgBetterMeasure, svgMeasure, svgMeasureText, transformStrokeWidth, unescapePresentationHtml;
    ref = root = Ast, define = ref.define, getType = ref.getType, cons = ref.cons, unescapePresentationHtml = ref.unescapePresentationHtml, isNil = ref.isNil;
    Node = Base.Node, resolve = Base.resolve, lazy = Base.lazy, defaultEnv = Base.defaultEnv;
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    Nil = requirejs('./ast').Nil;
    runMonad = Runtime.runMonad, runMonad2 = Runtime.runMonad2, newConsFrom = Runtime.newConsFrom, setValue = Runtime.setValue, getValue = Runtime.getValue, makeSyncMonad = Runtime.makeSyncMonad, makeHamt = Runtime.makeHamt, _true = Runtime._true, _false = Runtime._false, _identity = Runtime._identity, _unit = Runtime._unit, jsonConvert = Runtime.jsonConvert, Monad2 = Runtime.Monad2, some = Runtime.some, none = Runtime.none, acons = Runtime.lacons;
    evalLeisure = Eval.evalLeisure;
    getSvgElement = function(id) {
      var el, svg;
      if ((el = document.getElementById(id))) {
        return el;
      } else {
        svg = createNode("<svg id='HIDDEN_SVG' xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000px; position: absolute'><text id='HIDDEN_TEXT'>bubba</text></svg>");
        document.body.appendChild(svg);
        return document.getElementById(id);
      }
    };
    svgMeasureText = function(text) {
      return function(style) {
        return function(f) {
          var bx, txt;
          txt = getSvgElement('HIDDEN_TEXT');
          if (rz(style)) {
            txt.setAttribute('style', rz(style));
          }
          txt.lastChild.textContent = rz(text);
          bx = txt.getBBox();
          return rz(f)(lz(bx.width))(lz(bx.height));
        };
      };
    };
    svgMeasure = function(content) {
      return primSvgMeasure(content, baseStrokeWidth);
    };
    svgBetterMeasure = function(content) {
      return primSvgMeasure(content, transformStrokeWidth);
    };
    primSvgMeasure = function(content, transformFunc) {
      return function(f) {
        var bbox, g, pad, svg;
        svg = createNode("<svg xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000'><g>" + content + "</g></svg>");
        document.body.appendChild(svg);
        g = svg.firstChild;
        bbox = g.getBBox();
        pad = getMaxStrokeWidth(g, g, svg, transformFunc);
        document.body.removeChild(svg);
        return rz(f)(lz(bbox.x - Math.ceil(pad / 2)))(lz(bbox.y - Math.ceil(pad / 2)))(lz(bbox.width + pad))(lz(bbox.height + pad));
      };
    };
    baseElements = ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon'];
    foldLeft = function(func, val, thing) {
      if (thing instanceof Leisure_cons) {
        return thing.foldl(func, val);
      } else {
        return primFoldLeft(func, val, thing, 0);
      }
    };
    primFoldLeft = function(func, val, array, index) {
      if (index < array.length) {
        return primFoldLeft(func, func(val, array[index]), array, index + 1);
      } else {
        return val;
      }
    };
    getMaxStrokeWidth = function(el, base, svg, transformFunc) {
      var ref1, ref2;
      if (ref1 = base.nodeName, indexOf.call(baseElements, ref1) >= 0) {
        svg.setAttribute('width', (ref2 = getComputedStyle(base).strokeWidth) != null ? ref2 : '0', svg);
        return transformFunc(el, svg.width.baseVal.value);
      } else if (base.nodeName === 'use') {
        return getMaxStrokeWidth(base, base.instanceRoot.correspondingElement, svg, transformFunc);
      } else if (base.nodeName === 'g') {
        return foldLeft((function(v, n) {
          return Math.max(v, getMaxStrokeWidth(n, n, svg, transformFunc));
        }), 0, el.childNodes);
      } else {
        return 0;
      }
    };
    baseStrokeWidth = function(el, w) {
      return w;
    };
    transformStrokeWidth = function(el, w) {
      var ctm, tp1, tp2, x, y;
      if (w === 0) {
        return 0;
      } else {
        ctm = el.getScreenCTM();
        tp1 = transformedPoint(pt, bx.x - Math.ceil(w), bx.y - Math.ceil(w), ctm, isctm);
        tp2 = transformedPoint(pt, bx.x + bx.width + Math.ceil(w), bx.y + bx.height + Math.ceil(w), ctm, isctm);
        x = tp2.x - tp1.x;
        y = tp2.y - tp1.y;
        return Math.sqrt(x * x + y * y);
      }
    };
    createNode = function(txt) {
      var scratch;
      scratch = document.createElement('DIV');
      scratch.innerHTML = txt;
      return scratch.firstChild;
    };
    define('svgMeasure', (function(content) {
      return svgMeasure(rz(content));
    }), 1);
    define('svgMeasureText', (function(text) {
      return svgMeasureText(rz(text));
    }), 1);
    define('dataMod', setDataType((function(op) {
      var m;
      m = new Monad2(function(env, cont) {
        var data;
        data = {};
        return runMods(env, rz(op), data, cont, true);
      });
      m.op = op;
      m.leisureType = 'dataMod';
      return m;
    }), 'dataMod'));
    define('dataModOperation', function(mod) {
      return rz((rz(mod)).op);
    });
    define('setTheme', function(theme) {
      return new Monad2(function(env, cont) {
        env.opts.setTheme(theme);
        return cont(_unit);
      });
    });
    define('changeData', function(changes) {
      return new Monad2(function(env, cont) {
        var ch, data;
        ch = rz(changes);
        if (getType(ch) !== 'dataMod') {
          throw new Error("Attempt data change with value that is not a dataMod");
        }
        data = {};
        return env.opts.changeData(function() {
          return runMods(env, rz(ch.op), data, function() {
            return cont(jsonConvert(data));
          });
        });
      });
    });
    runMods = function(env, mod, data, cont, noChanges) {
      var d, first, firstRes, name, ref1, result, second, secondRes, value;
      if (noChanges && !((ref1 = getType(mod)) === 'dataModBind' || ref1 === 'dataModGet')) {
        throw new Error("Attempt to alter data outside a changeData command");
      }
      switch (getType(mod)) {
        case 'dataModBind':
          while (getType(mod) === 'dataModBind') {
            first = second = firstRes = secondRes = false;
            result = runMods(env, mod(_true), data, (function(res) {
              return mod = (mod(_false))(lz(res));
            }), noChanges);
          }
          if (getType(mod) === 'dataMod') {
            return runMods(env, rz(mod.op), data, cont, noChanges);
          } else {
            return cont(mod);
          }
          break;
        case 'dataModGet':
          name = mod(_identity);
          d = env.opts.getData(name, noChanges);
          if (d) {
            return cont(some(jsonConvert(data[name] = d)));
          } else {
            return cont(none);
          }
          break;
        case 'dataModSet':
          name = mod(_true);
          value = mod(_false);
          data[name] = value;
          return cont(jsonConvert(env.opts.setData(name, value)));
        case 'dataModAppend':
          return mod(function(headline) {
            return function(name) {
              return function(value) {
                env.opts.appendDataToHeadline(rz(headline), rz(name), rz(value));
                return cont(jsonConvert(data[rz(name)] = rz(value)));
              };
            };
          });
        case 'dataModAppendWithAttrs':
          return mod(function(headline) {
            return function(name) {
              return function(attrs) {
                return function(value) {
                  env.opts.appendDataToHeadline(rz(headline), !isNil(name) && name, rz(value), rz(attrs));
                  return cont(jsonConvert(data[rz(name)] = rz(value)));
                };
              };
            };
          });
        case 'dataModRemove':
          name = mod(_identity);
          delete data[name];
          env.opts.removeData(name);
          return cont(name);
      }
    };
    return evalLeisure("dataModGet name = \\f . f name\ngetData name = dataMod (dataModGet name)\ndefCase showBase.dataModGet func cmd | hasType cmd dataModGet ->\n  cmd \\name . concatFlat[\"(getData \" (showBase func name) \")\"]\n\ndataModSet name value = \\f . f name value\n_setData name value = dataMod (dataModSet name value)\nsetData name value = _setData name (toJson value)\ndefCase showBase.dataModSet func cmd | hasType cmd dataModSet -> cmd \\name value . concatFlat[\"(setData \" (map (showBase func) [name (fromJson value)]) \")\"]\n\ndataModRemove name = \\f . f name\nremoveData name = dataMod (dataModRemove name)\ndefCase showBase.dataModRemove func cmd | hasType cmd dataModRemove -> cmd \\name . concatFlat[\"(removeData \" (map (showBase func) name) \")\"]\n\ndataModAppend headline name value = \\f . f headline name value\ndefCase showBase.dataModAppend func cmd | hasType cmd dataModAppend -> cmd \\headline name value . concatFlat[\"(append \" (map (showBase func) [headline name value]) \")\"]\n_appendData headline name data = dataMod (dataModAppend headline name data)\nappendData headline name data = _appendData headline name (toJson data)\n\ndataModAppendWithAttrs headline name attrs data = \\f . f headline name attrs data\ndefCase showBase.dataModAppendWithAttrs func cmd | hasType cmd dataModAppendWithAttrs -> cmd \\headline name attrs data . concatFlat[\"(appendWithAttrs \" (map (showBase func) [headline name attrs data]) \")\"]\n_appendWithAttrs headline name attrs data = dataMod (dataModAppendWithAttrs headline name attrs data)\nappendWithAttrs headline name attrs data =\n  _appendWithAttrs headline name attrs (toJson data)\n\ndataModBind item cont = \\f . f item cont\ndefCase bind.dataMod mod cont | hasType mod dataMod ->\n  dataMod (dataModBind (dataModOperation mod) cont)\nisDataModBind m = getProperty m 'dataModType' (\\x . x == 'dataModBind') false\nextractDataModBind b = isDataModBind b\n  (dataModBindInfo b) \\mod cont . [mod | (extractDataModBind (cont nil))]\n  [b]\ndefCase showBase.dataModBind func mod | hasType mod dataModBind ->\n  concatFlat[\"(do \" (intersperse (map (showBase func) (extractDataModBind mod)) ' ') \")\"]\n\ndefCase showBase.dataMod func mod | hasType mod dataMod ->\n  showBase func (dataModOperation mod)");
  });

}).call(this);

//# sourceMappingURL=leisure-support.js.map
