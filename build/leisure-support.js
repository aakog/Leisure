// Generated by CoffeeScript 1.9.3
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  define(['./base', './ast', './runtime', './gen', './eval'], function(Base, Ast, Runtime, Gen, Eval) {
    var Monad2, Nil, Node, _false, _identity, _true, acons, baseElements, baseStrokeWidth, cons, createNode, defaultEnv, define, evalLeisure, foldLeft, getMaxStrokeWidth, getMod, getSvgElement, getType, getValue, isNil, jsonConvert, lazy, lc, lz, makeHamt, makeSyncMonad, newConsFrom, none, primFoldLeft, primSvgMeasure, ref, resolve, root, runMods, runMonad, runMonad2, rz, setValue, some, svgBetterMeasure, svgMeasure, svgMeasureText, transformStrokeWidth, unescapePresentationHtml;
    ref = root = Ast, define = ref.define, getType = ref.getType, cons = ref.cons, unescapePresentationHtml = ref.unescapePresentationHtml, isNil = ref.isNil;
    Node = Base.Node, resolve = Base.resolve, lazy = Base.lazy, defaultEnv = Base.defaultEnv;
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    Nil = requirejs('./ast').Nil;
    runMonad = Runtime.runMonad, runMonad2 = Runtime.runMonad2, newConsFrom = Runtime.newConsFrom, setValue = Runtime.setValue, getValue = Runtime.getValue, makeSyncMonad = Runtime.makeSyncMonad, makeHamt = Runtime.makeHamt, _true = Runtime._true, _false = Runtime._false, _identity = Runtime._identity, jsonConvert = Runtime.jsonConvert, Monad2 = Runtime.Monad2, some = Runtime.some, none = Runtime.none, acons = Runtime.lacons;
    evalLeisure = Eval.evalLeisure;
    getSvgElement = function(id) {
      var el, svg;
      if ((el = document.getElementById(id))) {
        return el;
      } else {
        svg = createNode("<svg id='HIDDEN_SVG' xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000px; position: absolute'><text id='HIDDEN_TEXT'>bubba</text></svg>");
        document.body.appendChild(svg);
        return document.getElementById(id);
      }
    };
    svgMeasureText = function(text) {
      return function(style) {
        return function(f) {
          var bx, txt;
          txt = getSvgElement('HIDDEN_TEXT');
          if (rz(style)) {
            txt.setAttribute('style', rz(style));
          }
          txt.lastChild.textContent = rz(text);
          bx = txt.getBBox();
          return rz(f)(lz(bx.width))(lz(bx.height));
        };
      };
    };
    svgMeasure = function(content) {
      return primSvgMeasure(content, baseStrokeWidth);
    };
    svgBetterMeasure = function(content) {
      return primSvgMeasure(content, transformStrokeWidth);
    };
    primSvgMeasure = function(content, transformFunc) {
      return function(f) {
        var bbox, g, pad, svg;
        svg = createNode("<svg xmlns='http://www.w3.org/2000/svg' version='1.1' style='top: -100000'><g>" + content + "</g></svg>");
        document.body.appendChild(svg);
        g = svg.firstChild;
        bbox = g.getBBox();
        pad = getMaxStrokeWidth(g, g, svg, transformFunc);
        document.body.removeChild(svg);
        return rz(f)(lz(bbox.x - Math.ceil(pad / 2)))(lz(bbox.y - Math.ceil(pad / 2)))(lz(bbox.width + pad))(lz(bbox.height + pad));
      };
    };
    baseElements = ['path', 'rect', 'circle', 'ellipse', 'line', 'polyline', 'polygon'];
    foldLeft = function(func, val, thing) {
      if (thing instanceof Leisure_cons) {
        return thing.foldl(func, val);
      } else {
        return primFoldLeft(func, val, thing, 0);
      }
    };
    primFoldLeft = function(func, val, array, index) {
      if (index < array.length) {
        return primFoldLeft(func, func(val, array[index]), array, index + 1);
      } else {
        return val;
      }
    };
    getMaxStrokeWidth = function(el, base, svg, transformFunc) {
      var ref1, ref2;
      if (ref1 = base.nodeName, indexOf.call(baseElements, ref1) >= 0) {
        svg.setAttribute('width', (ref2 = getComputedStyle(base).strokeWidth) != null ? ref2 : '0', svg);
        return transformFunc(el, svg.width.baseVal.value);
      } else if (base.nodeName === 'use') {
        return getMaxStrokeWidth(base, base.instanceRoot.correspondingElement, svg, transformFunc);
      } else if (base.nodeName === 'g') {
        return foldLeft((function(v, n) {
          return Math.max(v, getMaxStrokeWidth(n, n, svg, transformFunc));
        }), 0, el.childNodes);
      } else {
        return 0;
      }
    };
    baseStrokeWidth = function(el, w) {
      return w;
    };
    transformStrokeWidth = function(el, w) {
      var ctm, tp1, tp2, x, y;
      if (w === 0) {
        return 0;
      } else {
        ctm = el.getScreenCTM();
        tp1 = transformedPoint(pt, bx.x - Math.ceil(w), bx.y - Math.ceil(w), ctm, isctm);
        tp2 = transformedPoint(pt, bx.x + bx.width + Math.ceil(w), bx.y + bx.height + Math.ceil(w), ctm, isctm);
        x = tp2.x - tp1.x;
        y = tp2.y - tp1.y;
        return Math.sqrt(x * x + y * y);
      }
    };
    createNode = function(txt) {
      var scratch;
      scratch = document.createElement('DIV');
      scratch.innerHTML = txt;
      return scratch.firstChild;
    };
    define('svgMeasure', (function(content) {
      return svgMeasure(rz(content));
    }), 1);
    define('svgMeasureText', (function(text) {
      return svgMeasureText(rz(text));
    }), 1);
    define('getData', function(name) {
      var m;
      m = new Monad2(function(env, cont) {
        var data, ref1;
        data = (ref1 = env.opts.data.getBlockNamed(rz(name))) != null ? ref1.yaml : void 0;
        return cont(data ? some(jsonConvert(data)) : none);
      });
      m.properties = acons('getName', rz(name), Nil);
      m.name = name;
      m.leisureType = 'dataMod';
      return m;
    });
    define('setTheme', function(theme) {
      return new Monad2(function(env, cont) {
        env.opts.setTheme(theme);
        return cont();
      });
    });
    define('changeData', function(changes) {
      return new Monad2(function(env, cont) {
        var ch, data;
        ch = rz(changes);
        ch = ch instanceof Monad2 ? ch : ch(_identity);
        data = {};
        return env.opts.changeData(function() {
          return runMods(env, ch, data, function() {
            return cont(jsonConvert(data));
          });
        });
      });
    });
    getMod = function(dataMod) {
      if (dataMod instanceof Monad2) {
        return dataMod;
      } else {
        return dataMod(_identity);
      }
    };
    runMods = function(env, mod, data, cont) {
      var first, firstRes, name, result, second, secondRes, sync, type, value;
      type = mod instanceof Monad2 ? 'dataModGet' : getType(mod);
      switch (type) {
        case 'dataModBind':
          sync = true;
          first = second = firstRes = secondRes = false;
          result = runMods(env, mod(_true), data, function(res) {
            if (sync) {
              first = true;
              return firstRes = res;
            } else {
              return runMods(env, getMod((mod(_false))(lz(res))), data, cont);
            }
          });
          if (first) {
            runMods(env, getMod(mod(_false)(lz(firstRes))), data, function(res2) {
              if (sync) {
                second = true;
                return secondRes = res2;
              } else {
                return cont(res2);
              }
            });
          }
          sync = false;
          if (second) {
            return cont(secondRes);
          } else {
            return result;
          }
        case 'dataModGet':
          name = mod instanceof Monad2 ? rz(mod.name) : mod(_identity);
          return cont(jsonConvert(data[name] = env.opts.getData(name)));
        case 'dataModSet':
          name = mod(_true);
          value = mod(_false);
          data[name] = value;
          return cont(jsonConvert(env.opts.setData(name, value)));
        case 'dataModAppend':
          return mod(function(headline) {
            return function(name) {
              return function(value) {
                env.opts.appendDataToHeadline(rz(headline), rz(name), rz(value));
                return cont(jsonConvert(data[rz(name)] = rz(value)));
              };
            };
          });
        case 'dataModAppendWithAttrs':
          return mod(function(headline) {
            return function(name) {
              return function(attrs) {
                return function(value) {
                  env.opts.appendDataToHeadline(rz(headline), !isNil(name) && name, rz(value), rz(attrs));
                  return cont(jsonConvert(data[rz(name)] = rz(value)));
                };
              };
            };
          });
        case 'dataModRemove':
          name = mod(_identity);
          delete data[name];
          env.opts.removeData(name);
          return cont(name);
      }
    };
    return evalLeisure("dataMod item = \\f . f item\ngetDataModCmd mod = (getProperty mod 'getName') (\\x . mod) (mod id)\ndefCase showBase.dataMod func mod | hasType mod dataMod ->\n  (getProperty mod 'getName')\n    \\name . concat[\"(getData \" (showBase func name) \")\"]\n    mod \\cmd . showBase func cmd\n\ndataModSet name value = \\f . f name value\n_setData name value = dataMod (dataModSet name value)\nsetData name value = _setData name (toJson value)\ndefCase showBase.dataModSet func cmd | hasType cmd dataModSet -> cmd \\name value . concatFlat[\"(setData \" (map (showBase func) [name (fromJson value)]) \")\"]\n\ndataModRemove name = \\f . f name\nremoveData name = dataMod (dataModRemove name)\ndefCase showBase.dataModRemove func cmd | hasType cmd dataModRemove -> cmd \\name . concatFlat[\"(removeData \" (map (showBase func) name) \")\"]\n\ndataModAppend headline name value = \\f . f headline name value\ndefCase showBase.dataModAppend func cmd | hasType cmd dataModAppend -> cmd \\headline name value . concatFlat[\"(append \" (map (showBase func) [headline name value]) \")\"]\n_appendData headline name data = dataMod (dataModAppend headline name data)\nappendData headline name data = _appendData headline name (toJson data)\n\ndataModAppendWithAttrs headline name attrs data = \\f . f headline name attrs data\ndefCase showBase.dataModAppendWithAttrs func cmd | hasType cmd dataModAppendWithAttrs -> cmd \\headline name attrs data . concatFlat[\"(appendWithAttrs \" (map (showBase func) [headline name attrs data]) \")\"]\n_appendWithAttrs headline name attrs data = dataMod (dataModAppendWithAttrs headline name attrs data)\nappendWithAttrs headline name attrs data =\n  _appendWithAttrs headline name attrs (toJson data)\n\ndataModBind item cont = \\f . f item cont\ndefCase bind.dataMod mod cont | hasType mod dataMod ->\n  dataMod (dataModBind (getDataModCmd mod) cont)\ndefCase showBase.dataModBind func cmd | hasType cmd dataModBind ->\n  concatFlat[\"(do \" (intersperse (map (showBase func) (extractDataModBind cmd)) ' ') \")\"]\nextractDataModBind b = hasType b dataModBind\n  b \\mod cont . [mod | (extractDataModBind (cont nil))]\n  [b]");
  });

}).call(this);

//# sourceMappingURL=leisure-support.js.map
