// Generated by CoffeeScript 2.4.1
(function() {
  // SockJS relay server
  var MasterHandler, MessageHandler, SlaveHandler, _, badMasterIdError, badMsgTypeError, badVersionError, crypto, diag, disapprovedError, finalhandler, guid, http, isTextMsg, masters, noTrim, path, requirejs, runReplacements, s4, serveStatic, slaves, socketPrefix, sockjs, sockjsUtil, startServer, validateBatch;

  require('source-map-support').install();

  sockjs = require('sockjs');

  sockjsUtil = require('sockjs/lib/utils');

  http = require('http');

  crypto = require('crypto');

  serveStatic = require('serve-static');

  finalhandler = require('finalhandler');

  path = require('path');

  _ = require('./lib/lodash.min');

  requirejs = require('requirejs').config({
    baseUrl: path.dirname(module.filename),
    paths: {
      immutable: 'lib/immutable-3.7.4.min'
    }
  });

  ({badMasterIdError, badMsgTypeError, disapprovedError, badVersionError, noTrim} = requirejs('./common'));

  ({runReplacements} = requirejs('./ot'));

  masters = {};

  slaves = {};

  socketPrefix = '/Leisure/(master|slave(?:-([^/]*)))';

  // Thanks to [Broofa's stackoverflow post](http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript/105074#105074) Altered the code to use crypto's random.
  s4 = function() {
    var bytes, n;
    bytes = crypto.randomBytes(2);
    n = (bytes[0] + (bytes[1] << 8)).toString(16);
    while (n.length < 4) {
      n = '0' + n;
    }
    return n;
  };

  guid = function() {
    return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
  };

  diag = function(...args) {
    return console.log(...args);
  };

  MessageHandler = (function() {
    class MessageHandler {
      constructor() {
        this.id = guid();
        this.messageCount = 1;
        this.lastVersionAck = -1;
      }

      setConnection(con1) {
        this.con = con1;
        console.log(`${this.type} connection: ${this.id}`);
        this.con.leisure = this;
        this.con.on('data', (msg) => {
          return this.handleMessage(JSON.parse(msg));
        });
        return this.con.on('close', () => {
          return this.closed();
        });
      }

      close() {
        return this.con.close();
      }

      closed() {
        return console.log(`${this.type} closed: ${this.id}`);
      }

      send(msg) {
        //diag "S    #{JSON.stringify msg}"
        return this.con.write(JSON.stringify(msg));
      }

      sendError(msg) {
        msg.type = 'error';
        this.send(msg);
        return setTimeout((() => {
          return this.close();
        }), 1);
      }

      // Handle a message from the connected browser
      handleMessage(msg) {
        msg.connectionId = this.connectionId;
        if (!(msg.type in this.handler)) {
          console.log(`Received bad message ${msg.type}`, msg);
          return this.close();
        } else {
          return this.handler[msg.type].call(this, msg);
        }
      }

      shouldEcho(msg) {
        return isTextMsg(msg) && msg.connectionId === this.connectionId;
      }

    };

    MessageHandler.prototype.type = 'Unknown Handler';

    MessageHandler.prototype.handler = {
      log: function(msg) {
        return console.log(msg.msg);
      },
      replace: function(msg) {
        this.lastVersionAck = msg.parent;
        return this.master.relay(msg);
      },
      conditionalReplace: function(msg) {
        if (msg.version !== this.master.version && this.master.versionDirty) {
          return this.send({
            type: 'rejectChange',
            targetVersion: msg.targetVersion,
            version: this.version
          });
        } else {
          return this.master.relay(msg);
        }
      },
      ack: function(msg) {
        this.lastVersionAck = msg.version;
        return this.master.peerAcknowledgedVersion(msg);
      }
    };

    return MessageHandler;

  }).call(this);

  isTextMsg = function(msg) {
    var ref;
    return (ref = msg.type) === 'replace' || ref === 'conditionalReplace';
  };

  validateBatch = function(replacements) {
    var i, last, len, repl;
    replacements = _.sortBy(replacements, function(x) {
      return x.start;
    });
    last = 0;
    for (i = 0, len = replacements.length; i < len; i++) {
      repl = replacements[i];
      if (repl.start < last) {
        throw new Error("Attempt to perform overlapping replacements in batch");
      }
      last = repl.end;
    }
    return replacements;
  };

  MasterHandler = (function() {
    class MasterHandler extends MessageHandler {
      constructor() {
        super();
        this.master = this;
        this.connectionId = "peer-0";
        this.slaves = {};
        this.pendingSlaves = {};
        this.doc = '';
        this.peerCount = 0;
        this.version = 0;
        this.nextVersionCallbacks = [];
        this.pendingVersionAcks = {};
        this.remainingVersionAcks = 0;
        this.versionDirty = false;
        this.versionOps = [];
        this.unreplacements = [];
        this.ackedVersion = -1;
      }

      setConnection(con) {
        masters[this.id] = this;
        super.setConnection(con);
        return this.send({
          type: 'connect',
          id: this.id,
          connectionId: this.connectionId,
          version: this.messageCount
        });
      }

      addSlave(slave) {
        slave.connectionId = `peer-${++this.peerCount}`;
        this.pendingSlaves[slave.connectionId] = slave;
        return this.send({
          type: 'slaveConnect',
          slaveId: slave.connectionId
        });
      }

      removeSlave(slave) {
        delete this.slaves[slave.connectionId];
        delete this.pendingSlaves[slave.connectionId];
        this.send({
          type: 'slaveDisconnect',
          slaveId: slave.connectionId
        });
        return this.broadcast({
          type: 'connections',
          count: 1 + _.size(this.slaves)
        });
      }

      closed() {
        var id, ref, slave;
        delete masters[this.con.leisure.id];
        ref = this.slaves;
        for (id in ref) {
          slave = ref[id];
          slave.close();
        }
        this.slaves = {};
        return super.closed();
      }

      versionClean() {
        return !this.versionDirty && !this.remainingVersionAcks;
      }

      startVersionInc() {
        if (this.versionDirty && !this.remainingVersionAcks) {
          this.pendingVersionAcks = _.clone(slaves);
          this.pendingVersionAcks[this.connectionId] = this;
          this.remainingVersionAcks = _.size(this.pendingVersionAcks);
          return this.broadcast({
            type: 'newVersion',
            version: this.version + 1
          });
        }
      }

      peerAcknowledgedVersion(msg) {
        //diag "RECEIVED VERSION ACK"
        return this.trimVersions();
      }

      connection(msg) {
        if (msg.connectionId === this.connectionId) {
          return this;
        } else {
          return this.slaves[msg.connectionId];
        }
      }

      relay(msg) {
        var end, i, len, offset, ref, repl, start, text;
        if (msg.type === 'replace') {
          ({start, end, text} = msg);
          this.versionOps.push(msg);
          this.trimVersions();
        } else if (msg.type === 'conditionalReplace') {
          msg.replacements = validateBatch(msg.replacements);
          offset = 0;
          ref = msg.replacements;
          for (i = 0, len = ref.length; i < len; i++) {
            repl = ref[i];
            this.doc = this.doc.substring(0, repl.start + offset) + repl.text + this.doc.substring(repl.end + offset);
            offset += repl.text.length - repl.end + repl.start;
          }
        }
        return this.broadcast(msg);
      }

      trimVersions() {
        var i, id, len, minVersion, op, pos, ref, ref1, results, slave;
        if (noTrim) {
          return;
        }
        minVersion = this.lastVersionAck;
        ref = this.slaves;
        for (id in ref) {
          slave = ref[id];
          minVersion = Math.min(minVersion, slave.lastVersionAck);
        }
        ref1 = this.versionOps;
        results = [];
        for (pos = i = 0, len = ref1.length; i < len; pos = ++i) {
          op = ref1[pos];
          if (op.version >= minVersion) {
            if (pos > 0) {
              this.updateDoc(this.versionOps.slice(0, pos));
              this.unreplacements = [];
              this.versionOps = this.versionOps.slice(pos);
              this.updateDoc();
              this.broadcast({
                type: 'trimVersions',
                version: minVersion
              });
            }
            break;
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

      replace(start, end, text) {
        return this.doc = this.doc.substring(0, start) + text + this.doc.substring(end);
      }

      updateDoc(changes) {
        var i, ref, repl;
        ref = this.unreplacements;
        for (i = ref.length - 1; i >= 0; i += -1) {
          repl = ref[i];
          this.replace(repl.start, repl.end, repl.text);
        }
        this.unreplacements = [];
        return runReplacements(changes || this.versionOps, (start, end, text) => {
          this.unreplacements.push({
            start: start,
            end: start + text.length,
            text: this.doc.substring(start, end)
          });
          return this.replace(start, end, text);
        });
      }

      sendEchoIfNeeded(msg) {
        var con;
        if (isTextMsg(msg) && (con = this.connection(msg))) {
          con.send({
            type: 'echo',
            version: msg.version
          });
          return con;
        }
      }

      broadcast(msg) {
        var echoer, id, ref, results, slave;
        msg.version = ++this.messageCount;
        if ((echoer = this.sendEchoIfNeeded(msg)) !== this) {
          this.send(msg);
        }
        ref = this.slaves;
        results = [];
        for (id in ref) {
          slave = ref[id];
          if (echoer !== slave) {
            results.push(slave.send(msg));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

    };

    MasterHandler.prototype.type = 'Master';

    MasterHandler.prototype.handler = {
      __proto__: MessageHandler.prototype.handler,
      initDoc: function({doc}) {
        this.doc = doc;
      },
      slaveApproval: function({slaveId, approval}) {
        var slave;
        if (slave = this.pendingSlaves[slaveId]) {
          delete this.pendingSlaves[slaveId];
          if (approval) {
            this.slaves[slaveId] = slave;
            slave.send({
              type: 'connect',
              id: this.id,
              connectionId: slave.connectionId,
              doc: this.doc,
              version: this.messageCount
            });
            return this.broadcast({
              type: 'connections',
              count: 1 + _.size(this.slaves)
            });
          } else {
            return slave.sendError(disapprovedError());
          }
        }
      }
    };

    return MasterHandler;

  }).call(this);

  SlaveHandler = (function() {
    class SlaveHandler extends MessageHandler {
      setConnection(con, masterId) {
        if (!(this.master = masters[masterId])) {
          this.sendError(badMasterIdError(masterId));
        } else {
          this.master.addSlave(this);
        }
        return super.setConnection(con);
      }

      setId(id1) {
        this.id = id1;
      }

      closed() {
        this.master.removeSlave(this);
        return super.closed();
      }

    };

    SlaveHandler.prototype.type = 'Slave';

    return SlaveHandler;

  }).call(this);

  startServer = function(port) {
    var fileServer, http_server;
    console.log('serve: ' + path.dirname(process.cwd()));
    fileServer = serveStatic(path.dirname(process.cwd()), {
      index: ['index.html']
    });
    http_server = http.createServer(function(req, res) {
      return fileServer(req, res, finalhandler(req, res));
    });
    sockjs.createServer({
      sockjs_url: 'http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js',
      prefix: socketPrefix
    }).on('connection', function(con) {
      var ignore, masterId, type;
      [ignore, type, masterId] = con.pathname.match(socketPrefix);
      if (type === 'master') {
        return new MasterHandler().setConnection(con);
      } else {
        return new SlaveHandler().setConnection(con, masterId);
      }
    }).installHandlers(http_server);
    return http_server.listen(port, '0.0.0.0');
  };

  module.exports = {startServer, guid};

}).call(this);

//# sourceMappingURL=server.js.map
