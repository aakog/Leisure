// Generated by CoffeeScript 2.2.4
(function() {
  // * TODO and agenda code for Leisure
  'use strict';
  define(['./org', './docOrg', './editor', './editorSupport', 'lodash', 'jquery'], function(Org, DocOrg, Editor, EditorSupport, _, $) {
    var Todo, computeNewStructure, parseOrgMode, stdTodo, todoForEditor;
    ({parseOrgMode} = Org);
    ({computeNewStructure} = Editor);
    Todo = class Todo {
      constructor(data, inputStates) {
        var i, len, prev, ref, state, todoPat;
        this.data = data;
        inputStates = inputStates || stdTodo;
        this.states = {};
        todoPat = '';
        prev = null;
        ref = inputStates.todo.concat(inputStates.done);
        for (i = 0, len = ref.length; i < len; i++) {
          state = ref[i];
          state.name = state.name.toUpperCase();
          this.states[state.name] = state;
          if (prev) {
            state.prev = prev;
            prev.next = state;
          }
          prev = state;
          todoPat += `\\b${state.name}\\b|`;
        }
        this.startState = inputStates.todo[0] || inputStates.done[0];
        if (prev) {
          this.endState = prev;
        }
        //  @startState.prev = prev
        //  prev.next = @startState
        this.statePat = new RegExp(`^(\\*+)( +(${todoPat}) *)`, 'i');
      }

      shiftRight(docPos, block) {
        block = this.data.getBlock(block || this.data.blockForOffset(docPos));
        if (block.type === 'headline') {
          this.cycleTodo(block, true);
          return true;
        }
      }

      shiftLeft(docPos, block) {
        block = this.data.getBlock(block || this.data.blockForOffset(docPos));
        if (block.type === 'headline') {
          this.cycleTodo(block, false);
          return true;
        }
      }

      // Cycle the todo state for a headline
      cycleTodo(block, forward) {
        var m, newText, next, ref, ref1, ref2, ref3, start, state;
        if (m = block.text.match(this.statePat)) {
          state = m[2].trim();
          next = state ? forward ? ((ref = this.states[state.toUpperCase()]) != null ? (ref1 = ref.next) != null ? ref1.name : void 0 : void 0) || '' : ((ref2 = this.states[state.toUpperCase()]) != null ? (ref3 = ref2.prev) != null ? ref3.name : void 0 : void 0) || '' : forward ? this.startState.name : this.endState.name;
          newText = m[1] + ' ' + next + (next ? ' ' : '') + block.text.substring(m[0].length);
          start = this.data.offsetForBlock(block);
          return this.data.replaceText({
            start,
            end: start + block.text.length,
            text: newText,
            source: 'edit'
          });
        }
      }

      bind(opts) {
        opts.bindings['S-RIGHT'] = (editor, e, r) => {
          if (this.shiftRight(opts.editor.docOffset(r))) {
            e.originalEvent.stopPropagation();
            return e.originalEvent.preventDefault();
          }
        };
        return opts.bindings['S-LEFT'] = (editor, e, r) => {
          if (this.shiftLeft(opts.editor.docOffset(r))) {
            e.originalEvent.stopPropagation();
            return e.originalEvent.preventDefault();
          }
        };
      }

    };
    todoForEditor = function(ed, todoDefs) {
      return new Todo(ed.options.data, todoDefs).bind(ed.options);
    };
    stdTodo = {
      todo: [
        {
          name: 'TODO'
        }
      ],
      done: [
        {
          name: 'DONE'
        }
      ]
    };
    return {Todo, todoForEditor};
  });

}).call(this);

//# sourceMappingURL=todo.js.map
