// Generated by CoffeeScript 1.12.7
(function() {
  var OdbWorker, TraceDumper, addCallGraphEntry, addRecord, defKey, dump, last, newTraceRecords, pad, processTrace, shared, traceRecords, verbose, worker,
    slice = [].slice;

  self.traceRecords = traceRecords = {};

  shared = typeof SharedWorkerGlobalScope !== "undefined" && SharedWorkerGlobalScope !== null;

  defKey = function(context, id) {
    var key;
    return key = context.id + "-" + id;
  };

  verbose = function() {};

  OdbWorker = (function() {
    function OdbWorker() {
      if (shared) {
        self.onconnect = (function(_this) {
          return function(e) {
            return _this.init(e.ports[0]);
          };
        })(this);
      } else {
        this.init(self);
      }
    }

    OdbWorker.prototype.init = function(port) {
      this.port = port;
      return this.port.onmessage = function(e) {
        var err;
        verbose("message ", e.data.msg);
        try {
          return worker[e.data.msg](e, e.data);
        } catch (error) {
          err = error;
          console.log(err.stack);
          if (e.data.msgId) {
            return this.port.postMessage({
              msgId: msgId,
              error: {
                message: err.message,
                stack: err.stack
              }
            });
          }
        }
      };
    };

    OdbWorker.prototype.setVerbose = function(e, arg) {
      var state;
      state = arg.verbose;
      return verbose = state ? function() {
        var args;
        args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return console.log.apply(console, args);
      } : function() {};
    };

    OdbWorker.prototype.queueValues = function(e, arg) {
      var logName, pos, records, ref, values;
      logName = arg.logName, values = arg.values;
      records = (ref = traceRecords[logName]) != null ? ref : newTraceRecords(logName);
      pos = 0;
      while (pos < values.length) {
        pos = this[values[pos]](records, pos, values);
      }
      return null;
    };

    OdbWorker.prototype.getTraceRecords = function(e) {
      var logName;
      if (logName = e.data.logName) {
        return traceRecords[logName] || (function() {
          throw new Error("No trace log named " + logName);
        })();
      } else {
        throw new Error("No trace log specified");
      }
    };

    OdbWorker.prototype.dumpValues = function(e, arg) {
      var logName;
      logName = arg.logName;
      return console.log(traceRecords[logName].dump());
    };

    OdbWorker.prototype.latestEntry = function(e, arg) {
      var logName, msgId, r;
      logName = arg.logName, msgId = arg.msgId;
      console.log("GETTING LATEST ENTRY");
      return this.port.postMessage({
        "return": (r = this.getTraceRecords(e)) && r.sequence[r.sequenceCount - 1],
        msgId: msgId
      });
    };

    OdbWorker.prototype.getEntry = function(e, arg) {
      var key, logName, msgId, records, ref, type;
      logName = arg.logName, type = arg.type, key = arg.key, msgId = arg.msgId;
      if (!type) {
        type = 'sequence';
      }
      return this.port.postMessage({
        "return": (records = this.getTraceRecords(e)) && ((ref = records[type]) != null ? ref[key] : void 0),
        msgId: msgId
      });
    };

    OdbWorker.prototype.getCallGraphInfo = function(e, arg) {
      var logName, msgId, records;
      logName = arg.logName, msgId = arg.msgId;
      records = this.getTraceRecords(e);
      return this.port.postMessage({
        "return": {
          length: records.callGraphs.length,
          latest: records.callGraphs.slice(records.callGraphs.length - 10)
        },
        msgId: msgId
      });
    };

    OdbWorker.prototype.getCallGraphEntry = function(e, arg) {
      var logName, msgId, number;
      logName = arg.logName, msgId = arg.msgId, number = arg.number;
      return this.port.postMessage({
        "return": this.getTraceRecords(e).callGraphs[number],
        msgId: msgId
      });
    };

    OdbWorker.prototype.clearEntries = function(e, arg) {
      var logName;
      logName = arg.logName;
      return newTraceRecords(logName);
    };

    OdbWorker.prototype.deleteEntries = function(e, arg) {
      var logName;
      logName = arg.logName;
      return traceRecords[logName] = {};
    };

    OdbWorker.prototype.getContextDef = function(e, arg) {
      var context, id, logName, msgId;
      logName = arg.logName, context = arg.context, id = arg.id, msgId = arg.msgId;
      context = this.getTraceRecords(e).contexts[context];
      return this.port.postMessage({
        "return": context.lazyDefs[id] || context.lambdaDefs[id],
        msgId: msgId
      });
    };

    OdbWorker.prototype.getLambdaDef = function(e, arg) {
      var lambdaName, logName;
      logName = arg.logName, lambdaName = arg.lambdaName;
      return this.port.postMessage({
        "return": this.getTraceRecords(e).lambdaDefsByName[lambdaName],
        msgId: msgId
      });
    };

    OdbWorker.prototype.lazyValue = function(records, pos, values) {
      var context, id, instance, record, type;
      type = values[pos++];
      instance = values[pos++];
      context = values[pos++];
      id = values[pos++];
      record = records.add(records.values, instance, {
        type: type,
        instance: instance,
        context: context,
        id: id
      });
      records.addCallGraphEntry(0, record.sequence);
      return pos;
    };

    OdbWorker.prototype.resolve = function(records, pos, values) {
      var instance, record, result, type;
      type = values[pos++];
      instance = values[pos++];
      result = [values[pos++]];
      if (result[0] === -1) {
        result.push(values[pos++]);
      }
      record = records.add(records.resolves, instance, {
        type: type,
        instance: instance,
        value: result
      });
      records.addCallGraphEntry(0, record.sequence);
      return pos;
    };

    OdbWorker.prototype.lambda = function(records, pos, values) {
      var context, id, instance, parent, type;
      type = values[pos++];
      instance = values[pos++];
      context = values[pos++];
      id = values[pos++];
      parent = values[pos++];
      records.add(records.lambdas, instance, {
        type: type,
        instance: instance,
        context: context,
        id: id,
        parent: parent
      });
      records.lambdaList.push(instance);
      return pos;
    };

    OdbWorker.prototype.call = function(records, pos, values) {
      var args, context, i, id, instance, j, record, ref, type, v;
      type = values[pos++];
      instance = values[pos++];
      context = values[pos++];
      id = values[pos++];
      args = [];
      for (i = j = 0, ref = values[pos++]; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        args.push(v = values[pos++]);
        if (v === -1) {
          args.push(values[pos++]);
        }
      }
      record = records.add(records.calls, null, {
        type: type,
        instance: instance,
        context: context,
        id: id,
        args: args
      });
      records.stack.push(record);
      records.addCallGraphEntry(1, record.sequence);
      return pos;
    };

    OdbWorker.prototype["return"] = function(records, pos, values) {
      var caller, context, id, instance, record, result, type;
      type = values[pos++];
      instance = values[pos++];
      context = values[pos++];
      id = values[pos++];
      result = [values[pos++]];
      if (result[0] === -1) {
        result.push(values[pos++]);
      }
      caller = records.stack.pop();
      record = records.add(records.returns, null, {
        type: type,
        instance: instance,
        context: context,
        id: id,
        caller: caller.sequence,
        value: result
      });
      records.addCallGraphEntry(-1, record.sequence);
      return pos;
    };

    OdbWorker.prototype.createPartial = function(records, pos, values) {
      var args, context, i, id, instance, j, lambda, record, ref, type, v;
      type = values[pos++];
      instance = values[pos++];
      lambda = values[pos++];
      context = values[pos++];
      id = values[pos++];
      args = [];
      for (i = j = 0, ref = values[pos++]; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        args.push(v = values[pos++]);
        if (v === -1) {
          args.push(values[pos++]);
        }
      }
      record = records.add(records.partials, instance, {
        type: type,
        instance: instance,
        lambda: lambda,
        context: context,
        id: id,
        args: args
      });
      return pos;
    };

    OdbWorker.prototype.callPartial = function(records, pos, values) {
      var args, context, i, id, instance, j, lambda, record, ref, type, v;
      type = values[pos++];
      instance = values[pos++];
      lambda = values[pos++];
      context = values[pos++];
      id = values[pos++];
      args = [];
      for (i = j = 0, ref = values[pos++]; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        args.push(v = values[pos++]);
        if (v === -1) {
          args.push(values[pos++]);
        }
      }
      record = records.add(records.partialCalls, instance, {
        type: type,
        instance: instance,
        lambda: lambda,
        context: context,
        id: id,
        args: args
      });
      records.addCallGraphEntry(0, record.sequence);
      return pos;
    };

    OdbWorker.prototype.mark = function(records, pos, values) {
      var count, record, type;
      type = values[pos++];
      count = values[pos++];
      record = records.add(records.marks, null, {
        type: type,
        count: count
      });
      return pos;
    };

    OdbWorker.prototype.context = function(records, pos, values) {
      var argCount, args, col, context, debugType, defs, externalMap, id, inlineMap, lambdaDefs, lazyDefs, length, line, name, parent, ref, ref1, ref2, source, type;
      ref = values.slice(pos, pos + 7), type = ref[0], context = ref[1], source = ref[2], inlineMap = ref[3], externalMap = ref[4], debugType = ref[5], length = ref[6];
      pos += 7;
      defs = [];
      lambdaDefs = {};
      lazyDefs = {};
      records.contexts[context] = {
        type: type,
        id: context,
        source: source,
        inlineMap: inlineMap,
        externalMap: externalMap,
        defs: defs,
        lambdaDefs: lambdaDefs,
        lazyDefs: lazyDefs,
        debugType: debugType
      };
      id = 0;
      length += pos;
      while (pos < length) {
        ref1 = values.slice(pos, pos + 4), type = ref1[0], line = ref1[1], col = ref1[2], parent = ref1[3];
        pos += 4;
        if (type === 'lazy') {
          defs.push(lazyDefs[id] = {
            context: context,
            id: id,
            type: 'lazyDef',
            line: line,
            col: col,
            parent: parent
          });
        } else {
          ref2 = values.slice(pos, pos + 2), name = ref2[0], argCount = ref2[1];
          pos += 2;
          args = values.slice(pos, pos + argCount);
          pos += argCount;
          defs.push(lambdaDefs[id] = {
            context: context,
            id: id,
            type: 'lambdaDef',
            line: line,
            col: col,
            parent: parent,
            name: name,
            args: args
          });
          if (name) {
            records.lambdaDefsByName[name] = lambdaDefs[id];
          }
        }
        id++;
      }
      return pos;
    };

    return OdbWorker;

  })();

  self.worker = worker = new OdbWorker();

  self.traceRecords = traceRecords;

  console.log("global: ", self);

  console.log("worker: ", worker);

  console.log("records: ", traceRecords);

  addRecord = function(records, map, instanceId, record) {
    var seq;
    seq = record.sequence = records.sequenceCount++;
    records.sequence[seq] = record;
    if (map) {
      map[instanceId !== null ? instanceId : seq] = record;
    }
    if (records.items[instanceId] == null) {
      records.items[instanceId] = record;
    }
    return record;
  };

  newTraceRecords = function(name) {
    var records, ref, ref1, ref2, ref3;
    records = traceRecords[name] = {
      callGraphs: [],
      sequenceCount: 0,
      sequence: [],
      contexts: (ref = (ref1 = traceRecords[name]) != null ? ref1.contexts : void 0) != null ? ref : [],
      lambdaDefsByName: (ref2 = (ref3 = traceRecords[name]) != null ? ref3.lambdaDefsByName : void 0) != null ? ref2 : {},
      values: {},
      resolves: {},
      lambdas: {},
      lambdaIds: [],
      calls: {},
      partials: {},
      partialCalls: {},
      returns: {},
      items: {},
      contexts: [],
      stack: []
    };
    records.add = addRecord.bind(null, records);
    records.dump = dump.bind(null, name);
    records.addCallGraphEntry = addCallGraphEntry.bind(null, records);
    return records;
  };

  last = function(a) {
    return a[a.length - 1];
  };

  addCallGraphEntry = function(records, delta, seq) {
    var cg, entry;
    cg = records.callGraphs;
    if (cg.length === 0 || (entry = last(cg).level === 0)) {
      entry = {
        size: 0,
        level: 0,
        start: seq
      };
      cg.push(entry);
    }
    entry.size++;
    entry.level += delta;
    if (entry.level < 0) {
      throw new Error("Call level dropped below zero");
    } else if (entry.level === 0) {
      return entry.end = seq;
    }
  };

  processTrace = function(records, value) {};

  TraceDumper = (function() {
    function TraceDumper() {}

    TraceDumper.prototype.dump = function(records1) {
      var context, def, i, result, type;
      this.records = records1;
      this.level = 0;
      this.called = {};
      result = ((function() {
        var j, len, ref, results;
        ref = this.records.contexts;
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          context = ref[j];
          results.push(this.dumpRecord(context) + '\n' + ((function() {
            var k, len1, ref1, results1;
            ref1 = context.defs;
            results1 = [];
            for (k = 0, len1 = ref1.length; k < len1; k++) {
              def = ref1[k];
              type = def.type === 'lazy' ? 'lazyDef' : 'lambdaDef';
              results1.push(this.dumpRecord(Object.assign({}, def, {
                type: type
              })));
            }
            return results1;
          }).call(this)).join('\n'));
        }
        return results;
      }).call(this)).join('\n');
      return result + '\n' + ((function() {
        var j, ref, results;
        results = [];
        for (i = j = 0, ref = this.records.sequenceCount; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
          results.push(this.dumpRecord(this.records.sequence[i]));
        }
        return results;
      }).call(this)).join('\n');
    };

    TraceDumper.prototype.dumpRecord = function(record) {
      var i, j, prefix, ref;
      prefix = record.sequence != null ? pad(7, String(record.sequence)) + ' ' : '';
      for (i = j = 0, ref = this.level; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        prefix = prefix + '  ';
      }
      return ("" + prefix + record.type + " ") + this[record.type](record).join(' ');
    };

    TraceDumper.prototype.nameForLambda = function(lambda, context, id) {
      var ctx, def, l, ref;
      if ((context == null) && typeof lambda === 'number') {
        if (l = this.records.lambdas[lambda]) {
          def = this.records.contexts[l.context].defs[l.id];
        }
      } else if (context != null) {
        def = this.records.contexts[context].defs[id];
      } else if (lambda.context != null) {
        def = this.records.contexts[lambda.context].defs[lambda.id];
      }
      if (def) {
        if (def.name) {
          return def.name;
        } else {
          id = def.id;
          ctx = this.records.contexts[def.context];
          while (def && !def.name) {
            def = ctx.defs[def.parent];
          }
          return ((ref = def != null ? def.name : void 0) != null ? ref : '') + "[" + id + "]";
        }
      } else {
        return "[" + lambda + "]";
      }
    };

    TraceDumper.prototype.nextValue = function(value, pos) {
      var v;
      pos = pos != null ? pos : 0;
      if (value[pos] === -1) {
        return value[pos + 1];
      } else if (typeof value[pos] === 'number') {
        if (v = this.records.values[value[pos]]) {
          return "VALUE[" + v.instance + " in " + (this.nameForLambda(v.parent)) + "]";
        } else {
          return this.nameForLambda(value[pos]);
        }
      } else {
        return value[pos];
      }
    };

    TraceDumper.prototype.context = function(arg) {
      var debugType, id, source;
      id = arg.id, source = arg.source, debugType = arg.debugType;
      return [id, source, debugType];
    };

    TraceDumper.prototype.lambdaDef = function(arg) {
      var argNames, col, context, id, line, name, parent, ref;
      line = arg.line, col = arg.col, context = arg.context, id = arg.id, parent = arg.parent, name = arg.name, argNames = arg.argNames;
      return [(ref = this.nameForLambda('unknown', context, id)) != null ? ref : '????', "id: " + context + ":" + id + ":" + (parent != null ? parent : '-'), "position: " + (line != null ? line : '?') + ":" + (col != null ? col : '?'), argNames];
    };

    TraceDumper.prototype.lazyDef = function(arg) {
      var col, context, id, line, parent;
      line = arg.line, col = arg.col, context = arg.context, id = arg.id, parent = arg.parent;
      return ["id: " + context + ":" + id + ":" + (parent != null ? parent : '-'), "position: " + (line != null ? line : '?') + ":" + (col != null ? col : '?')];
    };

    TraceDumper.prototype.lazyValue = function(arg) {
      var context, id, instance, parent;
      instance = arg.instance, id = arg.id, parent = arg.parent, context = arg.context;
      return ["(" + instance + " " + (this.nameForLambda("unknown", context, id)) + ")"];
    };

    TraceDumper.prototype.resolve = function(arg) {
      var instance, value;
      instance = arg.instance, value = arg.value;
      return ["(" + instance + "):", this.nextValue(value)];
    };

    TraceDumper.prototype.lambda = function(arg) {
      var context, id, instance, parent;
      instance = arg.instance, context = arg.context, id = arg.id, parent = arg.parent;
      return [this.nameForLambda(instance, context, id), this.records.contexts[context].defs[id].args.join(', ')];
    };

    TraceDumper.prototype.call = function(arg) {
      var args, context, id, instance, pos, result;
      instance = arg.instance, context = arg.context, id = arg.id, args = arg.args;
      if (this.called[instance]) {
        this.called[instance]++;
      } else {
        this.called[instance] = 1;
      }
      this.level++;
      result = [this.nameForLambda(instance, context, id), "(" + instance + "):"];
      pos = 0;
      while (pos < args.length) {
        result.push(this.nextValue(args, pos));
        pos += args[pos] === -1 ? 2 : 1;
      }
      return result;
    };

    TraceDumper.prototype["return"] = function(arg) {
      var caller, context, id, instance, value;
      caller = arg.caller, instance = arg.instance, context = arg.context, id = arg.id, value = arg.value;
      if (this.called[instance]) {
        this.called[instance]--;
        this.level--;
      }
      return ["from", this.nameForLambda(instance, context, id), "(" + instance + " caller: " + caller + "):", this.nextValue(value)];
    };

    TraceDumper.prototype.createPartial = function(arg) {
      var args, instance, lambda;
      instance = arg.instance, lambda = arg.lambda, args = arg.args;
      return [this.nameForLambda(lambda), instance, args];
    };

    TraceDumper.prototype.callPartial = function(arg) {
      var args, instance;
      instance = arg.instance, args = arg.args;
      return [this.nameForLambda(this.records.partials[instance].lambda), instance, args];
    };

    return TraceDumper;

  })();

  pad = function(number, string) {
    while (string.length < number) {
      string = " " + string;
    }
    return string;
  };

  dump = function(logName) {
    return new TraceDumper().dump(traceRecords[logName]);
  };

  self.dump = dump;

}).call(this);

//# sourceMappingURL=odbWorker.js.map
