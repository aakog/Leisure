// Generated by CoffeeScript 1.9.3
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  define(['jquery', 'immutable', 'cs!./lib/webrtc.litcoffee', 'lib/cycle', 'cs!./editor.litcoffee', 'cs!./editorSupport.litcoffee', 'sockjs', 'cs!./hamtData.litcoffee'], function(jq, immutable, Peer, cycle, Editor, Support, SockJS, HamtData) {
    var DataStore, HamtOrgData, Map, MasterConnection, MessageHandler, OrgData, PeerConnection, SlaveConnection, preserveSelection;
    Map = (window.Immutable = immutable).Map;
    PeerConnection = Peer.PeerConnection, MasterConnection = Peer.MasterConnection, SlaveConnection = Peer.SlaveConnection;
    DataStore = Editor.DataStore, preserveSelection = Editor.preserveSelection;
    OrgData = Support.OrgData;
    HamtOrgData = HamtData.HamtOrgData;
    Peer = (function() {
      function Peer() {
        this.data = new OrgData();
      }

      Peer.prototype.disconnect = function() {
        var ref;
        if ((ref = this.con) != null) {
          ref.close();
        }
        return this.con = null;
      };

      Peer.prototype.createSession = function(host, connected) {
        this.con = new MasterConnection();
        return this.con.setConnection(this, host, connected);
      };

      Peer.prototype.connectToSession = function(host) {
        this.con = new SlaveConnection();
        return this.con.setConnection(this, host);
      };

      return Peer;

    })();
    MessageHandler = (function() {
      function MessageHandler() {}

      MessageHandler.prototype.setConnection = function(peer, host1, connectedFunc) {
        this.peer = peer;
        this.host = host1;
        this.connectedFunc = connectedFunc;
        this.con = new SockJS("http://" + this.host + "/Leisure/master");
        this.con.onmessage = (function(_this) {
          return function(msg) {
            return _this.handleMessage(JSON.parse(msg.data));
          };
        })(this);
        return this.con.onclose = (function(_this) {
          return function() {
            return _this.closed();
          };
        })(this);
      };

      MessageHandler.prototype.type = 'Unknown Handler';

      MessageHandler.prototype.close = function() {
        return this.con.close();
      };

      MessageHandler.prototype.closed = function() {};

      MessageHandler.prototype.send = function(type, msg) {
        msg.type = type;
        console.log("Sending message", msg);
        return this.con.send(JSON.stringify(msg));
      };

      MessageHandler.prototype.handleMessage = function(msg) {
        var ref, ref1;
        console.log(this.type + " received: " + (JSON.stringify(msg)));
        if (ref = (ref1 = msg.type) != null ? ref1.toLowerCase() : void 0, indexOf.call(this.legalMessages, ref) >= 0) {
          return this[msg.type](msg);
        } else {
          console.log("Received bad message " + msg.type, msg);
          return this.close();
        }
      };

      MessageHandler.prototype.legalMessages = ['log', 'connect', 'error'];

      MessageHandler.prototype.log = function(msg) {
        return console.log(msg.msg);
      };

      MessageHandler.prototype.connect = function(msg) {
        this.id = msg.id;
        console.log("Connected, id: " + this.id);
        this.peer.data.addFilter(this.filter());
        if (typeof this.connectedFunc === "function") {
          this.connectedFunc(this);
        }
        return this.connectedFunc = null;
      };

      MessageHandler.prototype.error = function(msg) {
        console.log("Received error: " + msg.error, msg);
        return this.close();
      };

      return MessageHandler;

    })();
    MasterConnection = (function(superClass) {
      extend(MasterConnection, superClass);

      function MasterConnection() {
        return MasterConnection.__super__.constructor.apply(this, arguments);
      }

      MasterConnection.prototype.type = 'Master';

      MasterConnection.prototype.filter = function() {
        var con;
        if (!this.myFilter) {
          con = this;
          this.myFilter = {
            clear: function() {},
            replaceBlock: function(oldBlock, newBlock) {
              var end, endOff, i, j, newLen, oldLen, ref, ref1, ref2, ref3, start, startOff, text;
              start = con.peer.data.offsetForBlock((ref = oldBlock != null ? oldBlock._id : void 0) != null ? ref : newBlock._id);
              end = start + ((ref1 = oldBlock != null ? oldBlock.text.length : void 0) != null ? ref1 : 0);
              text = newBlock.text;
              if (oldBlock && newBlock) {
                oldLen = oldBlock.text.length;
                newLen = newBlock.text.length;
                for (startOff = i = 0, ref2 = Math.min(oldLen, newLen); 0 <= ref2 ? i < ref2 : i > ref2; startOff = 0 <= ref2 ? ++i : --i) {
                  if (oldBlock.text[startOff] !== newBlock.text[startOff]) {
                    break;
                  }
                }
                start += startOff;
                for (endOff = j = 0, ref3 = Math.min(oldLen, newLen); 0 <= ref3 ? j <= ref3 : j >= ref3; endOff = 0 <= ref3 ? ++j : --j) {
                  if (oldBlock.text[oldLen - endOff] !== newBlock.text[newLen - endOff] || oldLen - endOff <= startOff || newLen - endOff <= startOff) {
                    break;
                  }
                }
                end -= endOff;
                if (startOff || endOff) {
                  text = text.substring(startOff, text.length - endOff);
                }
              }
              if (start !== end || text !== '') {
                return con.sendReplace(start, end, text);
              }
            }
          };
        }
        return this.myFilter;
      };

      MasterConnection.prototype.closed = function() {
        console.log("CLOSING MASTER");
        this.peer.data.removeFilter(this.myFilter);
        this.myFilter = null;
        return MasterConnection.__super__.closed.call(this);
      };

      MasterConnection.prototype.sendReplace = function(start, end, text) {
        return this.send('replace', {
          start: start,
          end: end,
          text: text
        });
      };

      MasterConnection.prototype.connect = function(msg) {
        this.connectUrl = "http://" + this.host + "/Leisure/slave-" + msg.id;
        return MasterConnection.__super__.connect.call(this, msg);
      };

      return MasterConnection;

    })(MessageHandler);
    return {
      Peer: Peer
    };
  });

}).call(this);

//# sourceMappingURL=p2p.js.map
