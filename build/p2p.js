// Generated by CoffeeScript 1.9.3
(function() {
  define(['jquery', 'immutable', './editor', './editorSupport', 'sockjs', './hamtData', './advice', './ot'], function(jq, immutable, Editor, Support, SockJS, HamtData, Advice, OT) {
    var DataStore, HamtOrgData, Map, OrgData, Peer, Set, afterMethod, basicDataFilter, beforeMethod, blockText, callOriginal, changeAdvice, computeNewStructure, editorToolbar, getDocumentParams, preserveSelection, ref, replacementFor, validateBatch;
    ref = window.Immutable = immutable, Map = ref.Map, Set = ref.Set;
    DataStore = Editor.DataStore, preserveSelection = Editor.preserveSelection, blockText = Editor.blockText, computeNewStructure = Editor.computeNewStructure, validateBatch = Editor.validateBatch;
    OrgData = Support.OrgData, getDocumentParams = Support.getDocumentParams, editorToolbar = Support.editorToolbar, basicDataFilter = Support.basicDataFilter;
    HamtOrgData = HamtData.HamtOrgData;
    changeAdvice = Advice.changeAdvice, afterMethod = Advice.afterMethod, beforeMethod = Advice.beforeMethod, callOriginal = Advice.callOriginal;
    Peer = (function() {
      function Peer() {
        this.data = new HamtOrgData();
        this.clearChanges();
        this.versionReplaces = [];
        this.pendingReplaces = [];
        this.pendingCount = 0;
        this.pendingUnreplacements = [];
        this.unreplacements = [];
        this.batchCallbacks = [];
        this.messageCount = 0;
        this.dataFilter = {
          __proto__: basicDataFilter,
          endChange: (function(_this) {
            return function() {
              return _this.dataFinishedChange;
            };
          })(this),
          clear: (function(_this) {
            return function() {
              return _this.dataClear;
            };
          })(this),
          replaceBlock: (function(_this) {
            return function(data, oldBlock, newBlock) {
              return _this.recordChange(_this.peerChanges, oldBlock, newBlock);
            };
          })(this)
        };
        this.version = -1;
      }

      Peer.prototype.clearChanges = function() {
        return this.ot = new OT();
      };

      Peer.prototype.recordChange = function(changes, oldBlock, newBlock) {
        if (!newBlock) {
          changes.removes[oldBlock._id] = true;
          return delete changes.sets[oldBlock._id];
        } else {
          delete changes.removes[newBlock._id];
          return changes.sets[newBlock._id] = true;
        }
      };

      Peer.prototype.recordLocalChanges = function(oldBlocks, newBlocks) {
        var block, id, newIds, ref1, results;
        newIds = _.indexBy(newBlocks, '_id');
        ref1 = _.indexBy(oldBlocks, '_id');
        for (id in ref1) {
          block = ref1[id];
          if (!newIds[id]) {
            this.recordChange(this.localChanges, block, null);
          }
        }
        results = [];
        for (id in newIds) {
          block = newIds[id];
          results.push(this.recordChange(this.localChanges, null, block));
        }
        return results;
      };

      Peer.prototype.setEditor = function(editor) {
        this.editor = editor;
      };

      Peer.prototype.disconnect = function() {
        var ref1;
        if ((ref1 = this.con) != null) {
          ref1.close();
        }
        return this.con = null;
      };

      Peer.prototype.subsumesIncoming = function(cur, next) {
        var ref1, ref2, ref3, ref4;
        return next.mine && (!cur || ((ref1 = next.pendingCount) != null ? ref1 : -1) > ((ref2 = cur.pendingCount) != null ? ref2 : -1) || ((ref3 = next.messageCount) != null ? ref3 : -1) > ((ref4 = cur.messageCount) != null ? ref4 : -1));
      };

      Peer.prototype.applyIncomingChanges = function() {
        var i, j, len, myPos, ot, range, ref1, ref2, repl;
        ref1 = this.unreplacements;
        for (i = ref1.length - 1; i >= 0; i += -1) {
          repl = ref1[i];
          this.logReplacement("VER U ", repl.start, repl.end, repl.text);
          this.data.replaceText(repl.start, repl.end, repl.text);
        }
        this.unreplacements = [];
        this.pendingUnreplacements = [];
        ot = this.ot.snapshot();
        ref2 = this.pendingReplaces;
        for (j = 0, len = ref2.length; j < len; j++) {
          repl = ref2[j];
          if (repl.type === 'replace') {
            ot.replace(repl);
          }
        }
        myPos = -1;
        preserveSelection((function(_this) {
          return function(range) {
            return ot.eachOperation(function(start, end, text, offset, effect) {
              var k, len1, myLast, myLatest, ref3, ref4, results, tmpEnd, tmpOff, tmpStart;
              myLatest = null;
              myLast = _.last(_this.pendingReplaces);
              tmpOff = offset;
              ref3 = effect.activeOperations;
              results = [];
              for (k = 0, len1 = ref3.length; k < len1; k++) {
                repl = ref3[k];
                tmpStart = repl.start + tmpOff;
                tmpEnd = repl.end + tmpOff;
                if (repl === myLast || (repl !== myLast && _this.subsumesIncoming(myLatest, repl))) {
                  myPos = tmpStart + repl.text.length;
                }
                if (repl.pendingCount) {
                  _this.pushUnreplacement(_this.pendingUnreplacements, tmpStart, tmpEnd, repl.text);
                }
                _this.pushUnreplacement(_this.unreplacements, tmpStart, tmpEnd, repl.text);
                _this.logReplacement((_this.nodeLabel(effect)) + " R ", tmpStart, tmpEnd, repl.text);
                _this.data.replaceText(tmpStart, tmpEnd, repl.text);
                if (tmpEnd <= range.start) {
                  range.start += repl.text.length - tmpEnd + tmpStart;
                } else if ((tmpStart <= (ref4 = range.start) && ref4 < tmpEnd)) {
                  range.start = tmpStart + repl.text.length;
                }
                results.push(tmpOff += repl.text.length);
              }
              return results;
            });
          };
        })(this));
        if (myPos > -1) {
          range = this.editor.getSelectedDocRange();
          range.start = myPos;
          range.length = 0;
          return this.editor.selectDocRange(range);
        }
      };

      Peer.prototype.nodeLabel = function(node) {
        var hasIncoming, hasPending, i, len, op, ref1;
        hasPending = false;
        hasIncoming = false;
        ref1 = node.activeOperations;
        for (i = 0, len = ref1.length; i < len; i++) {
          op = ref1[i];
          if (op.pendingCount) {
            hasPending = true;
          } else {
            hasIncoming = true;
          }
        }
        if (hasIncoming && hasPending) {
          return "P/I";
        } else if (hasIncoming) {
          return "IN ";
        } else {
          return "PEN";
        }
      };

      Peer.prototype.connect = function(url, connectedFunc) {
        var peer;
        this.url = url;
        this.connectedFunc = connectedFunc;
        this.con = new SockJS(this.url);
        this.con.onmessage = (function(_this) {
          return function(msg) {
            return _this.handleMessage(JSON.parse(msg.data));
          };
        })(this);
        this.con.onclose = (function(_this) {
          return function() {
            return _this.closed();
          };
        })(this);
        peer = this;
        return changeAdvice(this.editor.options, true, {
          changesFor: {
            p2p: function(parent) {
              return function(first, oldBlocks, newBlocks, verbatim) {
                var changes;
                changes = parent(first, oldBlocks, newBlocks, verbatim);
                peer.sendReplace(changes);
                return changes;
              };
            }
          },
          batchReplace: {
            p2p: function(parent) {
              return function(replacementsFunc, contFunc, errFunc) {
                return peer.runBatchReplace(replacementsFunc, contFunc, errFunc);
              };
            }
          }
        });
      };

      Peer.prototype.type = 'Unknown Handler';

      Peer.prototype.close = function() {
        console.log("CLOSING: " + this.type);
        return this.con.close();
      };

      Peer.prototype.closed = function() {
        return changeAdvice(this.editor.options, false, {
          changesFor: {
            p2p: true
          }
        });
      };

      Peer.prototype.send = function(type, msg) {
        msg.type = type;
        return this.con.send(JSON.stringify(msg));
      };

      Peer.prototype.runBatchReplace = function(replacementsFunc, contFunc, errFunc) {
        var err, msg, pushedCallbacks, pushedReplaces, replacements;
        try {
          replacements = validateBatch(replacementsFunc());
          msg = {
            type: 'conditionalReplace',
            replacements: replacements,
            targetVersion: this.version
          };
          this.pendingReplaces.push(msg);
          pushedReplaces = true;
          this.batchCallbacks.push({
            cont: contFunc,
            error: errFunc,
            replay: (function(_this) {
              return function() {
                return _this.runBatchReplace(replacementsFunc, contFunc, errFunc);
              };
            })(this)
          });
          pushedCallbacks = true;
          return this.send('conditionalReplace', msg);
        } catch (_error) {
          err = _error;
          if (pushedReplaces) {
            this.pendingReplaces.pop();
          }
          if (pushedCallbacks) {
            this.batchCallbacks.pop();
          }
          return errFunc(err);
        }
      };

      Peer.prototype.sendReplace = function(arg) {
        var i, len, newBlocks, newRepl, offset, oldBlocks, r, ref1, repl;
        oldBlocks = arg.oldBlocks, newBlocks = arg.newBlocks;
        offset = this.data.offsetForBlock(oldBlocks[0]);
        repl = replacementFor(offset, blockText(oldBlocks), blockText(newBlocks));
        repl.type = 'replace';
        repl.version = this.version;
        this.pushUnreplacement(this.pendingUnreplacements, repl.start, repl.end, repl.text);
        this.pushUnreplacement(this.unreplacements, repl.start, repl.end, repl.text);
        this.logReplacement("OUT R ", repl.start, repl.end, repl.text);
        ref1 = this.versionReplaces;
        for (i = 0, len = ref1.length; i < len; i++) {
          r = ref1[i];
          if (r.end < repl.start) {
            offset = r.text.length - r.end + r.start;
            repl.start -= offset;
            repl.end -= offset;
          }
        }
        this.pendingReplaces.push(newRepl = _.merge({
          mine: true,
          pendingCount: ++this.pendingCount
        }, repl));
        this.versionReplaces.push(newRepl);
        return this.send('replace', repl);
      };

      Peer.prototype.logReplacement = function(label, start, end, text) {
        return console.log(label + " " + start + " '" + (this.data.getDocSubstring(start, end)) + "' -> '" + text + "'");
      };

      Peer.prototype.pushUnreplacement = function(unrepl, start, end, text) {
        return unrepl.push({
          start: start,
          end: start + text.length,
          text: this.data.getDocSubstring(start, end)
        });
      };

      Peer.prototype.handleMessage = function(msg) {
        msg.mine = msg.connectionId === this.connectionId || msg.type === 'echo';
        msg.messageCount = this.messageCount++;
        if (!(msg.type in this.handler)) {
          console.log("Received bad message " + msg.type, msg);
          return this.close();
        } else {
          return this.handler[msg.type].call(this, msg);
        }
      };

      Peer.prototype.dumpReplacements = function() {
        var offset, replacementWidth, repls;
        repls = '';
        offset = 0;
        replacementWidth = 0;
        this.ot.eachOperation(function(start, end, text) {
          var deletionWidth;
          if (offset < start) {
            offset = start;
            deletionWidth = 0;
            replacementWidth = 0;
          } else if (end - start > 0 && deletionWidth > end - start) {
            return;
          }
          if (end - start > 0 && end - start === deletionWidth) {
            repls += "OVERRIDE " + start + ", " + end + ", " + text + "\n";
          } else {
            repls += start + ", " + end + ", " + text + "\n";
          }
          deletionWidth = Math.max(deletionWidth, end - start);
          return replacementWidth = Math.max(replacementWidth, text.length);
        });
        return repls;
      };

      Peer.prototype.handler = {
        log: function(msg) {
          return console.log(msg.msg);
        },
        connect: function(msg) {
          this.id = msg.id, this.connectionId = msg.connectionId, this.version = msg.version;
          this.clearChanges();
          if (typeof this.connectedFunc === "function") {
            this.connectedFunc(this);
          }
          return this.connectedFunc = null;
        },
        error: function(msg) {
          console.log("Received error: " + msg.error, msg);
          return this.close();
        },
        newVersion: function(msg) {
          var i, len, offset, ref1;
          this.version = msg.version;
          ref1 = this.pendingReplaces;
          for (i = 0, len = ref1.length; i < len; i++) {
            msg = ref1[i];
            offset = this.ot.floatFor(msg);
            msg.start += offset;
            msg.end += offset;
            msg.version = this.version;
          }
          while (this.versionReplaces.length > this.pendingReplaces.length) {
            this.versionReplaces.shift();
          }
          this.unreplacements = this.pendingUnreplacements.slice();
          this.clearChanges();
          return this.send('ack', {});
        },
        rejectChange: function() {
          this.pendingReplaces.shift();
          return this.batchCallbacks.pop().replay();
        },
        echo: function(msg) {
          var err, pending;
          pending = this.pendingReplaces.shift();
          pending.messageCount = msg.messageCount;
          pending.version = this.version;
          pending.pendingCount = null;
          if (pending.type === 'conditionalReplace') {
            try {
              this.replaceBatch(pending.replacements);
              return this.batchCallbacks.pop().cont();
            } catch (_error) {
              err = _error;
              return this.batchCallbacks.pop().error(err);
            }
          } else {
            pending.connectionId = this.connectionId;
            return this.handleMessage(pending);
          }
        },
        conditionalReplace: function(arg) {
          var replacements, version;
          replacements = arg.replacements, version = arg.version;
          return preserveSelection((function(_this) {
            return function(range) {
              var end, i, len, offset, ref1, repl, start;
              offset = 0;
              for (i = 0, len = replacements.length; i < len; i++) {
                repl = replacements[i];
                start = repl.start, end = repl.end;
                start += offset;
                end += offset;
                if (end <= range.start) {
                  range.start += text.length - end + start;
                } else if ((start <= (ref1 = range.start) && ref1 < end)) {
                  range.start = start + text.length;
                }
                offset += repl.text.length - repl.end + repl.start;
              }
              return _this.replaceBatch(replacements);
            };
          })(this));
        },
        replace: function(msg) {
          if (msg.upgraded && msg.mine) {
            this.pendingReplaces.shift();
          }
          this.ot.replace(msg);
          return this.applyIncomingChanges();
        }
      };

      Peer.prototype.replaceBatch = function(replacements) {
        return this.data.batchReplace(replacements);
      };

      Peer.prototype.createSession = function(host, connectedFunc) {
        this.host = host;
        this.connectedFunc = connectedFunc;
        this.type = 'Master';
        this.handler = {
          __proto__: Peer.prototype.handler,
          connect: function(msg) {
            this.connectUrl = new URL("slave-" + msg.id, this.url);
            Peer.prototype.handler.connect.call(this, msg);
            return this.send('initDoc', {
              doc: this.data.getText()
            });
          },
          slaveConnect: function(msg) {
            return this.send('slaveApproval', {
              slaveId: msg.slaveId,
              approval: true
            });
          },
          slaveDisconnect: function(msg) {}
        };
        return this.connect("http://" + this.host + "/Leisure/master", this.connectedFunc);
      };

      Peer.prototype.connectToSession = function(url, connected) {
        this.url = url;
        this.type = 'Slave';
        this.handler = {
          __proto__: Peer.prototype.handler,
          connect: function(msg) {
            Peer.prototype.handler.connect.call(this, msg);
            return this.editor.options.load(msg.doc);
          }
        };
        return this.connect(this.url, connected);
      };

      return Peer;

    })();
    replacementFor = function(start, oldText, newText) {
      var end, endOff, i, j, ref1, ref2, ref3, startOff;
      end = start + ((ref1 = oldText.length) != null ? ref1 : 0);
      for (startOff = i = 0, ref2 = Math.min(oldText.length, newText.length); 0 <= ref2 ? i < ref2 : i > ref2; startOff = 0 <= ref2 ? ++i : --i) {
        if (oldText[startOff] !== newText[startOff]) {
          break;
        }
      }
      start += startOff;
      for (endOff = j = 0, ref3 = Math.min(oldText.length - startOff - 1, newText.length - startOff - 1); j <= ref3; endOff = j += 1) {
        if (oldText[oldText.length - endOff - 1] !== newText[newText.length - endOff - 1]) {
          break;
        }
      }
      return {
        start: start,
        end: end - endOff,
        text: (startOff || endOff ? newText.substring(startOff, newText.length - endOff) : '')
      };
    };
    $(document).ready(function() {
      var connected, join;
      if (document.location.search.length > 1 && !connected) {
        connected = true;
        join = getDocumentParams().join;
        if (join) {
          return setTimeout((function() {
            var createSessionButton, u;
            createSessionButton = $(editorToolbar(window.PEER.editor.node)).find('[name=p2pConnector] [name=createSession]');
            createSessionButton.data({
              hasSession: true
            });
            createSessionButton.closest('.contents').removeClass('not-connected');
            createSessionButton.closest('.contents').addClass('connected');
            createSessionButton.button('option', 'label', 'Disconnect');
            console.log("CREATE SESSION:", createSessionButton[0]);
            u = new URL(join);
            console.log("JOIN SESSION: " + u);
            return window.PEER.connectToSession(u.toString());
          }), 1);
        }
      }
    });
    return {
      Peer: Peer
    };
  });

}).call(this);

//# sourceMappingURL=p2p.js.map
