// Generated by CoffeeScript 1.9.3
(function() {
  var slice = [].slice;

  define(['jquery', 'immutable', './editor', './editorSupport', 'sockjs', './advice', './ot'], function(jq, immutable, Editor, Support, SockJS, Advice, OperationTransformation) {
    var DataStore, Map, OrgData, Peer, SequentialReplacements, Set, afterMethod, basicDataFilter, beforeMethod, blockText, callOriginal, changeAdvice, computeNewStructure, concurrentReplacements, diag, editorToolbar, getDocumentParams, preserveSelection, ref, replacementFor, replacementsString, runReplacements, sequentialReplacements, validateBatch;
    ref = window.Immutable = immutable, Map = ref.Map, Set = ref.Set;
    DataStore = Editor.DataStore, preserveSelection = Editor.preserveSelection, blockText = Editor.blockText, computeNewStructure = Editor.computeNewStructure, validateBatch = Editor.validateBatch;
    OrgData = Support.OrgData, getDocumentParams = Support.getDocumentParams, editorToolbar = Support.editorToolbar, basicDataFilter = Support.basicDataFilter;
    changeAdvice = Advice.changeAdvice, afterMethod = Advice.afterMethod, beforeMethod = Advice.beforeMethod, callOriginal = Advice.callOriginal;
    SequentialReplacements = OperationTransformation.SequentialReplacements, runReplacements = OperationTransformation.runReplacements, replacementsString = OperationTransformation.replacementsString, sequentialReplacements = OperationTransformation.sequentialReplacements, concurrentReplacements = OperationTransformation.concurrentReplacements;
    diag = function() {
      var args;
      args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return console.log.apply(console, args);
    };
    Peer = (function() {
      function Peer() {
        this.data = new OrgData();
        this.clearChanges();
        this.pendingReplaces = [];
        this.pendingCount = 0;
        this.unreplacements = [];
        this.batchCallbacks = [];
        this.dataFilter = {
          __proto__: basicDataFilter,
          endChange: (function(_this) {
            return function() {
              return _this.dataFinishedChange;
            };
          })(this),
          clear: (function(_this) {
            return function() {
              return _this.dataClear;
            };
          })(this),
          replaceBlock: (function(_this) {
            return function(data, oldBlock, newBlock) {
              return _this.recordChange(_this.peerChanges, oldBlock, newBlock);
            };
          })(this)
        };
        this.version = -1;
        this.successiveChanges = 0;
        this.lastReplace = null;
        this.localChangeLimit = 3;
        this.replacementAckLimit = 5;
        this.incomingReplacementCount = 0;
        this.docSnap = null;
        this.solo = true;
      }

      Peer.prototype.clearChanges = function() {
        return this.incomingReplaces = [];
      };

      Peer.prototype.recordChange = function(changes, oldBlock, newBlock) {
        if (!newBlock) {
          changes.removes[oldBlock._id] = true;
          return delete changes.sets[oldBlock._id];
        } else {
          delete changes.removes[newBlock._id];
          return changes.sets[newBlock._id] = true;
        }
      };

      Peer.prototype.recordLocalChanges = function(oldBlocks, newBlocks) {
        var block, id, newIds, ref1, results;
        newIds = _.indexBy(newBlocks, '_id');
        ref1 = _.indexBy(oldBlocks, '_id');
        for (id in ref1) {
          block = ref1[id];
          if (!newIds[id]) {
            this.recordChange(this.localChanges, block, null);
          }
        }
        results = [];
        for (id in newIds) {
          block = newIds[id];
          results.push(this.recordChange(this.localChanges, null, block));
        }
        return results;
      };

      Peer.prototype.setEditor = function(editor) {
        this.editor = editor;
      };

      Peer.prototype.disconnect = function() {
        var ref1;
        if ((ref1 = this.con) != null) {
          ref1.close();
        }
        return this.con = null;
      };

      Peer.prototype.subsumesIncoming = function(cur, next) {
        var ref1;
        return next.mine && (!cur || next.pendingCount > ((ref1 = cur.pendingCount) != null ? ref1 : -1) || ((cur.pendingCount == null) && next.messageCount > cur.messageCount));
      };

      Peer.prototype.rollback = function(track) {
        var i, oldText, ref1, repl, seq;
        if (track) {
          seq = sequentialReplacements((function() {
            var i, ref1, results;
            ref1 = this.unreplacements;
            results = [];
            for (i = ref1.length - 1; i >= 0; i += -1) {
              repl = ref1[i];
              results.push(repl);
            }
            return results;
          }).call(this));
          oldText = seq.initialBounds();
          oldText.text = this.data.getDocSubstring(oldText.start, oldText.end);
        } else {
          oldText = null;
        }
        ref1 = this.unreplacements;
        for (i = ref1.length - 1; i >= 0; i += -1) {
          repl = ref1[i];
          this.data.replaceText(repl.start, repl.end, repl.text);
        }
        this.unreplacements = [];
        return oldText;
      };

      Peer.prototype.applyIncomingChanges = function(changes) {
        var myLast, myLatest, myPos, reps;
        myPos = -1;
        myLatest = null;
        myLast = _.last(this.pendingReplaces);
        reps = changes || this.incomingReplaces.concat(this.pendingReplaces);
        return preserveSelection((function(_this) {
          return function(range) {
            var act, bounds, exp, oldText, seq, txt;
            oldText = _this.rollback(_this.solo);
            runReplacements(reps, function(start, end, text, cookies, node) {
              var err, i, inRepl, len, ref1;
              _this.pushUnreplacement(start, end, text);
              try {
                _this.data.replaceText(start, end, text);
              } catch (_error) {
                err = _error;
                console.log(err);
              }
              if (!changes) {
                for (i = 0, len = cookies.length; i < len; i++) {
                  inRepl = cookies[i];
                  if (inRepl === myLast || (inRepl !== myLast && _this.subsumesIncoming(myLatest, inRepl))) {
                    myPos = start + text.length;
                    myLatest = inRepl;
                  }
                }
                if (end <= range.start) {
                  return range.start += text.length - end + start;
                } else if ((start <= (ref1 = range.start) && ref1 < end)) {
                  return range.start = start + text.length;
                }
              }
            });
            if (_this.solo && !changes) {
              if (oldText && (txt = _this.data.getDocSubstring(oldText.start, oldText.end)) !== oldText.text) {
                console.log("BAD REPLACEMENT, EXPECTED:\n" + (oldText.text.replace(/$/, '$')) + "\n BUT GOT:\n" + (txt.replace(/$/, '$')));
                console.log("REPLACEMENT DUMP FOLLOWS...\n" + (replacementsString(reps)));
                console.log("Replacements:", reps);
              } else {
                seq = new SequentialReplacements();
                runReplacements(reps, function(start, end, text) {
                  return seq.replace({
                    start: start,
                    end: end,
                    text: text
                  });
                });
                bounds = seq.finalBounds();
                if ((exp = _this.docSnap.substring(bounds.start, bounds.end)) !== (act = _this.data.getDocSubstring(bounds.start, bounds.end))) {
                  console.log("BAD REPLACEMENT, EXPECTED:\n" + (exp.replace(/$/, '$')) + "\n BUT GOT:\n" + (act.replace(/$/, '$')));
                  console.log("REPLACEMENT DUMP FOLLOWS...\n" + (replacementsString(reps)));
                  console.log("Replacements:", reps);
                }
              }
            }
            if (myPos > -1) {
              range.start = myPos;
              return range.length = 0;
            }
          };
        })(this));
      };

      Peer.prototype.nodeLabel = function(node) {
        var cookie, hasIncoming, hasPending, i, j, len, len1, op, ref1, ref2;
        hasPending = false;
        hasIncoming = false;
        ref1 = node.activeOperations;
        for (i = 0, len = ref1.length; i < len; i++) {
          op = ref1[i];
          ref2 = op.cookies;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            cookie = ref2[j];
            if (op.pendingCount) {
              hasPending = true;
            } else {
              hasIncoming = true;
            }
          }
        }
        if (hasIncoming && hasPending) {
          return "P/I";
        } else if (hasIncoming) {
          return "IN ";
        } else {
          return "PEN";
        }
      };

      Peer.prototype.connect = function(url, connectedFunc) {
        var peer;
        this.url = url;
        this.connectedFunc = connectedFunc;
        this.con = new SockJS(this.url);
        this.con.onmessage = (function(_this) {
          return function(msg) {
            return _this.handleMessage(JSON.parse(msg.data));
          };
        })(this);
        this.con.onclose = (function(_this) {
          return function() {
            return _this.closed();
          };
        })(this);
        peer = this;
        return changeAdvice(this.editor.options, true, {
          editBlocks: {
            p2p: (function(_this) {
              return function(parent) {
                return function(blocks, start, length, newContent, select) {
                  _this.editingReplacement = {
                    blocks: blocks,
                    start: start,
                    length: length,
                    text: newContent
                  };
                  parent(blocks, start, length, newContent, select);
                  return _this.editingReplacement = null;
                };
              };
            })(this)
          },
          changesFor: {
            p2p: function(parent) {
              return function(first, oldBlocks, newBlocks, verbatim) {
                var changes;
                changes = parent(first, oldBlocks, newBlocks, verbatim);
                peer.sendReplace(changes);
                return changes;
              };
            }
          },
          batchReplace: {
            p2p: function(parent) {
              return function(replacementsFunc, contFunc, errFunc) {
                return peer.runBatchReplace(replacementsFunc, contFunc, errFunc);
              };
            }
          }
        });
      };

      Peer.prototype.type = 'Unknown Handler';

      Peer.prototype.close = function() {
        console.log("CLOSING: " + this.type);
        return this.con.close();
      };

      Peer.prototype.closed = function() {
        return changeAdvice(this.editor.options, false, {
          changesFor: {
            p2p: true
          }
        });
      };

      Peer.prototype.send = function(type, msg) {
        msg.type = type;
        return this.con.send(JSON.stringify(msg));
      };

      Peer.prototype.runBatchReplace = function(replacementsFunc, contFunc, errFunc) {};

      Peer.prototype.sendReplace = function(arg) {
        var newBlocks, newRepl, offset, oldBlocks, repl, start;
        oldBlocks = arg.oldBlocks, newBlocks = arg.newBlocks;
        this.incomingReplacementCount = 0;
        offset = this.data.offsetForBlock(oldBlocks[0]);
        repl = this.editingReplacement ? (start = offset + this.editingReplacement.start, {
          start: start,
          end: start + this.editingReplacement.length,
          text: this.editingReplacement.text
        }) : replacementFor(offset, blockText(oldBlocks), blockText(newBlocks));
        repl.type = 'replace';
        repl.version = this.version;
        repl.connectionId = this.connectionId;
        this.pushUnreplacement(repl.start, repl.end, repl.text);
        this.logReplacement("OUT R ", repl.start, repl.end, repl.text);
        this.pendingReplaces.push(newRepl = _.merge({
          mine: true,
          pendingCount: ++this.pendingCount
        }, repl));
        this.send('replace', repl);
        if (this.solo) {
          return this.docSnap = this.docSnap.substring(0, repl.start) + repl.text + this.docSnap.substring(repl.end);
        }
      };

      Peer.prototype.logReplacement = function(label, start, end, text) {};

      Peer.prototype.pushUnreplacement = function(start, end, text) {
        return this.unreplacements.push({
          start: start,
          end: start + text.length,
          text: this.data.getDocSubstring(start, end)
        });
      };

      Peer.prototype.handleMessage = function(msg) {
        msg.mine = msg.connectionId === this.connectionId || msg.type === 'echo';
        if (!(msg.type in this.handler)) {
          console.log("Received bad message " + msg.type, msg);
          return this.close();
        } else {
          return this.handler[msg.type].call(this, msg);
        }
      };

      Peer.prototype.handler = {
        log: function(msg) {
          return console.log(msg.msg);
        },
        connect: function(msg) {
          this.id = msg.id, this.connectionId = msg.connectionId, this.version = msg.version;
          this.clearChanges();
          if (typeof this.connectedFunc === "function") {
            this.connectedFunc(this);
          }
          return this.connectedFunc = null;
        },
        error: function(msg) {
          console.log("Received error: " + msg.error, msg);
          return this.close();
        },
        rejectChange: function() {},
        echo: function(msg) {
          var pending;
          pending = this.pendingReplaces.shift();
          pending.messageCount = msg.messageCount;
          pending.connectionId = this.connectionId;
          return this.handleMessage(pending);
        },
        conditionalReplace: function(arg) {
          var replacements, version;
          replacements = arg.replacements, version = arg.version;
          return preserveSelection((function(_this) {
            return function(range) {
              var end, i, len, offset, ref1, repl, start;
              offset = 0;
              for (i = 0, len = replacements.length; i < len; i++) {
                repl = replacements[i];
                start = repl.start, end = repl.end;
                start += offset;
                end += offset;
                if (end <= range.start) {
                  range.start += text.length - end + start;
                } else if ((start <= (ref1 = range.start) && ref1 < end)) {
                  range.start = start + text.length;
                }
                offset += repl.text.length - repl.end + repl.start;
              }
              return _this.replaceBatch(replacements);
            };
          })(this));
        },
        replace: function(msg) {
          var ref1;
          if (msg.connectionId !== this.connectionId) {
            this.solo = false;
            this.docSnap = null;
          }
          if (this.successiveChanges < 2 && msg.mine && ((ref1 = this.lastReplace) != null ? ref1.mine : void 0)) {
            this.successiveChanges++;
          } else {
            this.version = msg.messageCount;
            this.successiveChanges = 0;
          }
          if (!msg.mine && ++this.incomingReplacementCount > this.replacementAckLimit) {
            this.incomingReplacementCount = 0;
            this.send('ack', {
              version: this.version
            });
          }
          this.lastReplace = msg;
          this.incomingReplaces.push(msg);
          return this.applyIncomingChanges();
        },
        trimVersions: function(arg) {
          var i, len, op, pos, ref1, results, version;
          version = arg.version;
          ref1 = this.incomingReplaces;
          results = [];
          for (pos = i = 0, len = ref1.length; i < len; pos = ++i) {
            op = ref1[pos];
            if (op.messageCount >= version) {
              if (pos > 0) {
                preserveSelection((function(_this) {
                  return function() {
                    console.log("TRIMMING " + pos + " versions");
                    _this.applyIncomingChanges(_this.incomingReplaces.slice(0, pos));
                    _this.unreplacements = [];
                    _this.incomingReplaces = _this.incomingReplaces.slice(pos);
                    return _this.applyIncomingChanges();
                  };
                })(this));
              }
              break;
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      };

      Peer.prototype.replaceBatch = function(replacements) {
        return this.data.batchReplace(replacements);
      };

      Peer.prototype.createSession = function(host, connectedFunc) {
        this.host = host;
        this.connectedFunc = connectedFunc;
        this.type = 'Master';
        this.handler = {
          __proto__: Peer.prototype.handler,
          connect: function(msg) {
            this.connectUrl = new URL("slave-" + msg.id, this.url);
            Peer.prototype.handler.connect.call(this, msg);
            return this.send('initDoc', {
              doc: this.data.getText()
            });
          },
          slaveConnect: function(msg) {
            return this.send('slaveApproval', {
              slaveId: msg.slaveId,
              approval: true
            });
          },
          slaveDisconnect: function(msg) {}
        };
        this.connect("http://" + this.host + "/Leisure/master", this.connectedFunc);
        return this.docSnap = this.data.getText();
      };

      Peer.prototype.connectToSession = function(url, connected) {
        this.url = url;
        this.type = 'Slave';
        this.handler = {
          __proto__: Peer.prototype.handler,
          connect: function(msg) {
            Peer.prototype.handler.connect.call(this, msg);
            this.editor.options.load(msg.doc);
            return this.docSnap = msg.doc;
          }
        };
        return this.connect(this.url, connected);
      };

      return Peer;

    })();
    replacementFor = function(start, oldText, newText) {
      var end, endOff, i, j, ref1, ref2, ref3, startOff;
      end = start + ((ref1 = oldText.length) != null ? ref1 : 0);
      for (startOff = i = 0, ref2 = Math.min(oldText.length, newText.length); 0 <= ref2 ? i < ref2 : i > ref2; startOff = 0 <= ref2 ? ++i : --i) {
        if (oldText[startOff] !== newText[startOff]) {
          break;
        }
      }
      start += startOff;
      for (endOff = j = 0, ref3 = Math.min(oldText.length - startOff - 1, newText.length - startOff - 1); j <= ref3; endOff = j += 1) {
        if (oldText[oldText.length - endOff - 1] !== newText[newText.length - endOff - 1]) {
          break;
        }
      }
      return {
        start: start,
        end: end - endOff,
        text: (startOff || endOff ? newText.substring(startOff, newText.length - endOff) : '')
      };
    };
    $(document).ready(function() {
      var connected, join;
      if (document.location.search.length > 1 && !connected) {
        connected = true;
        join = getDocumentParams().join;
        if (join) {
          return setTimeout((function() {
            var createSessionButton, u;
            createSessionButton = $(editorToolbar(window.PEER.editor.node)).find('[name=p2pConnector] [name=createSession]');
            createSessionButton.data({
              hasSession: true
            });
            createSessionButton.closest('.contents').removeClass('not-connected');
            createSessionButton.closest('.contents').addClass('connected');
            createSessionButton.button('option', 'label', 'Disconnect');
            console.log("CREATE SESSION:", createSessionButton[0]);
            u = new URL(join);
            console.log("JOIN SESSION: " + u);
            return window.PEER.connectToSession(u.toString());
          }), 1);
        }
      }
    });
    return {
      Peer: Peer
    };
  });

}).call(this);

//# sourceMappingURL=p2p.js.map
