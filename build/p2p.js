// Generated by CoffeeScript 1.9.3
(function() {
  define(['jquery', 'immutable', 'cs!./lib/webrtc.litcoffee', 'lib/cycle', 'cs!./editor.litcoffee', 'cs!./editorSupport.litcoffee', 'sockjs', 'cs!./hamtData.litcoffee', './lib/fingertree', 'cs!./advice.litcoffee'], function(jq, immutable, Peer, cycle, Editor, Support, SockJS, HamtData, Fingertree, Advice) {
    var DataStore, HamtOrgData, Map, MasterConnection, OrgData, PeerConnection, Set, SlaveConnection, afterMethod, basicDataFilter, blockText, callOriginal, changeAdvice, computeNewStructure, editorToolbar, getDocumentParams, preserveSelection, ref, replacementFor, validateBatch;
    ref = window.Immutable = immutable, Map = ref.Map, Set = ref.Set;
    PeerConnection = Peer.PeerConnection, MasterConnection = Peer.MasterConnection, SlaveConnection = Peer.SlaveConnection;
    DataStore = Editor.DataStore, preserveSelection = Editor.preserveSelection, blockText = Editor.blockText, computeNewStructure = Editor.computeNewStructure, validateBatch = Editor.validateBatch;
    OrgData = Support.OrgData, getDocumentParams = Support.getDocumentParams, editorToolbar = Support.editorToolbar, basicDataFilter = Support.basicDataFilter;
    HamtOrgData = HamtData.HamtOrgData;
    changeAdvice = Advice.changeAdvice, afterMethod = Advice.afterMethod, callOriginal = Advice.callOriginal;
    Peer = (function() {
      function Peer() {
        this.data = new HamtOrgData();
        this.clearChanges();
        this.dataFilter = {
          __proto__: basicDataFilter,
          endChange: (function(_this) {
            return function() {
              return _this.dataFinishedChange;
            };
          })(this),
          clear: (function(_this) {
            return function() {
              return _this.dataClear;
            };
          })(this),
          replaceBlock: (function(_this) {
            return function(data, oldBlock, newBlock) {
              if (!newBlock) {
                _this.peerChanges.removes[oldBlock._id] = true;
                return delete _this.peerChanges.sets[oldBlock._id];
              } else {
                delete _this.peerChanges.removes[newBlock._id];
                return _this.peerChanges.sets[newBlock._id] = true;
              }
            };
          })(this)
        };
        this.change = -1;
      }

      Peer.prototype.clearChanges = function() {
        this.changedBlocks = new Set();
        this.pendingReplaces = [];
        this.batchCallbacks = [];
        this.localChanges = {
          sets: {},
          removes: {}
        };
        return this.peerChanges = {
          sets: {},
          removes: {}
        };
      };

      Peer.prototype.checkPendingData = function() {
        if (!this.hasPendingReplaces() && this.changedBlocks.isEmpty()) {
          this.incomingData = this.data.snapshot();
          return this.incomingData.addFilter(this.dataFilter);
        }
      };

      Peer.prototype.setEditor = function(editor) {
        this.editor = editor;
      };

      Peer.prototype.disconnect = function() {
        var ref1;
        if ((ref1 = this.con) != null) {
          ref1.close();
        }
        return this.con = null;
      };

      Peer.prototype.hasPendingReplaces = function() {
        return this.pendingReplaces.length;
      };

      Peer.prototype.connect = function(url, connectedFunc) {
        var peer;
        this.url = url;
        this.connectedFunc = connectedFunc;
        this.con = new SockJS(this.url);
        this.con.onmessage = (function(_this) {
          return function(msg) {
            return _this.handleMessage(JSON.parse(msg.data));
          };
        })(this);
        this.con.onclose = (function(_this) {
          return function() {
            return _this.closed();
          };
        })(this);
        peer = this;
        return changeAdvice(this.editor.options, true, {
          changesFor: {
            p2p: function(parent) {
              return function(first, oldBlocks, newBlocks, verbatim) {
                peer.sendReplace(parent(first, oldBlocks, newBlocks, verbatim));
                peer.recordLocalChange(oldBlocks, newBlocks);
                return null;
              };
            }
          },
          batchReplace: {
            p2p: function(parent) {
              return function(replacementsFunc, contFunc, errFunc) {
                return peer.runBatchReplace(replacementsFunc, contFunc, errFunc);
              };
            }
          }
        });
      };

      Peer.prototype.type = 'Unknown Handler';

      Peer.prototype.recordLocalChange = function(oldBlocks, newBlocks) {
        var block, id, newIds, results;
        newIds = _.indexBy(newBlocks, '_id');
        for (id in _.indexBy(oldBlocks, '_id')) {
          if (!newIds[id]) {
            this.localChanges.removes[id] = true;
            delete this.localChanges.sets[id];
          }
        }
        results = [];
        for (id in newIds) {
          block = newIds[id];
          delete this.localChanges.removes[id];
          results.push(this.localChanges.sets[id] = true);
        }
        return results;
      };

      Peer.prototype.close = function() {
        console.log("CLOSING: " + this.type);
        return this.con.close();
      };

      Peer.prototype.closed = function() {
        return changeAdvice(this.editor.options, false, {
          changesFor: {
            p2p: true
          }
        });
      };

      Peer.prototype.send = function(type, msg) {
        msg.type = type;
        return this.con.send(JSON.stringify(msg));
      };

      Peer.prototype.runBatchReplace = function(replacementsFunc, contFunc, errFunc) {
        var err, msg, pushedCallbacks, pushedReplaces, replacements;
        try {
          replacements = validateBatch(replacementsFunc());
          msg = {
            type: 'conditionalReplace',
            replacements: replacements,
            targetChange: this.change
          };
          this.pendingReplaces.push(msg);
          pushedReplaces = true;
          this.batchCallbacks.push([
            contFunc, ((function(_this) {
              return function() {
                return _this.runBatchReplace(replacementsFunc, contFunc, errFunc);
              };
            })(this)), errFunc
          ]);
          pushedCallbacks = true;
          return this.send('conditionalReplace', msg);
        } catch (_error) {
          err = _error;
          if (pushedReplaces) {
            this.pendingReplaces.pop();
          }
          if (pushedCallbacks) {
            this.batchCallbacks.pop();
          }
          return errFunc(err);
        }
      };

      Peer.prototype.sendReplace = function(arg) {
        var newBlocks, offset, oldBlocks, repl;
        oldBlocks = arg.oldBlocks, newBlocks = arg.newBlocks;
        offset = this.data.offsetForBlock(oldBlocks[0]);
        repl = replacementFor(offset, blockText(oldBlocks), blockText(newBlocks));
        repl.context = this.editor.options.changeContext;
        repl.type = 'replace';
        this.pendingReplaces.push(repl);
        return this.send('replace', repl);
      };

      Peer.prototype.handleMessage = function(msg) {
        if (!(msg.type in this.handler)) {
          console.log("Received bad message " + msg.type, msg);
          return this.close();
        } else {
          return this.handler[msg.type].call(this, msg);
        }
      };

      Peer.prototype.handler = {
        log: function(msg) {
          return console.log(msg.msg);
        },
        connect: function(msg) {
          this.id = msg.id, this.connectionId = msg.connectionId, this.change = msg.change;
          if (typeof this.connectedFunc === "function") {
            this.connectedFunc(this);
          }
          return this.connectedFunc = null;
        },
        error: function(msg) {
          console.log("Received error: " + msg.error, msg);
          return this.close();
        },
        rejectChange: function() {
          this.pendingReplaces.shift();
          return this.batchCallbacks.pop()[1]();
        },
        echo: function(msg) {
          var err, pending;
          this.change = msg.change;
          pending = this.pendingReplaces.shift();
          if (pending.type === 'conditionalReplace') {
            try {
              this.replaceBatch(pending.replacements);
              return this.batchCallbacks.pop()[0]();
            } catch (_error) {
              err = _error;
              return this.batchCallbacks.pop()[2](err);
            }
          } else {
            pending.connectionId = this.connectionId;
            pending.change = this.change;
            return this.handleMessage(pending);
          }
        },
        conditionalReplace: function(arg) {
          var replacements;
          replacements = arg.replacements, this.change = arg.change;
          return preserveSelection((function(_this) {
            return function(range) {
              var end, i, len, offset, ref1, repl, start;
              offset = 0;
              for (i = 0, len = replacements.length; i < len; i++) {
                repl = replacements[i];
                start = repl.start, end = repl.end;
                start += offset;
                end += offset;
                if (end <= range.start) {
                  range.start += text.length - end + start;
                } else if ((start <= (ref1 = range.start) && ref1 < end)) {
                  range.start = start + text.length;
                }
                offset += repl.text.length - repl.end + repl.start;
              }
              return _this.replaceBatch(replacements);
            };
          })(this));
        },
        replace: function(arg) {
          var connectionId, context, end, range, start, text;
          start = arg.start, end = arg.end, text = arg.text, context = arg.context, connectionId = arg.connectionId, this.change = arg.change;
          if (context) {
            this.editor.options.mergeChangeContext(context);
          }
          if (connectionId === this.connectionId) {
            range = this.editor.getSelectedDocRange();
            this.replaceText(start, end, text);
            range.start = start + text.length;
            range.length = 0;
            this.editor.selectDocRange(range);
          } else {
            preserveSelection((function(_this) {
              return function(range) {
                var ref1;
                if (end <= range.start) {
                  range.start += text.length - end + start;
                } else if ((start <= (ref1 = range.start) && ref1 < end)) {
                  range.start = start + text.length;
                }
                return _this.replaceText(start, end, text);
              };
            })(this));
          }
          return this.editor.options.clearChangeContext();
        }
      };

      Peer.prototype.replaceBatch = function(replacements) {
        this.data.batchReplace(replacements);
        return this.incomingData.batchReplace(replacements);
      };

      Peer.prototype.replaceText = function(start, end, text) {
        this.data.replaceText(start, end, text);
        return this.incomingData.replaceText(start, end, text);
      };

      Peer.prototype.createSession = function(host, connectedFunc) {
        this.host = host;
        this.connectedFunc = connectedFunc;
        this.checkPendingData();
        this.type = 'Master';
        this.handler = {
          __proto__: Peer.prototype.handler,
          connect: function(msg) {
            this.connectUrl = new URL("slave-" + msg.id, this.url);
            Peer.prototype.handler.connect.call(this, msg);
            return this.send('initDoc', {
              doc: this.data.getText()
            });
          },
          slaveConnect: function(msg) {
            return this.send('slaveApproval', {
              slaveId: msg.slaveId,
              approval: true
            });
          },
          slaveDisconnect: function(msg) {}
        };
        return this.connect("http://" + this.host + "/Leisure/master", this.connectedFunc);
      };

      Peer.prototype.connectToSession = function(url, connected) {
        this.url = url;
        this.type = 'Slave';
        this.handler = {
          __proto__: Peer.prototype.handler,
          connect: function(msg) {
            Peer.prototype.handler.connect.call(this, msg);
            this.editor.options.load(msg.doc);
            this.clearChanges();
            return this.checkPendingData();
          }
        };
        return this.connect(this.url, connected);
      };

      return Peer;

    })();
    replacementFor = function(start, oldText, newText) {
      var end, endOff, i, j, ref1, ref2, ref3, startOff;
      end = start + ((ref1 = oldText.length) != null ? ref1 : 0);
      for (startOff = i = 0, ref2 = Math.min(oldText.length, newText.length); 0 <= ref2 ? i < ref2 : i > ref2; startOff = 0 <= ref2 ? ++i : --i) {
        if (oldText[startOff] !== newText[startOff]) {
          break;
        }
      }
      start += startOff;
      for (endOff = j = 0, ref3 = Math.min(oldText.length - startOff - 1, newText.length - startOff - 1); j <= ref3; endOff = j += 1) {
        if (oldText[oldText.length - endOff - 1] !== newText[newText.length - endOff - 1]) {
          break;
        }
      }
      return {
        start: start,
        end: end - endOff,
        text: (startOff || endOff ? newText.substring(startOff, newText.length - endOff) : '')
      };
    };
    $(document).ready(function() {
      var connected, join;
      if (document.location.search.length > 1 && !connected) {
        connected = true;
        join = getDocumentParams().join;
        if (join) {
          return setTimeout((function() {
            var createSessionButton, u;
            createSessionButton = $(editorToolbar(window.PEER.editor.node)).find('[name=p2pConnector] [name=createSession]');
            createSessionButton.data({
              hasSession: true
            });
            createSessionButton.closest('.contents').removeClass('not-connected');
            createSessionButton.closest('.contents').addClass('connected');
            createSessionButton.button('option', 'label', 'Disconnect');
            console.log("CREATE SESSION:", createSessionButton[0]);
            u = new URL(join);
            console.log("JOIN SESSION: " + u);
            return window.PEER.connectToSession(u.toString());
          }), 1);
        }
      }
    });
    return {
      Peer: Peer
    };
  });

}).call(this);

//# sourceMappingURL=p2p.js.map
