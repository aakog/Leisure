// Generated by CoffeeScript 2.2.4
(function() {
  /*
  Copyright (C) 2013, Bill Burdick, Tiny Concepts: https://github.com/zot/Leisure

  (licensed with ZLIB license)

  This software is provided 'as-is', without any express or implied
  warranty. In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
  claim that you wrote the original software. If you use this software
  in a product, an acknowledgment in the product documentation would be
  appreciated but is not required.

  2. Altered source versions must be plainly marked as such, and must not be
  misrepresented as being the original software.

  3. This notice may not be removed or altered from any source distribution.
  */
  'use strict';
  define(['./base', './ast', './runtime', 'lodash', 'lib/source-map', 'browser-source-map-support', 'lib/js-yaml'], function(Base, Ast, Runtime, _, SourceMap, SourceMapSupport, Yaml) {
    var CodeGenerator, Leisure_anno, Leisure_apply, Leisure_lambda, Leisure_let, Leisure_lit, Leisure_ref, Monad2, Nil, SourceMapConsumer, SourceMapGenerator, SourceNode, USE_STRICT, _false, _true, addDebugType, addLambdaProperties, addUniq, arrayify, assocListProps, ast2Json, booleanFor, check, checkChild, codeNum, collectArgs, cons, consFrom, curDef, currentFile, currentFuncName, curryCall, define, dump, dumpAnno, dumpMonadStack, findName, functionId, functionInfo, gen, genMap, genSource, getAnnoBody, getAnnoData, getAnnoName, getApplyArg, getApplyFunc, getAssocListProps, getDebugType, getLambdaArgs, getLambdaBody, getLambdaProperties, getLambdaVar, getLastLetBody, getLetBody, getLetName, getLetValue, getLitVal, getNArgs, getNthLambdaBody, getPos, getRefName, getType, isNil, isResolved, jsCodeFor, jstr, lacons, lazify, lazy, lc, lcons, lconsFrom, left, letList, locateAst, location, lz, megaArity, nameSub, newConsFrom, nsLog, parseErr, rangeToJson, ref1, resolve, right, root, rz, setDataType, setDebugType, setMegaArity, setType, simpyCons, sn, specialAnnotations, stackSize, trace, uniqName, unit, useArity, varNameSub, verboseMsg, withFile;
    //SourceMapSupport?.install()
    ({simpyCons, resolve, lazy, verboseMsg, nsLog, isResolved, addDebugType, getDebugType, setDebugType} = Base);
    ({dump} = Yaml);
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    ({nameSub, getLitVal, getRefName, getLambdaVar, getLambdaBody, getApplyFunc, getApplyArg, getAnnoName, getAnnoData, getAnnoBody, getLetName, getLetValue, getLetBody, Leisure_lit, Leisure_ref, Leisure_lambda, Leisure_apply, Leisure_let, Leisure_anno, setType, setDataType, cons, Nil, define, functionInfo, getPos, isNil, getType, ast2Json, rangeToJson, getPos} = root = Ast);
    ({Monad2, _true, _false, unit, left, right, booleanFor, newConsFrom, dumpMonadStack} = Runtime);
    consFrom = newConsFrom;
    ({SourceNode, SourceMapConsumer, SourceMapGenerator} = SourceMap);
    varNameSub = function(n) {
      return `L_${nameSub(n)}`;
    };
    useArity = true;
    megaArity = false;
    curDef = null;
    //trace = false
    trace = true;
    stackSize = 20;
    USE_STRICT = '"use strict";\n';
    //USE_STRICT = ''
    setMegaArity = function(setting) {
      return megaArity = setting;
    };
    setDebugType('User');
    //########
    // Code
    //########
    setDebugType = function(type) {
      addDebugType(type);
      return Base.setDebugType(type);
    };
    collectArgs = function(args, result) {
      var i, j, len;
      for (j = 0, len = args.length; j < len; j++) {
        i = args[j];
        if (Array.isArray(i)) {
          collectArgs(i, result);
        } else {
          result.push(i);
        }
      }
      return result;
    };
    locateAst = function(ast) {
      var col, line, pos;
      [line, col] = pos = getPos(ast).toArray();
      return [line, col];
    };
    check = function(bool, arg) {
      if (!bool) {
        return console.log(new Error(`Bad sourcemap arg: ${arg}`).stack);
      }
    };
    checkChild = function(child) {
      if (Array.isArray(child)) {
        return child.forEach(checkChild);
      } else {
        return check((typeof child === 'string') || (child instanceof SourceNode), child);
      }
    };
    currentFile = 'NEVERGIVENFILE.lsr';
    currentFuncName = void 0;
    withFile = function(file, name, block) {
      var oldFileName, oldFuncName;
      oldFileName = currentFile;
      oldFuncName = currentFuncName;
      currentFile = file;
      currentFuncName = name;
      try {
        return block();
      } finally {
        currentFile = oldFileName;
        currentFuncName = oldFuncName;
      }
    };
    sn = function(ast, ...str) {
      var line, offset;
      [line, offset] = locateAst(ast);
      check(typeof line === 'number', 'line');
      check(typeof offset === 'number', 'offset');
      checkChild(str);
      if (line < 1) {
        line = 1;
      }
      if (currentFile === 'NEVERGIVENFILE.lsr') {
        console.log(new Error("SN CALLED WITHOUT FILE").stack);
      }
      if (currentFuncName != null) {
        return new SourceNode(line, offset, currentFile, str, currentFuncName);
      } else {
        return new SourceNode(line, offset, currentFile, str);
      }
    };
    jstr = function(str) {
      return JSON.stringify(str);
    };
    jsCodeFor = function(codeMap, mapType, externalMap) {
      var code;
      code = codeMap.code;
      if (mapType === 'inline') {
        code = code.replace(/map: '@SOURCEMAP@'/, 'inlineMap: ' + jstr(codeMap.map.toJSON()));
      } else if (mapType === 'external') {
        code = code.replace(/map: '@SOURCEMAP@'/, 'externalMap: ' + jstr(externalMap));
      }
      //"#{code}\n//# sourceMappingURL=data:application/json;base64,#{btoa jstr codeMap.map.toJSON()}\n"
      return `${code}\n//# sourceMappingURL=data:application/json,${jstr(codeMap.map.toJSON())}\n`;
    };
    functionId = 0;
    codeNum = 0;
    CodeGenerator = class CodeGenerator {
      constructor(fileName, useContext, noFile, suppressContextCreation, source1) {
        this.useContext = useContext;
        this.noFile = noFile;
        this.suppressContextCreation = suppressContextCreation;
        this.source = source1;
        this.debugType = getDebugType();
        this.fileName = fileName != null ? fileName : `dynamic code with source ${++codeNum}`;
        this.startId = functionId;
        this.positions = [];
        this.createContext = !this.suppressContextCreation;
        this.decls = [];
        this.declStack = [];
        this.funcInfo = [];
        this.debug = false;
      }

      contextInit() {
        if (this.useContext) {
          return '\n  L$F.context = L_$context;';
        } else {
          return '';
        }
      }

      funcVar(index) {
        return `L$FUNC_${index}`;
      }

      addFuncInfo(info) {
        info.funcId = this.funcInfo.length;
        this.funcInfo.push(info);
        return this.funcVar(info.funcId);
      }

      decl(ast, dec) {
        var col, line;
        if (this.debug) {
          dec.id = this.decls.length;
          [line, col] = getPos(ast).toArray();
          dec.line = line;
          dec.col = col;
          if (this.declStack.length) {
            dec.parent = _.last(this.declStack).id;
          }
          this.decls.push(dec);
          return this.declStack.push(dec);
        }
      }

      declLazy(ast, arg) {
        var result;
        this.decl(ast, {
          lazy: true
        });
        if (arg != null) {
          result = arg();
          this.popDecl();
          return result;
        }
      }

      declLambda(ast, name, args) {
        var dec, info, varName;
        this.decl(ast, dec = {
          lambda: name,
          args: args
        });
        varName = this.addFuncInfo(info = {
          length: args.length,
          name,
          args,
          parent: dec.parent,
          id: dec.id
        });
        dec.funcId = info.funcId;
        return varName;
      }

      popDecl() {
        if (this.debug) {
          return this.declStack.pop();
        }
      }

      genSource(source, ast) {
        var funcName, map, result, sm;
        if (this.noFile) {
          sm = this.genNode(ast).prepend(USE_STRICT + '(').add(')').toStringWithSourceMap({
            file: this.fileName
          });
          map = JSON.parse(sm.map.toString());
          result = sm.code;
        } else {
          funcName = ast instanceof Leisure_anno && getAnnoName(ast) === 'leisureName' ? getAnnoData(ast) : null;
          //fileName = "dynamic code with source #{++codeNum}"
          withFile(this.fileName, funcName, () => {
            var err;
            try {
              sm = this.genNode(ast).toStringWithSourceMap({
                file: this.fileName
              });
              map = JSON.parse(sm.map.toString());
              map.sourcesContent = [source];
              return result = sm.code;
            } catch (error) {
              err = error;
              err.message = `Error generating code for:\n  ${source.trim().replace(/\n/g, '\n  ')}\n${err.message}`;
              throw err;
            }
          });
        }
        this.endId = functionId;
        return jsCodeFor(sm, 'inline');
      }

      genNode(ast) {
        var result;
        result = this.genUniq(ast, Nil, [Nil, 0]);
        this.endId = functionId;
        return this.genTopLevel(ast, result);
      }

      genMap(ast) {
        var filename, funcname, hasFile, nameAst, sub;
        hasFile = ast instanceof Leisure_anno && getAnnoName(ast) === 'filename';
        //filename = if hasFile then getAnnoData ast else 'GENFORUNKNOWNFILE.lsr'
        filename = hasFile ? getAnnoData(ast) : this.fileName;
        nameAst = hasFile ? getAnnoBody(ast) : null;
        funcname = nameAst instanceof Leisure_anno && getAnnoName(nameAst) === 'leisureName' ? getAnnoData(nameAst) : currentFuncName;
        sub = withFile(filename, null, () => {
          return this.genNode(ast);
        });
        this.endId = functionId;
        if (!funcname) {
          return sub;
        } else {
          return withFile(filename, funcname, function() {
            return sn(ast, sub);
          });
        }
      }

      gen(ast) {
        var result;
        result = this.genMap(ast);
        checkChild(result);
        return new SourceNode(1, 0, currentFile, ['(', result, ')']).toStringWithSourceMap({
          file: currentFile
        }).code;
      }

      genUniq(ast, names, uniq) {
        var arity, data, funcName, genned, name, oldDebug, oldDef, src;
        switch (ast.constructor) {
          case Leisure_lit:
            return sn(ast, jstr(getLitVal(ast)));
          case Leisure_ref:
            return sn(ast, "resolve(", this.genRefName(ast, uniq, names, true), ")");
          case Leisure_lambda:
            return this.genLambda(ast, names, uniq);
          case Leisure_apply:
            if (useArity) {
              return this.genArifiedApply(ast, names, uniq);
            } else {
              return sn(ast, this.genUniq(getApplyFunc(ast), names, uniq), "(", this.genApplyArg(getApplyArg(ast), names, uniq), ")");
            }
            break;
          case Leisure_let:
            return sn(ast, "(function(){", this.genLets(ast, names, uniq), "})()");
          case Leisure_anno:
            name = getAnnoName(ast);
            data = getAnnoData(ast);
            if (name === 'arity' && useArity && data > 1) {
              return this.genArifiedLambda(getAnnoBody(ast), names, uniq, data);
            } else {
              try {
                switch (name) {
                  case 'leisureName':
                    oldDef = curDef;
                    curDef = data;
                    break;
                  case 'debug':
                    if (Leisure_generateDebuggingCode) {
                      oldDebug = this.debug;
                      this.debug = true;
                    }
                    break;
                  case 'define':
                    this.declLazy(getAnnoBody(ast));
                }
                genned = this.genUniq(getAnnoBody(ast), names, uniq);
                if (name === 'debug' && Leisure_generateDebuggingCode) {
                  this.debug = oldDebug;
                }
                switch (name) {
                  case 'type':
                    return sn(ast, "setType(", genned, ", '", data, "')");
                  case 'dataType':
                    return sn(ast, "setDataType(", genned, ", '", data, "')");
                  case 'define':
                    [funcName, arity, src] = data.toArray();
                    this.popDecl();
                    return sn(ast, "define('", funcName, "', ", lazify(ast, genned), ", ", arity, ", ", jstr(src), ")");
                  case 'leisureName':
                    return genned;
                  default:
                    return genned;
                }
              } finally {
                if (name === 'leisureName') {
                  curDef = oldDef;
                }
              }
            }
            break;
          default:
            return `CANNOT GENERATE CODE FOR UNKNOWN AST TYPE: ${ast}, ${ast.constructor} ${Leisure_lambda}`;
        }
      }

      genArifiedApply(ast, names, uniq) {
        var argCode, args, arity, defaultArity, dmp, func, funcName, i, info, j, m, ref1, ref2, ref3;
        args = [];
        func = ast;
        while (dumpAnno(func) instanceof Leisure_apply) {
          args.push(getApplyArg(dumpAnno(func)));
          func = getApplyFunc(dumpAnno(func));
        }
        args.reverse();
        defaultArity = false;
        if (args.length > 1 && ((dmp = dumpAnno(func)) instanceof Leisure_ref) && (((info = functionInfo[funcName = getRefName(dmp)]) && ((info.newArity && (arity = info.arity) && arity <= args.length) || (!arity && megaArity))) || (!info && isNil(names.find(function(el) {
          return el === funcName;
        }))))) {
          if (defaultArity = !arity) {
            arity = args.length;
          }
          argCode = [];
          argCode.push(ast);
          if (defaultArity) {
            argCode.push('L$(');
          }
          argCode.push(this.genUniq(func, names, uniq));
          if (defaultArity) {
            argCode.push(')(');
          } else {
            argCode.push('(');
          }
          for (i = j = 0, ref1 = arity; (0 <= ref1 ? j < ref1 : j > ref1); i = 0 <= ref1 ? ++j : --j) {
            if (i > 0) {
              argCode.push(', ');
            }
            argCode.push(sn(args[i], this.genApplyArg(args[i], names, uniq)));
          }
          argCode.push(')');
          for (i = m = ref2 = arity, ref3 = args.length; m < ref3; i = m += 1) {
            argCode.push('(', sn(args[i], this.genApplyArg(args[i], names, uniq)), ')');
          }
          return sn(...argCode);
        } else {
          ast = dumpAnno(ast);
          return sn(ast, this.genUniq(getApplyFunc(ast), names, uniq), "(", this.genApplyArg(getApplyArg(ast), names, uniq), ")");
        }
      }

      genLambda(ast, names, uniq) {
        var argName, bodyCode, code, defName, infoVar, n, name, result, u;
        name = getLambdaVar(ast);
        u = addUniq(name, names, uniq);
        n = cons(name, names);
        argName = uniqName(name, u);
        defName = curDef;
        curDef = null;
        infoVar = this.declLambda(ast, defName, [name]);
        bodyCode = this.genUniq(getLambdaBody(ast), n, u);
        code = sn(ast, `function(${argName}){return `, this.genTraceCall(ast, bodyCode, argName), ";}");
        //addLambdaProperties ast, @genLambdaDecl ast, 'L$F.length', code
        result = this.genLambdaDecl(ast, infoVar, defName, [name], 1, addLambdaProperties(ast, code));
        this.popDecl();
        return result;
      }

      genArifiedLambda(ast, names, uniq, arity) {
        var annoAst, argList, args, bodyCode, code, data, defName, infoVar, name, result;
        if (arity < 2) {
          return this.genLambda(ast, names, uniq, 0);
        } else {
          args = getNArgs(arity, ast).toArray();
          argList = _.map(args, (function(x) {
            return 'L_' + x;
          })).join(', ');
          defName = curDef;
          curDef = null;
          infoVar = this.declLambda(ast, defName, args);
          bodyCode = this.genUniq(getNthLambdaBody(ast, arity), names, uniq);
          if (this.debug) {
            code = sn(ast, `function(${argList}) {\n  return L_checkPartial(L$F, arguments, Leisure_traceCreatePartial${this.debugType}, Leisure_traceCallPartial${this.debugType}) || `, this.genTraceCall(ast, bodyCode, argList), ";\n};");
          } else {
            code = sn(ast, `function(${argList}) {\n  return L_checkPartial(L$F, arguments) || `, this.genTraceCall(ast, bodyCode, argList), ";\n};");
          }
          result = this.genLambdaDecl(ast, infoVar, defName, args, args.length, addLambdaProperties(ast, code));
          annoAst = ast;
          while (annoAst instanceof Leisure_anno) {
            name = getAnnoName(annoAst);
            data = getAnnoData(annoAst);
            switch (name) {
              case 'type':
                result = sn(ast, "setType(", result, ", '", data, "')");
                break;
              case 'dataType':
                result = sn(ast, "setDataType(", result, ", '", data, "')");
            }
            annoAst = getAnnoBody(annoAst);
          }
          this.popDecl();
          return result;
        }
      }

      genRefName(ref, uniq, names, checkMacro) {
        var name, ns, ref1, val, vname;
        name = getRefName(ref);
        if (isNil((val = names.find(function(el) {
          return el === name;
        })))) {
          vname = varNameSub(name);
          if (!(typeof window !== "undefined" && window !== null ? window : global)[vname] && ((ref1 = Leisure.stateValues.macroDefs) != null ? ref1.map.has(name) : void 0)) {
            throw new Error(`Attempt to use a macro as a value: ${name}`);
          }
          ns = findName(nameSub(name));
          if (ns === root.currentNameSpace) {
            nsLog(`LOCAL NAME: ${name} FOR ${root.currentNameSpace} ${location(ref)}`);
          } else if (!ns) {
            nsLog(`GUESSING LOCAL NAME ${name} FOR ${root.currentNameSpace} ${location(ref)}`);
          }
          return vname;
        } else {
          return uniqName(name, uniq);
        }
      }

      genApplyArg(arg, names, uniq) {
        var d;
        d = dumpAnno(arg);
        if (d instanceof Leisure_apply) {
          return this.declLazy(arg, () => {
            return this.lazify(d, this.genUniq(arg, names, uniq));
          });
        } else if (d instanceof Leisure_ref) {
          return this.genRefName(d, uniq, names);
        } else if (d instanceof Leisure_lit) {
          return sn(arg, jstr(getLitVal(d)));
        } else if (d instanceof Leisure_let) {
          return this.declLazy(arg, () => {
            return this.lazify(arg, this.genUniq(arg, names, uniq));
          });
        } else if (d instanceof Leisure_lambda) {
          return sn(arg, 'lazy(', this.genUniq(arg, names, uniq), ')');
        } else {
          return this.declLazy(arg, () => {
            return this.lazify(arg, this.genUniq(arg, names, uniq));
          });
        }
      }

      genLetAssign(arg, names, uniq) {
        return this.declLazy(arg, () => {
          return this.lazify(arg, this.genUniq(arg, names, uniq));
        });
      }

      lazify(ast, body) {
        return lazify(ast, body, (this.debug ? _.last(this.decls).id : void 0), this.debug && this.debugType);
      }

      genLets(ast, names, uniq) {
        var assigns, bindings, decs, letUniq, ln;
        bindings = letList(ast, []);
        [letUniq, decs, assigns, ln] = _.reduce(bindings, ((result, l) => {
          var code, letName, newNames, newU, u;
          [u, code, assigns, ln] = result;
          newU = addUniq(getLetName(l), ln, u);
          letName = uniqName(getLetName(l), newU);
          newNames = cons(getLetName(l), ln);
          return [newU, cons(sn(ast, letName + ' = ', this.genLetAssign(getLetValue(l), newNames, u)), code), cons(letName, assigns), newNames];
        }), [uniq, Nil, Nil, names]);
        return sn(ast, "  var ", assigns.reverse().intersperse(', ').toArray(), ";\n  ", decs.reverse().intersperse(';\n  ').toArray(), ";\n\n  return ", this.genUniq(getLastLetBody(ast), ln, letUniq));
      }

      genTraceCall(ast, code, argNames) {
        if (this.debug) {
          return sn(ast, `(\n  Leisure_traceCall${this.debugType}(L$F, arguments),\n  Leisure_traceReturn${this.debugType}(L$F, (`, code, "))\n)");
        } else {
          return code;
        }
      }

      genLambdaDecl(ast, infoVar, name, args, length, code) {
        var info, nameCode;
        if (name) {
          nameCode = jstr(name);
        } else {
          nameCode = 'undefined';
        }
        infoVar = this.addFuncInfo(info = {length});
        if (this.debug) {
          info.id = _.last(this.declStack).id;
          return sn(ast, "(function(L$instance, L$parent){\n  var L$F = ", code, `;\n  L$F.L$info = ${infoVar};\n  L$F.L$instanceId = L$instance;\n  L$F.L$parentId = L$parent;\n  return Leisure_traceLambda${this.debugType}(L$F);\n})(++Leisure_traceInstance, L$instance)`);
        } else {
          return sn(ast, "(function(){\n  var L$F = ", code, `;\n  L$F.L$info = ${infoVar};\n  return L$F;\n})()`);
        }
      }

      genAddSource() {
        if (this.source) {
          return `\n  Leisure_addSourceFile(@fileName, ${jstr(this.source)});`;
        } else {
          return '';
        }
      }

      genTraceMemos() {
        // memos for trace codes
        return '';
      }

      genTopLevel(ast, node) {
        var header, ref1;
        if ((ref1 = dumpAnno(ast).constructor) === Leisure_lit || ref1 === Leisure_ref) {
          return node;
        } else if (this.decls.length || this.debug) {
          header = "var L$ret;";
          if (this.createContext) {
            header += this.genContext();
          }
          return sn(ast, `(function(L$instance){\n  ${header}\n  return `, node, ";\n})(++Leisure_traceInstance)");
        } else {
          return sn(ast, `(function(){\n  var L$context = null;\n  ${this.genFuncInfo()}\n  return `, node, ";\n})()");
        }
      }

      genContext() {
        var context, decl, decls, j, len, ref1, source, type;
        source = this.source || this.noFile ? `source: Leisure_addSourceFile(${jstr(this.fileName)}, ${jstr(this.source)}),\n    map: '@SOURCEMAP@'` : this.sourceMap ? `source: ${jstr(this.fileName)},\n    map: '@SOURCEMAP@'` : `source: ${jstr(this.fileName)}`;
        decls = [];
        ref1 = this.decls;
        for (j = 0, len = ref1.length; j < len; j++) {
          decl = ref1[j];
          type = decl.lazy ? 'lazy' : 'lambda';
          decls.push(type, decl.line, decl.col, decl.parent);
          if (type === 'lambda') {
            decls.push(decl.lambda, decl.args.length, ...decl.args);
          }
        }
        return context = `\n  var L$context = Leisure_traceTopLevel${this.debugType}({\n    id: Leisure_traceContext++,\n    traceCreatePartial: function(){return Leisure_traceCreatePartial${this.debugType};},\n    traceCallPartial: function(){return Leisure_traceCallPartial${this.debugType};},\n    debugType: ${JSON.stringify(this.debugType)},\n    ${source},\n    decls: ${JSON.stringify(decls)}\n  });` + this.genFuncInfo();
      }

      genFuncInfo() {
        var header, i, info, j, len, len1, m, parent, ref1, ref2;
        header = '';
        if (this.decls.length) {
          ref1 = this.funcInfo;
          for (i = j = 0, len = ref1.length; j < len; i = ++j) {
            info = ref1[i];
            parent = (info.parent != null) && this.decls[info.parent];
            while (parent && parent.lazy) {
              parent = this.decls[parent.parent];
            }
            parent = (parent != null ? parent.funcId : void 0) ? this.funcVar(parent.funcId) : 'null';
            header += `\n  var ${this.funcVar(i)} = {name: ${JSON.stringify(info.name)}, args: ${JSON.stringify(info.args)}, id: ${info.id}, length: ${info.length}, parent: ${parent}, context: L$context};`;
          }
        } else {
          ref2 = this.funcInfo;
          for (i = m = 0, len1 = ref2.length; m < len1; i = ++m) {
            info = ref2[i];
            header += `\n  var ${this.funcVar(i)} = {name: ${JSON.stringify(info.name)}, length: ${info.length}};`;
          }
        }
        return header;
      }

    };
    lazify = function(ast, body, id, debugType) {
      if (debugType) {
        return sn(ast, `(function(L$instance, L$parent) {\n  return Leisure_traceLazyValue${debugType}(L$instance, L$context, ${id}, function(){\n    return Leisure_traceResolve${debugType}(L$instance, `, body, ");\n  });\n})(++Leisure_traceInstance, L$instance)");
      } else {
        return sn(ast, "function(){\n  return ", body, ";\n}");
      }
    };
    findName = function(name) {
      var i, j, ref1, ref2;
      for (i = j = ref1 = root.nameSpacePath.length - 1; (ref1 <= 0 ? j <= 0 : j >= 0); i = ref1 <= 0 ? ++j : --j) {
        if ((ref2 = LeisureNameSpaces[root.nameSpacePath[i]]) != null ? ref2[name] : void 0) {
          return root.nameSpacePath[i];
        }
      }
      if (root.currentNameSpace && LeisureNameSpaces[root.currentNameSpace][name]) {
        return root.currentNameSpace;
      } else {
        return null;
      }
    };
    location = function(ast) {
      var col, line;
      [line, col] = locateAst(ast);
      return `${line}:${col}`;
    };
    getLambdaArgs = function(ast) {
      var args;
      args = [];
      while (ast instanceof Leisure_lambda) {
        args.push(getLambdaVar(ast));
        ast = getLambdaBody(ast);
      }
      return [args, ast];
    };
    getNthLambdaBody = function(ast, n) {
      var d;
      if (n === 0) {
        return ast;
      } else if ((d = dumpAnno(ast)) instanceof Leisure_lambda) {
        return getNthLambdaBody(getLambdaBody(d), n - 1);
      } else {
        throw new Error(`Expected lambda but got ${ast}`);
      }
    };
    ((ref1 = typeof window !== "undefined" && window !== null ? window : global) != null ? ref1 : {}).curryCall = curryCall = function(args, func) {
      var f, i, j, ref1;
      f = func(args[0]);
      for (i = j = 1, ref1 = args.length; (1 <= ref1 ? j < ref1 : j > ref1); i = 1 <= ref1 ? ++j : --j) {
        f = f(args[i]);
      }
      return f;
    };
    getNArgs = function(n, ast) {
      var d;
      d = dumpAnno(ast);
      if (!n) {
        return Nil;
      } else {
        return cons(getLambdaVar(d), getNArgs(n - 1, getLambdaBody(d)));
      }
    };
    specialAnnotations = ['type', 'dataType', 'define'];
    arrayify = function(cons) {
      if (cons instanceof Leisure_cons) {
        return cons.map(function(el) {
          return arrayify(el);
        }).toArray();
      } else {
        return cons;
      }
    };
    getLambdaProperties = function(body, props) {
      var value;
      if (body instanceof Leisure_anno) {
        if (!_.includes(specialAnnotations, getAnnoName(body))) {
          if (!props) {
            props = {};
          }
          value = getAnnoData(body);
          props[getAnnoName(body)] = arrayify(value);
        }
        getLambdaProperties(getAnnoBody(body), props);
      }
      return props;
    };
    addLambdaProperties = function(ast, def, extras) {
      var p, props;
      props = getLambdaProperties(getLambdaBody(ast));
      if (props || extras) {
        p = {};
        if (props) {
          _.merge(p, props);
        }
        if (extras) {
          _.merge(p, extras);
        }
        return sn(ast, "setLambdaProperties(", def, ", ", jstr(p), ")");
      } else {
        return def;
      }
    };
    lcons = function(a, b) {
      return rz(L_cons)(lz(a))(lz(b));
    };
    parseErr = function(a, b) {
      return rz(L_parseErr)(a, b);
    };
    lconsFrom = function(array) {
      var el, j, len, p, ref2;
      if (array instanceof Array) {
        p = rz(L_nil);
        ref2 = array.reverse();
        for (j = 0, len = ref2.length; j < len; j++) {
          el = ref2[j];
          p = lcons(lconsFrom(el), p);
        }
        return p;
      } else {
        return array;
      }
    };
    assocListProps = null;
    getAssocListProps = function() {
      if (!assocListProps) {
        assocListProps = lcons(lcons('assoc', 'true'), rz(L_nil));
        assocListProps.properties = assocListProps;
      }
      return assocListProps;
    };
    lacons = function(key, value, list) {
      var alist;
      alist = lcons(lcons(key, value), list);
      alist.properties = getAssocListProps();
      return alist;
    };
    (typeof window !== "undefined" && window !== null ? window : global).setLambdaProperties = function(def, props) {
      var k, p, v;
      p = rz(L_nil);
      for (k in props) {
        v = props[k];
        p = lacons(k, lconsFrom(v), p);
      }
      def.properties = p;
      return def;
    };
    (typeof global !== "undefined" && global !== null ? global : window).L$convertError = function(err, args) {
      if (!err.L_stack) {
        console.log('CONVERTING ERROR:', err);
        (typeof global !== "undefined" && global !== null ? global : window).ERR = err;
        err.L_stack = args.callee.L$stack;
        err.L_args = args;
      }
      return err;
    };
    dumpAnno = function(ast) {
      if (ast instanceof Leisure_anno) {
        return dumpAnno(getAnnoBody(ast));
      } else {
        return ast;
      }
    };
    addUniq = function(name, names, uniq) {
      var num, overrides;
      if ((names.find(function(el) {
        return el === name;
      })) !== Nil) {
        [overrides, num] = uniq;
        return [cons(cons(name, `${name}_${num}`), overrides), num + 1];
      } else {
        return uniq;
      }
    };
    uniqName = function(name, uniq) {
      var kv;
      [uniq] = uniq;
      kv = uniq.find((function(el) {
        return el.head() === name;
      }), uniq);
      return varNameSub((kv !== Nil ? kv.tail() : name));
    };
    letList = function(ast, buf) {
      if (ast instanceof Leisure_let) {
        buf.push(ast);
        return letList(getLetBody(ast), buf);
      } else {
        return buf;
      }
    };
    getLastLetBody = function(ast) {
      if (ast instanceof Leisure_let) {
        return getLastLetBody(getLetBody(ast));
      } else {
        return ast;
      }
    };
    define('debugType', function(lvl) {
      return new Monad2('debugType', function(env, cont) {
        setDebugType(String(rz(lvl)));
        return cont(unit());
      });
    });
    define('debugMessage', function(type, msg) {
      return checkPartial(L_vectorRemove, arguments) || (new Monad2('debugMessage', function(env, cont) {
        var count;
        count = (typeof window !== "undefined" && window !== null ? window : global)[`Leisure_traceMessage${rz(type)}`](rz(msg));
        env.writeTraceMessage(count, rz(msg));
        return cont(unit());
      }));
    });
    define('traceOff', new Monad2('traceOff', function(env, cont) {
      trace = false;
      return cont(unit());
    }));
    define('traceOn', new Monad2('traceOn', function(env, cont) {
      trace = true;
      return cont(unit());
    }));
    define('runAst', (function(code) {
      return function(ast) {
        return new Monad2('runAst', function(env, cont) {
          var baseMsg, codeMsg, err, jsCode;
          //console.log "running code", code
          jsCode = null;
          try {
            jsCode = env.fileName ? withFile(env.fileName, null, () => {
              return new CodeGenerator(env.fileName, false, true).genSource(null, rz(ast));
            }) : new CodeGenerator().genSource(rz(code), rz(ast));
            return cont(eval(jsCode));
          } catch (error) {
            err = error;
            dumpMonadStack(err, env);
            codeMsg = (jsCode ? `CODE: \n${jsCode}\n` : '');
            baseMsg = `\n\nParse error: ${err.message}\n${codeMsg}AST: `;
            err.message = `${baseMsg}${ast()}`;
            err.L$ast = ast;
            return cont(err);
          }
        });
      };
    }), null, null, null, 'parser');
    define('genAst', (function(ast) {
      var err;
      try {
        return gen(rz(ast));
      } catch (error) {
        err = error;
        return parseErr(lz('\n\nParse error: ' + err.toString() + "AST: "), ast);
      }
    }), null, null, null, 'parser');
    //####
    // TMP HOOKS
    //####

    //####
    // END TMP HOOKS
    //####
    gen = function(ast) {
      return new CodeGenerator().gen(ast);
    };
    genMap = function(ast, fileName) {
      return new CodeGenerator(fileName, false, false, fileName).genMap(ast);
    };
    genSource = function(source, ast) {
      return new CodeGenerator().genSource(source, ast);
    };
    return {
      gen,
      genMap,
      genSource,
      sourceNode: sn,
      withFile,
      curryCall,
      //useNameSpace: useNameSpace
      //pushNameSpace: pushNameSpace
      //getNameSpacePath: getNameSpacePath
      //clearNameSpacePath: clearNameSpacePath
      //saveNameSpace: saveNameSpace
      //restoreNameSpace: restoreNameSpace
      SourceNode,
      SourceMapConsumer,
      SourceMapGenerator,
      setMegaArity,
      CodeGenerator,
      setDebugType,
      jsCodeFor
    };
  });

}).call(this);

//# sourceMappingURL=gen.js.map
