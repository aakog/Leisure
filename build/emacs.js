// Generated by CoffeeScript 1.9.3
(function() {
  var slice = [].slice;

  define(['./lib/lodash.min', './export', './ui', './editor', './editorSupport', './diag', './eval', './advice'], function(_, Exports, UI, Editor, EditorSupport, Diag, Eval, Advice) {
    var basicDataFilter, blockRangeFor, changeAdvice, clearDiag, close, computeNewStructure, configureEmacs, connect, connected, diag, diagMessage, error, escapeAttr, escapeString, fileCount, fileTypes, findEditor, getDocumentParams, imgCount, knownLanguages, mergeExports, message, messages, msgPat, open, preserveSelection, pushPendingInitialzation, receiveFile, renderImage, replace, replaceMsgPat, replaceWhile, sendCcCc, sendConcurrentBlockChange, sendFollowLink, sendGetFile, sendReplace, shouldSendConcurrent, showDiag, showMessage, typeForFile, unescapeString;
    mergeExports = Exports.mergeExports;
    findEditor = Editor.findEditor, preserveSelection = Editor.preserveSelection, computeNewStructure = Editor.computeNewStructure;
    changeAdvice = Advice.changeAdvice;
    showMessage = UI.showMessage, pushPendingInitialzation = UI.pushPendingInitialzation, escapeAttr = UI.escapeAttr;
    getDocumentParams = EditorSupport.getDocumentParams, basicDataFilter = EditorSupport.basicDataFilter;
    clearDiag = Diag.clearDiag, diagMessage = Diag.diagMessage;
    knownLanguages = Eval.knownLanguages, escapeString = Eval.escapeString, unescapeString = Eval.unescapeString;
    msgPat = /^([^ ]+)( (.*))?$/;
    replaceMsgPat = /^([^ ]+) ([^ ]+) ([^ ]+) (.*)$/;
    connected = false;
    showDiag = false;
    imgCount = 0;
    fileCount = 0;
    fileTypes = {
      pgn: 'image/png',
      gif: 'image/gif',
      bmp: 'image/bmp',
      xpm: 'image/xpm',
      svg: 'image/svg'
    };
    diag = function() {
      var msg;
      msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (showDiag) {
        return console.log.apply(console, msg);
      }
    };
    messages = {
      r: function(data, msg, frame) {
        return replace(data, msg);
      },
      reload: function() {
        return document.location.href = document.location.href;
      },
      activate: function() {
        window.open("javascript:close()");
        return window.focus();
      },
      file: function(data, msg, frame) {
        return receiveFile(data, msg);
      }
    };
    replace = function(data, msg) {
      var count, editor, end, ignore, ref, start, text;
      diag("Received " + msg);
      ref = msg.match(replaceMsgPat), ignore = ref[0], count = ref[1], start = ref[2], end = ref[3], text = ref[4];
      start = Number(start);
      end = Number(end);
      text = JSON.parse(text);
      editor = data.emacsConnection.opts.editor;
      return replaceWhile(start, end, text, data, function(repl) {
        var endLen, targetLen;
        if (end === -1) {
          return editor.options.load('emacs', text);
        } else {
          targetLen = data.getDocLength() - (end - start) + text.length;
          editor.options.makeStructureChange(start, end, text, repl);
          endLen = data.getDocLength();
          if (endLen !== targetLen) {
            return diagMessage("BAD DOC LENGTH AFTER REPLACEMENT, expected <" + targetLen + "> but ggot<" + endLen + ">");
          }
        }
      });
    };
    receiveFile = function(data, msg) {
      var base, id, lead, ref;
      ref = msg.match(/^([^ ]+) +/), lead = ref[0], id = ref[1];
      if (typeof (base = data.emacsConnection.fileCallbacks)[id] === "function") {
        base[id](msg.substring(lead.length));
      }
      return delete data.emacsConnection.fileCallbacks[id];
    };
    replaceWhile = function(start, end, text, data, func) {
      var blocks, newText, ref, repl;
      if (end === -1) {
        blocks = [];
        newText = text;
      } else {
        ref = data.blockOverlapsForReplacement(start, end, text), blocks = ref.blocks, newText = ref.newText;
      }
      repl = computeNewStructure(data, blocks, newText);
      repl.changeId = "emacs-" + (data.emacsConnection.changeCount++);
      repl.emacsNewBlocks = repl.newBlocks.slice();
      repl.blockOffset = blocks.length ? data.offsetForBlock(blocks[0]) : 0;
      data.emacsConnection.replacing = repl;
      data.emacsConnection.opts.mergeChangeContext({
        fromEmacs: repl.changeId
      });
      data.emacsConnection.pendingChanges[repl.changeId] = repl;
      try {
        return func(repl);
      } finally {
        data.emacsConnection.replacing = null;
      }
    };
    shouldSendConcurrent = function(data, newBlock) {
      var currentBlock, repl;
      if (newBlock) {
        repl = data.emacsConnection.replacing;
        currentBlock = _.find(repl.newBlocks, function(b) {
          return b._id === newBlock._id;
        });
        return currentBlock && currentBlock.text !== newBlock.text;
      }
    };
    sendConcurrentBlockChange = function(data, newBlock) {
      var currentNew, ind, offset, oldLen, repl, start;
      repl = data.emacsConnection.replacing;
      ind = _.findIndex(repl.newBlocks, function(x) {
        return x._id = newBlock;
      });
      currentNew = repl.emacsNewBlocks[ind];
      if (currentNew.text !== newBlock.text) {
        offset = 0;
        oldLen = currentNew.text.length;
        repl.emacsNewBlocks[ind] = newBlock;
        while (ind-- > 0) {
          offset += repl.emacsNewBlocks[ind];
        }
        start = offset + repl.blockOffset;
        return sendReplace(data.emacsConnection.websocket, start, start + oldLen, newBlock.text);
      }
    };
    connect = function(opts, host, port, cookie, cont) {
      var con;
      con = new WebSocket("ws://" + host + ":" + port);
      con.onopen = function(evt) {
        return open(evt, con, opts.data, port, cookie, cont);
      };
      con.onclose = function(evt) {
        return close(evt, opts.data);
      };
      con.onmessage = function(evt) {
        return message(evt, opts.data);
      };
      con.onerror = function(evt) {
        return showMessage(opts.editor.node, "Connection error", "Could not open connection to emacs", {
          position: {
            my: 'center top',
            at: 'center top'
          },
          buttons: {
            OK: function() {
              return $(this).dialog('close');
            }
          }
        });
      };
      _.defaults(opts, {
        renderImage: renderImage
      });
      return changeAdvice(opts, true, {
        followLink: {
          emacs: function(parent) {
            return function(e) {
              if (e.target.href.match(/^elisp/)) {
                sendFollowLink(this.data.emacsConnection.websocket, this.editor.docOffset($(e.target).prev('.link')[0], 1));
                return false;
              } else {
                return parent(e);
              }
            };
          }
        },
        execute: {
          emacs: function(parent) {
            return function() {
              var ref;
              if (((ref = this.editor.blockForCaret()) != null ? ref.language.toLowerCase() : void 0) in knownLanguages) {
                return parent();
              } else {
                return sendCcCc(this.editor.options.data.emacsConnection.websocket, this.editor.docOffset(this.editor.domCursorForCaret()));
              }
            };
          }
        }
      });
    };
    renderImage = function(src, title, currentId) {
      var con, imgId, name, ref, ref1;
      if (name = (ref = src.match(/^file:([^#?]*)([#?].*)?$/)) != null ? ref[1] : void 0) {
        con = this.data.emacsConnection;
        imgId = currentId || ("emacs-image-" + (imgCount++));
        sendGetFile(this.data, src, function(file) {
          var img;
          if (file && (img = $("#" + imgId)[0])) {
            return preserveSelection(function(range) {
              img.src = "data:" + (typeForFile(name)) + ";base64," + file;
              return img.onload = function() {
                img.removeAttribute('style');
                return con.imageSizes[name] = " style='height: " + img.height + "px; width: " + img.width + "px'";
              };
            });
          }
        });
        return "<img id='" + imgId + "' title='" + (escapeAttr(title)) + "'" + ((ref1 = con.imageSizes[name]) != null ? ref1 : '') + ">";
      } else {
        return "<img src='" + src + "' title='" + title + "'>";
      }
    };
    typeForFile = function(name) {
      var ext, ignore, ref;
      ref = name.match(/\.(.*)$/), ignore = ref[0], ext = ref[1];
      return fileTypes[ext];
    };
    close = function(evt, data) {
      var connection;
      console.log("CLOSED EMACS CONNECTION");
      connection = data.emacsConnection;
      connection.panel.find('button').button('enable');
      connection.panel.find('input').removeAttr('readonly');
      if (connection.cookie) {
        window.close();
      }
      data.removeFilter(connection.filter);
      connection.websocket = null;
      return connection.filter = null;
    };
    message = function(evt, data) {
      var ignore, method, msg, ref, text;
      ref = evt.data.match(msgPat), ignore = ref[0], msg = ref[1], ignore = ref[2], text = ref[3];
      if (method = messages[msg]) {
        return preserveSelection((function(_this) {
          return function() {
            return method(data, text, evt.data);
          };
        })(this));
      } else {
        console.log("Unknown message " + msg + ": " + text);
        return data.emacsConnection.websocket.close();
      }
    };
    error = function(evt, data) {
      return console.log("Error: " + evt.data);
    };
    open = function(evt, ws, data, port, cookie, cont) {
      var connection;
      ws.send((cookie != null ? cookie : '') + " display");
      connection = data.emacsConnection;
      connection.cookie = cookie;
      connection.panel.find('button').button('disable');
      connection.panel.find('input').attr('readonly', true);
      connection.websocket = ws;
      connection.filter = {
        __proto__: basicDataFilter,
        replaceBlock: function(data, oldBlock, newBlock) {
          var con, end, endOff, i, j, newLen, oldLen, ref, ref1, ref2, ref3, ref4, start, startOff, text, tmpReplacing;
          con = data.emacsConnection;
          if (!con.replacing && (((ref = con.opts.changeContext) != null ? ref.fromEmacs : void 0) != null)) {
            tmpReplacing = con.replacing = con.pendingChanges[con.opts.changeContext.fromEmacs];
          }
          if (con.replacing) {
            delete data.emacsConnection.pendingChanges[con.replacing.changeId];
          }
          if (!con.replacing || shouldSendConcurrent(data, newBlock)) {
            start = data.offsetForBlock((ref1 = oldBlock != null ? oldBlock._id : void 0) != null ? ref1 : newBlock._id);
            end = start + ((ref2 = oldBlock != null ? oldBlock.text.length : void 0) != null ? ref2 : 0);
            text = newBlock.text;
            if (data.emacsConnection.replacing) {
              sendConcurrentBlockChange(data, newBlock);
            } else {
              if (oldBlock && newBlock) {
                oldLen = oldBlock.text.length;
                newLen = newBlock.text.length;
                for (startOff = i = 0, ref3 = Math.min(oldLen, newLen); 0 <= ref3 ? i < ref3 : i > ref3; startOff = 0 <= ref3 ? ++i : --i) {
                  if (oldBlock.text[startOff] !== newBlock.text[startOff]) {
                    break;
                  }
                }
                start += startOff;
                for (endOff = j = 0, ref4 = Math.min(oldLen - startOff - 1, newLen - startOff - 1); j <= ref4; endOff = j += 1) {
                  if (oldBlock.text[oldLen - endOff - 1] !== newBlock.text[newLen - endOff - 1]) {
                    break;
                  }
                }
                end -= endOff;
                if (startOff || endOff) {
                  text = text.substring(startOff, text.length - endOff);
                }
              }
              if (start !== end || text !== '') {
                sendReplace(ws, start, end, text);
              }
            }
          }
          if (tmpReplacing) {
            return con.replacing = null;
          }
        }
      };
      data.addFilter(connection.filter);
      if (!cookie) {
        sendReplace(ws, 0, -1, data.getText());
      }
      return typeof cont === "function" ? cont() : void 0;
    };
    sendReplace = function(con, start, end, text) {
      con.send("r " + start + " " + end + " " + (JSON.stringify(text)));
      return diag("sending r " + start + " " + end + " " + (JSON.stringify(text)));
    };
    sendFollowLink = function(con, location) {
      con.send("followLink " + location);
      return diag("sending followLink " + location);
    };
    sendCcCc = function(con, location) {
      con.send("ctrl-c-ctrl-c " + location);
      return diag("sending ctrl-c-ctrl-c " + location);
    };
    sendGetFile = function(data, name, callback) {
      var con, id, m;
      con = data.emacsConnection.websocket;
      if (m = name.match(/#.*$/)) {
        name = name.substring(0, name.length - m[0].length);
      }
      id = "file-" + (fileCount++);
      diag("sending getFile " + id + " " + name);
      data.emacsConnection.fileCallbacks[id] = function(file) {
        delete data.emacsConnection.fileCallbacks[id];
        return callback(file);
      };
      return con.send("getFile " + id + " " + name);
    };
    blockRangeFor = function(data, start, end) {
      var bOff;
      bOff = data.blockOffsetForDocOffset(start);
      bOff.block = data.getBlock(bOff.block);
      bOff.length = end - start;
      bOff.type = start === end ? 'Caret' : 'Range';
      return bOff;
    };
    configureEmacs = function(panel) {
      var data, opts;
      opts = UI.context.opts;
      data = opts.data;
      data.emacsConnection = {
        imageSizes: {},
        panel: panel,
        opts: UI.context.opts,
        fileCallbacks: {},
        changeCount: 0,
        pendingChanges: {}
      };
      panel.find('button').button().on('click', function() {
        var host, port, ref;
        ref = panel.find('input').val().split(':'), host = ref[0], port = ref[1];
        return connect(opts, host, Number(port), '', function() {});
      });
      return $(document).ready(function() {
        var con, cookie, host, ignore, m, port, u;
        if (document.location.search.length > 1 && !connected) {
          connected = true;
          con = getDocumentParams().connect;
          if (con) {
            u = new URL(con);
            if (u.protocol === 'emacs:' && (m = u.pathname.match(/^\/\/([^:]*)(:[^\/]*)(\/.*)$/))) {
              ignore = m[0], host = m[1], port = m[2], cookie = m[3];
              return connect(opts, host, port.substring(1), cookie.substring(1));
            }
          }
        }
      });
    };
    mergeExports({
      blockRangeFor: blockRangeFor,
      configureEmacs: configureEmacs
    });
    return {};
  });

}).call(this);

//# sourceMappingURL=emacs.js.map
