// Generated by CoffeeScript 1.9.3
(function() {
  var slice = [].slice;

  define(['./lib/lodash.min', 'cs!./export.litcoffee', 'cs!./ui.litcoffee', 'cs!./editor.litcoffee'], function(_, Exports, UI, Editor) {
    var addBlockOffset, blockRangeFor, c, close, configureEmacs, connect, connected, diag, e, error, escapeString, escaped, findEditor, mergeExports, message, messages, msgPat, offsetFor, open, replace, replaceMsgPat, replaceWhile, replacing, sendReplace, showDiag, slashed, specials, unescapeString, unescaped;
    mergeExports = Exports.mergeExports;
    findEditor = Editor.findEditor;
    msgPat = /^([^ ]+) (.*)$/;
    replaceMsgPat = /^([^ ]+) ([^ ]+) ([^ ]+) (.*)$/;
    replacing = false;
    connected = false;
    showDiag = false;
    showDiag = true;
    diag = function() {
      var msg;
      msg = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if (showDiag) {
        return console.log.apply(console, msg);
      }
    };
    messages = {
      r: function(data, msg, frame) {
        return replace(data, msg);
      }
    };
    replace = function(data, msg) {
      var count, editor, end, ignore, ref, start, text;
      diag("Received " + msg);
      ref = msg.match(replaceMsgPat), ignore = ref[0], count = ref[1], start = ref[2], end = ref[3], text = ref[4];
      start = Number(start);
      end = Number(end);
      text = JSON.parse(text);
      editor = data.emacsConnection.opts.editor;
      return replaceWhile(function() {
        if (end === -1) {
          return editor.options.load(text);
        } else {
          return editor.replace(null, blockRangeFor(data, start, end), text);
        }
      });
    };
    replaceWhile = function(func) {
      replacing = true;
      try {
        return func();
      } finally {
        replacing = false;
      }
    };
    connect = function(data, port, cookie, cont) {
      var con;
      con = new WebSocket("ws://localhost:" + port);
      con.onopen = function(evt) {
        return open(evt, con, data, port, cookie, cont);
      };
      con.onclose = function(evt) {
        return close(evt, data);
      };
      con.onmessage = function(evt) {
        return message(evt, data);
      };
      return con.onerror = function(evt) {
        return error(evt, data);
      };
    };
    close = function(evt, data) {
      var connection;
      connection = data.emacsConnection;
      connection.panel.find('button').button('enable');
      connection.panel.find('input').removeAttr('readonly');
      console.log("closed");
      if (connection.cookie) {
        return window.close();
      }
    };
    message = function(evt, data) {
      var ignore, method, msg, ref, text;
      ref = evt.data.match(msgPat), ignore = ref[0], msg = ref[1], text = ref[2];
      if (method = messages[msg]) {
        return method(data, text, evt.data);
      } else {
        console.log("Unknown message " + msg + ": " + text);
        return data.emacsConnection.websocket.close();
      }
    };
    error = function(evt, data) {
      return console.log("Error: " + evt.data);
    };
    open = function(evt, ws, data, port, cookie, cont) {
      var connection;
      console.log("opened");
      ws.send((cookie != null ? cookie : '') + " display");
      connection = data.emacsConnection;
      connection.cookie = cookie;
      connection.panel.find('button').button('disable');
      connection.panel.find('input').attr('readonly', true);
      connection.websocket = ws;
      connection.filter = {
        clear: function() {
          connection.offsetIds = [];
          return connection.idOffsets = {};
        },
        replaceBlock: function(oldBlock, newBlock) {
          var end, endOff, i, index, j, newLen, oldLen, ref, ref1, ref2, start, startOff, text;
          if (!replacing) {
            if ((index = connection.idOffsets[oldBlock != null ? oldBlock._id : void 0]) != null) {
              while (connection.offsetIds.length > index) {
                delete connection.idOffsets[connection.offsetIds.pop()];
              }
            }
            start = offsetFor(data, (ref = oldBlock._id) != null ? ref : newBlock._id);
            end = start + (oldBlock ? oldBlock.text.length : 0);
            text = newBlock.text;
            if (oldBlock && newBlock) {
              oldLen = oldBlock.text.length;
              newLen = newBlock.text.length;
              for (startOff = i = 0, ref1 = Math.min(oldLen, newLen); 0 <= ref1 ? i < ref1 : i > ref1; startOff = 0 <= ref1 ? ++i : --i) {
                if (oldBlock.text[startOff] !== newBlock.text[startOff]) {
                  break;
                }
              }
              start += startOff;
              for (endOff = j = 1, ref2 = Math.min(oldLen, newLen, newLen - startOff - 1); 1 <= ref2 ? j <= ref2 : j >= ref2; endOff = 1 <= ref2 ? ++j : --j) {
                if (oldBlock.text[oldLen - endOff] !== newBlock.text[newLen - endOff]) {
                  break;
                }
              }
              endOff -= 1;
              end -= endOff;
              if (startOff || endOff) {
                text = text.substring(startOff, text.length - endOff);
              }
            }
            return sendReplace(ws, start, end, text);
          }
        }
      };
      connection.filter.clear();
      data.addFilter(connection.filter);
      if (!cookie) {
        sendReplace(ws, 0, -1, data.getText());
      }
      return typeof cont === "function" ? cont() : void 0;
    };
    sendReplace = function(con, start, end, text) {
      con.send("r " + start + " " + end + " " + (JSON.stringify(text)));
      return diag("sending r " + start + " " + end + " " + (JSON.stringify(text)));
    };
    blockRangeFor = function(data, start, end) {
      var con, lastBlock, lastId, offset, ref;
      con = data.emacsConnection;
      if (lastId = _.last(con.offsetIds)) {
        offset = con.idOffsets[lastId];
        lastBlock = data.getBlock(lastId);
      } else {
        offset = 0;
        lastId = data.getFirst();
        lastBlock = data.getBlock(lastId);
        addBlockOffset(data, offset, lastBlock._id, null);
      }
      while (offset < start && lastId) {
        ref = addBlockOffset(data, offset, lastId, null), lastId = ref[0], offset = ref[1];
      }
      if (!lastId) {
        lastId = _.last(con.offsetIds);
        offset = con.idOffsets[lastId];
      }
      while (offset > start) {
        lastId = data.getBlock(lastId).prev;
        offset = con.idOffsets[lastId];
      }
      return {
        block: data.getBlock(lastId),
        offset: start - offset,
        length: end - start,
        type: start === end ? 'Caret' : 'Range'
      };
    };
    offsetFor = function(data, thing) {
      var block, connection, id, lastId, offset, ref, thingId;
      thingId = typeof thing === 'string' ? thing : thing._id;
      connection = data.emacsConnection;
      if ((offset = connection.idOffsets[thingId]) == null) {
        if (lastId = _.last(connection.offsetIds)) {
          block = data.getBlock(lastId);
          offset = connection.idOffsets[lastId] + block.text.length;
          id = block.next;
        } else {
          offset = 0;
          id = data.getFirst();
        }
        while ((ref = addBlockOffset(data, offset, id, thingId), id = ref[0], offset = ref[1], ref) && id) {}
        if (!id) {
          return connection.idOffsets[_.last(connection.offsetIds)];
        }
      }
      return offset;
    };
    addBlockOffset = function(data, offset, id, endId) {
      var block, connection;
      connection = data.emacsConnection;
      connection.idOffsets[id] = offset;
      connection.offsetIds.push(id);
      if (id === endId) {
        return [];
      } else {
        block = data.getBlock(id);
        return [block.next, offset + block.text.length];
      }
    };
    specials = /[\b\f\n\r\t\v\"\\]/g;
    slashed = /\\./g;
    escaped = {
      '\b': "\\b",
      '\f': "\\f",
      '\n': "\\n",
      '\r': "\\r",
      '\t': "\\t",
      '\v': "\\v",
      '\"': "\\\"",
      '\\': "\\\\"
    };
    unescaped = _.zipObject((function() {
      var results;
      results = [];
      for (c in escaped) {
        e = escaped[c];
        results.push([e, c]);
      }
      return results;
    })());
    escapeString = function(str) {
      return str.replace(specials, function(c) {
        return escaped[c];
      });
    };
    unescapeString = function(str) {
      return str.replace(slashed, function(c) {
        var ref;
        return (ref = unescaped[c]) != null ? ref : c[1];
      });
    };
    configureEmacs = function(panel) {
      var data;
      data = UI.context.opts.data;
      data.emacsConnection = {
        panel: panel,
        opts: UI.context.opts
      };
      panel.find('button').button().on('click', function() {
        return connect(data, Number(panel.find('input').val()), '', function() {});
      });
      return $(document).ready(function() {
        var cookie, i, k, len, param, params, port, ref, ref1, v;
        if (document.location.search.length > 1 && !connected) {
          connected = true;
          params = {};
          ref = document.location.search.substring(1).split('&');
          for (i = 0, len = ref.length; i < len; i++) {
            param = ref[i];
            ref1 = param.split('='), k = ref1[0], v = ref1[1];
            params[k.toLowerCase()] = v;
          }
          port = params.port, cookie = params.cookie;
          if (port) {
            return connect(data, port, cookie);
          }
        }
      });
    };
    mergeExports({
      offsetFor: offsetFor,
      blockRangeFor: blockRangeFor,
      configureEmacs: configureEmacs
    });
    return {
      escapeString: escapeString,
      unescapeString: unescapeString
    };
  });

}).call(this);

//# sourceMappingURL=emacs.js.map
