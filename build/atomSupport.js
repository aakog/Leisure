// Generated by CoffeeScript 2.2.4
(function() {
  // Connect to the Atom editor. Atom needs line/col coordinates so we need to Map
  // offsets <--> line/col.
  define(['lodash', './ui', './editor', './editorSupport', './diag', './eval', './advice', 'fingertree'], function(_, UI, Editor, EditorSupport, Diag, Eval, Advice, Fingertree) {
    var AtomSupport, LINE_END, NON_LEISURE_LINE_END, Point, basicDataFilter, configureAtom, getDocumentParams, leisureText, path;
    if (!window.atomView) {
      return {
        configureAtom: function() {}
      };
    }
    ({getDocumentParams, basicDataFilter} = EditorSupport);
    ({Point} = parent.require('atom'));
    path = parent.require('path');
    LINE_END = /\r\n|\r|\n/g;
    NON_LEISURE_LINE_END = /\r\n|\r/g;
    AtomSupport = (function() {
      class AtomSupport {
        constructor(opts1, text) {
          var line, textLines;
          this.opts = opts1;
          textLines = text.split(/\n/);
          // console.log 'text lines', textLines
          // console.log 'text', text
          if (_.last(textLines) === '') {
            textLines.pop();
          }
          this.atomLines = Fingertree.fromArray((function() {
            var j, len, results;
            results = [];
            for (j = 0, len = textLines.length; j < len; j++) {
              line = textLines[j];
              results.push(line.length + 1);
            }
            return results;
          })(), {
            identity: function() {
              return {
                lines: 0,
                width: 0
              };
            },
            measure: function(v) {
              return {
                lines: 1,
                width: v
              };
            },
            sum: function(a, b) {
              return {
                lines: a.lines + b.lines,
                width: a.width + b.width
              };
            }
          });
          this.opts.data.addFilter({
            __proto__: basicDataFilter,
            replaceText: (data, {start, end, text, source}) => {
              var endOff, startOff;
              if (source !== 'atom') {
                try {
                  this.changing = true;
                  startOff = this.atomOffset(start);
                  endOff = this.atomOffset(end);
                  // console.log "Leisure replace #{start}, #{end}, #{text}"
                  // console.log "-> atom replace [#{startOff.row}, #{startOff.column}], [#{endOff.row}, #{endOff.column}], #{text}"
                  return atomView.editor.setTextInBufferRange([startOff, endOff], text);
                } finally {
                  this.changing = false;
                }
              }
            }
          });
        }

        splitForLine(line) {
          return this.atomLines.split(function(m) {
            return m.lines > line;
          });
        }

        atomOffset(leisureOffset) {
          var m;
          m = (this.atomLines.split(function(m) {
            return m.width > leisureOffset;
          }))[0].measure();
          return Point.fromObject([m.lines, leisureOffset - m.width]);
        }

        leisureOffset(atomOffset) {
          var p;
          p = Point.fromObject(atomOffset);
          return this.splitForLine(p.row)[0].measure().width + p.column;
        }

        handleAtomTextChanged(e) {
          var end, first, i, j, k, len, line, ref, ref1, ref2, ref3, rest, start, t, text;
          // console.log 'Atom text event', e
          start = this.leisureOffset([e.start, 0]);
          end = this.leisureOffset([e.end + 1, 0]);
          text = leisureText(atomView.editor.getTextInRange([[e.start, 0], [e.end + 1 + ((ref = e.bufferDelta) != null ? ref : 0), 0]]));
          if (this.opts.data.getDocSubstring(start, end) !== text) {
            // console.log "-> Leisure replace#{if @changing then ' (index update only)' else ''}: ", {start, end, text}
            [first, rest] = this.splitForLine(e.start);
            for (i = j = ref1 = e.start, ref2 = e.end; (ref1 <= ref2 ? j <= ref2 : j >= ref2); i = ref1 <= ref2 ? ++j : --j) {
              if (rest.isEmpty()) {
                break;
              }
              rest = rest.removeFirst();
            }
            t = (_.last(text) === '\n' ? text.substring(0, text.length - 1) : text);
            ref3 = t.split(LINE_END);
            for (k = 0, len = ref3.length; k < len; k++) {
              line = ref3[k];
              first = first.addLast(line.length + 1);
            }
            this.atomLines = first.concat(rest);
            if (!this.changing) {
              return this.opts.replaceText({
                start,
                end,
                text,
                source: 'atom'
              });
            }
          }
        }

      };

      AtomSupport.prototype.changing = false;

      return AtomSupport;

    }).call(this);
    // else console.log 'Ignoring redundant event'
    leisureText = function(text) {
      return text.replace(NON_LEISURE_LINE_END, '\n');
    };
    configureAtom = function(opts, cont) {
      return $(document).ready(function() {
        var con, connected, editorId, ignore, m, text, u;
        if (document.location.search.length > 1 && !connected) {
          connected = true;
          ({
            connect: con
          } = getDocumentParams());
          if (con) {
            u = new URL(con);
            if (u.protocol === 'atom:' && (m = u.pathname.match(/^\/\/(.*)$/))) {
              [ignore, editorId] = m;
              // console.log "CONNECT TO ATOM EDITOR: #{editorId}", atomView, parent.atom
              text = atomView.editor.getText();
              window.atomSupport = new AtomSupport(opts, leisureText(text));
              opts.loadName = `file:${path.join(atomView.editor.getDirectoryPath(), atomView.editor.getFileName())}`;
              opts.load(opts.loadName, leisureText(text));
              return cont(opts);
            }
          }
        }
      });
    };
    //opts.load 'atom', '* heading\n#+BEGIN_SRC leisure :results def\n3+4\n#+END_SRC\n'
    return {configureAtom};
  });

}).call(this);

//# sourceMappingURL=atomSupport.js.map
