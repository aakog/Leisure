// Generated by CoffeeScript 1.9.3
(function() {
  define(['./lib/fingertree'], function(Fingertree) {
    var OT, Replacements, addOperation, addOperations, computeNodeEffect, isReplace, mergeRepl, newNode;
    OT = (function() {
      function OT(operations1) {
        this.operations = operations1;
        if (!this.operations) {
          this.operations = Fingertree.fromArray([], {
            identity: function() {
              return {
                maxOffset: -1,
                float: 0
              };
            },
            measure: function(v) {
              return {
                maxOffset: v.start,
                float: v.float
              };
            },
            sum: function(a, b) {
              return {
                maxOffset: Math.max(a.maxOffset, b.maxOffset),
                float: a.float + b.float
              };
            }
          });
        }
      }

      OT.prototype.toString = function() {
        var ops;
        ops = [];
        this.eachOperation(function(start, end, text) {
          return ops.push("(" + start + ", " + end + ", " + (JSON.stringify(text)) + ")");
        });
        return ops.join(' ');
      };

      OT.prototype.snapshot = function() {
        return new OT(this.operations);
      };

      OT.prototype.floatFor = function(repl) {
        var first, float, i, len, m, n, op, ref, ref1, rest;
        ref = this.operations.split(function(m) {
          return m.maxOffset >= repl.start;
        }), first = ref[0], rest = ref[1];
        m = first.measure();
        if (!rest.isEmpty() && (n = rest.peekFirst()).start === repl.start) {
          float = m.float;
          ref1 = n.operations;
          for (i = 0, len = ref1.length; i < len; i++) {
            op = ref1[i];
            if (op.start <= repl.start && !isReplace(op)) {
              float += op.text.length - op.end + op.start;
            }
          }
          return float;
        } else {
          return m.float;
        }
      };

      OT.prototype.replace = function(repl) {
        var first, next, node, prev, ref, rest, target;
        ref = this.operations.split(function(m) {
          return m.maxOffset >= repl.start;
        }), first = ref[0], rest = ref[1];
        if (!first.isEmpty() && (prev = first.peekLast()).end > repl.start - 2) {
          first = first.removeLast();
          node = addOperation(prev, repl);
        } else {
          node = !rest.isEmpty() && (target = rest.peekFirst()).start === repl.start ? (rest = rest.removeFirst(), addOperation(target, repl)) : newNode(repl);
        }
        while (!rest.isEmpty() && node.end > (next = rest.peekFirst()).start - 2) {
          rest = rest.removeFirst();
          node = addOperations(node, next.operations);
        }
        return this.operations = first.concat(rest.addFirst(node));
      };

      OT.prototype.eachOperation = function(func) {
        var end, node, offset, results, t, text;
        offset = 0;
        t = this.operations;
        results = [];
        while (!t.isEmpty()) {
          node = t.peekFirst();
          end = node.end, text = node.text;
          func(node.start + offset, end + offset, text, offset, node);
          offset += node.float;
          results.push(t = t.removeFirst());
        }
        return results;
      };

      return OT;

    })();
    isReplace = function(repl) {
      return repl.end > repl.start && repl.text.length;
    };
    computeNodeEffect = function(node) {
      var del, end, float, i, insertionText, j, len, len1, op, operation, operations, ref, repl;
      insertionText = '';
      repl = null;
      del = null;
      operations = [];
      float = 0;
      end = node.start;
      ref = node.operations;
      for (i = 0, len = ref.length; i < len; i++) {
        op = ref[i];
        if (op.end === op.start) {
          operations.push(op);
          float += op.text.length;
        } else if (!op.text.length) {
          del = op;
        } else {
          repl = op;
        }
      }
      if (del) {
        operations.unshift(del);
      } else if (repl) {
        operations.push(repl);
      }
      if (operation = del || repl) {
        float += operation.text.length - operation.end + operation.start;
      }
      for (j = 0, len1 = operations.length; j < len1; j++) {
        op = operations[j];
        end = Math.max(end, op.end);
      }
      node.float = float;
      node.end = end;
      node.activeOperations = operations;
      return node;
    };
    addOperation = function(node, record) {
      return addOperations(node, [record]);
    };
    addOperations = function(node, records) {
      return computeNodeEffect({
        start: node.start,
        operations: node.operations.concat(records)
      });
    };
    newNode = function(record) {
      return computeNodeEffect({
        start: record.start,
        operations: [record]
      });
    };
    Replacements = (function() {
      function Replacements() {
        this.replacements = Fingertree.fromArray([], {
          identity: function() {
            return {
              start: -1,
              float: 0
            };
          },
          measure: function(arg) {
            var end, start, text;
            start = arg.start, end = arg.end, text = arg.text;
            return {
              start: start,
              float: text.length - end + start
            };
          },
          sum: function(a, b) {
            return {
              start: b.start,
              float: a.float + b.float
            };
          }
        });
      }

      Replacements.prototype.replace = function(repl) {
        var end, first, node, old, ref, rest, start, text;
        start = repl.start, end = repl.end, text = repl.text;
        ref = this.replacements.split(function(m) {
          return m.start >= start;
        }), first = ref[0], rest = ref[1];
        if (!first.isEmpty() && (old = first.peekLast()) && old.end >= start) {
          first = first.removeLast();
          node = mergeRepl(old, repl);
        } else if (!rest.isEmpty() && (old = rest.peekFirst()) && (old.start === start || end >= old.start)) {
          rest = rest.removeFirst();
          node = mergeRepl(old, repl);
        } else {
          node = {
            start: start,
            end: end,
            text: text,
            repl: repl
          };
        }
        this.replacements = first.concat(rest.addFirst(node));
        return old != null ? old.repl : void 0;
      };

      Replacements.prototype.dump = function() {
        var n, t;
        t = this.replacements;
        while (!t.isEmpty()) {
          n = t.peekFirst();
          console.log(n.start + ", " + n.end + ", " + (JSON.stringify(n.text)));
          t = t.removeFirst();
        }
        return null;
      };

      return Replacements;

    })();
    mergeRepl = function(node, repl) {
      var rEnd, rStart;
      rStart = Math.max(0, repl.start - node.start);
      rEnd = repl.end - node.start;
      return {
        start: Math.min(node.start, repl.start),
        end: node.end + Math.max(0, repl.end - node.start - node.text.length),
        text: node.text.substring(0, rStart) + repl.text + node.text.substring(rEnd),
        repl: repl
      };
    };
    Replacements.test = function() {
      var r;
      r = new Replacements();
      r.replace({
        start: 100,
        end: 109,
        text: 'duh'
      });
      r.replace({
        start: 101,
        end: 102,
        text: 'HELLO'
      });
      r.replace({
        start: 100,
        end: 109,
        text: 'poop'
      });
      r.replace({
        start: 95,
        end: 100,
        text: ''
      });
      r.replace({
        start: 30,
        end: 35,
        text: 'smeg'
      });
      r.replace({
        start: 25,
        end: 34,
        text: 'blorfl'
      });
      r.dump();
      return r;
    };
    OT.Replacements = Replacements;
    window.Replacements = Replacements;
    return OT;
  });

}).call(this);

//# sourceMappingURL=ot.js.map
