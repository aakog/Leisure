// Generated by CoffeeScript 1.9.3
(function() {
  define(['./lib/fingertree'], function(Fingertree) {
    var OT, addOperation, computeNodeEffect, newNode;
    OT = (function() {
      function OT(operations1) {
        this.operations = operations1;
        if (!this.operations) {
          this.operations = Fingertree.fromArray([], {
            identity: function() {
              return {
                maxOffset: -1,
                float: 0
              };
            },
            measure: function(v) {
              return {
                maxOffset: v.start,
                float: v.text.length - v.end + v.start
              };
            },
            sum: function(a, b) {
              return {
                maxOffset: Math.max(a.maxOffset, b.maxOffset),
                float: a.float + b.float
              };
            }
          });
        }
      }

      OT.prototype.snapshot = function() {
        return new OT(this.operations);
      };

      OT.prototype.floatFor = function(offset) {
        return this.operations.split(function(m) {
          return m.maxOffset >= offset;
        })[0].measure().float;
      };

      OT.prototype.replace = function(repl) {
        var first, node, ref, rest, target;
        ref = this.operations.split(function(m) {
          return m.maxOffset >= repl.start;
        }), first = ref[0], rest = ref[1];
        node = !rest.isEmpty() && (target = rest.peekFirst()).start === repl.start ? (rest = rest.removeFirst(), addOperation(target, repl)) : newNode(repl);
        return this.operations = first.concat(rest.addFirst(node));
      };

      OT.prototype.eachOperation = function(func) {
        var end, node, offset, results, t, text;
        offset = 0;
        t = this.operations;
        results = [];
        while (!t.isEmpty()) {
          node = t.peekFirst();
          end = node.end, text = node.text;
          func(node.start + offset, end + offset, text, offset, node);
          offset += text.length - end + node.start;
          results.push(t = t.removeFirst());
        }
        return results;
      };

      return OT;

    })();
    computeNodeEffect = function(node) {
      var deletionWidth, i, insertionText, lastDel, lastRepl, len, oldDel, op, operations, ref, replCount, replacementText;
      deletionWidth = 0;
      insertionText = '';
      replacementText = '';
      lastRepl = null;
      replCount = 0;
      lastDel = null;
      operations = [];
      ref = node.operations;
      for (i = 0, len = ref.length; i < len; i++) {
        op = ref[i];
        if (op.end > op.start) {
          oldDel = deletionWidth;
          deletionWidth = Math.max(deletionWidth, op.end - op.start);
          if (oldDel !== deletionWidth) {
            lastRepl = null;
            replCount = 0;
            if (op.text.length === '') {
              lastDel = op;
            }
          }
          if (deletionWidth === op.end - op.start && op.text.length) {
            lastRepl = op;
            replCount++;
            replacementText = op.text;
          }
        }
        if (op.end === op.start) {
          insertionText += op.text;
          operations.push(op);
        }
      }
      if (lastDel) {
        operations.unshift(lastDel);
      }
      if (lastRepl) {
        operations.push(lastRepl);
      }
      node.end = node.start + deletionWidth;
      node.text = insertionText + replacementText;
      node.activeOperations = operations;
      node.replCount = replCount;
      return node;
    };
    addOperation = function(node, record) {
      return computeNodeEffect({
        start: node.start,
        operations: node.operations.concat([record])
      });
    };
    newNode = function(record) {
      return computeNodeEffect({
        start: record.start,
        operations: [record]
      });
    };
    return OT;
  });

}).call(this);

//# sourceMappingURL=ot.js.map
