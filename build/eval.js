// Generated by CoffeeScript 1.9.3
(function() {
  define(['cs!base', 'cs!ast', 'cs!runtime'], function(Base, Ast, Runtime) {
    var Html, Node, _true, cons, defaultEnv, define, errorDiv, escapeHtml, getType, getValue, html, jsEnv, jsonConvert, knownLanguages, languageEnvMaker, lazy, lc, leisureEnv, lz, makeHamt, makeSyncMonad, newConsFrom, replacements, resolve, runMonad, runMonad2, runNextResult, rz, setValue, unescapePresentationHtml;
    getType = Ast.getType, cons = Ast.cons, define = Ast.define, unescapePresentationHtml = Ast.unescapePresentationHtml;
    Node = Base.Node, resolve = Base.resolve, lazy = Base.lazy, defaultEnv = Base.defaultEnv;
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    runMonad = Runtime.runMonad, runMonad2 = Runtime.runMonad2, newConsFrom = Runtime.newConsFrom, setValue = Runtime.setValue, getValue = Runtime.getValue, makeSyncMonad = Runtime.makeSyncMonad, makeHamt = Runtime.makeHamt, _true = Runtime._true, jsonConvert = Runtime.jsonConvert;
    leisureEnv = function(env) {
      env.presentValue = function(v) {
        return rz(L_showHtml)(lz(v));
      };
      env.executeText = function(text, props, cont) {
        var old, result;
        old = getValue('parser_funcProps');
        setValue('parser_funcProps', props);
        result = rz(L_baseLoadString)('notebook')(text);
        return runMonad2(result, env, function(results) {
          return runNextResult(results, env, function() {
            setValue('parser_funcProps', old);
            return typeof cont === "function" ? cont(env, results) : void 0;
          });
        });
      };
      return env;
    };
    runNextResult = function(results, env, cont) {
      while (results !== rz(L_nil) && getType(results.head().tail()) === 'left') {
        env.write("PARSE ERROR: " + (getLeft(results.head().tail())));
        results = results.tail();
      }
      if (results !== rz(L_nil)) {
        return runMonad2(getRight(results.head().tail()), env, function(res2) {
          if (getType(res2) !== 'unit') {
            env.write(String(env.presentValue(res2)));
          }
          return runNextResult(results.tail(), env, cont);
        });
      } else {
        return cont();
      }
    };
    jsEnv = function(env) {
      env.presentValue = function(v) {
        if (v instanceof Html) {
          return v.content;
        } else {
          return escapeHtml(v);
        }
      };
      env.executeText = function(text, props, cont) {
        var console, err;
        console = {
          log: (function(_this) {
            return function(str) {
              return _this.write(_this.presentValue(str));
            };
          })(this)
        };
        try {
          return console.log(eval(text));
        } catch (_error) {
          err = _error;
          return this.write(html(errorDiv(err.stack)));
        } finally {
          if (typeof cont === "function") {
            cont(env);
          }
        }
      };
      return env;
    };
    Html = (function() {
      function Html(content1) {
        this.content = content1;
      }

      return Html;

    })();
    html = function(content) {
      return new Html(content);
    };
    errorDiv = function(err, orgText) {
      return "<span class='error' contenteditable='false'><span class='hidden'>" + (orgText || '') + "</span><span data-nonorg='true'>" + (escapeHtml(err)) + "</span></span>";
    };
    replacements = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;'
    };
    escapeHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&]/g, function(c) {
          return replacements[c];
        });
      } else {
        return str;
      }
    };
    knownLanguages = {
      leisure: leisureEnv,
      javascript: jsEnv,
      js: jsEnv
    };
    languageEnvMaker = function(name) {
      return knownLanguages[name.toLowerCase()];
    };
    return {
      languageEnvMaker: languageEnvMaker,
      html: html,
      Html: Html,
      escapeHtml: escapeHtml
    };
  });

}).call(this);

//# sourceMappingURL=eval.js.map
