// Generated by CoffeeScript 1.9.3
(function() {
  var loadLeisure,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  loadLeisure = function(cont) {
    return require(['./leisure/generatedPrelude'], function() {
      return require(['./leisure/std'], function() {
        return require(['./leisure/parseAst'], function() {
          return require(['./leisure/svg'], function() {
            return cont();
          });
        });
      });
    });
  };

  define(['./base', './ast', './runtime', 'acorn', 'acorn_walk', './lib/lispyscript/browser-bundle', './coffee-script', './gen', './leisure-support'], function(Base, Ast, Runtime, Acorn, AcornWalk, LispyScript, CS) {
    var Html, Node, _true, acorn, acornLoose, acornWalk, blockVars, c, cons, csEnv, defaultEnv, e, errorDiv, escapeHtml, escapeString, escaped, findError, getLeft, getRight, getType, getValue, handleErrors, html, id, isError, jsEnv, jsEval, jsonConvert, knownLanguages, languageEnvMaker, lazy, lc, leisureEnv, lispyScript, localEval, lsEnv, lz, makeHamt, makeSyncMonad, newConsFrom, presentHtml, replacements, resolve, runMonad, runMonad2, runNextResult, rz, setValue, show, slashed, specials, unescapePresentationHtml, unescapeString, unescaped, walk, writeValues;
    acorn = Acorn;
    acornWalk = AcornWalk;
    acornLoose = null;
    setTimeout((function() {
      return require(['acorn_loose'], function(AcornLoose) {
        return acornLoose = AcornLoose;
      });
    }), 1);
    lispyScript = lsrequire("lispyscript");
    getType = Ast.getType, cons = Ast.cons, unescapePresentationHtml = Ast.unescapePresentationHtml;
    Node = Base.Node, resolve = Base.resolve, lazy = Base.lazy, defaultEnv = Base.defaultEnv;
    rz = resolve;
    lz = lazy;
    lc = Leisure_call;
    runMonad = Runtime.runMonad, runMonad2 = Runtime.runMonad2, newConsFrom = Runtime.newConsFrom, setValue = Runtime.setValue, getValue = Runtime.getValue, makeSyncMonad = Runtime.makeSyncMonad, makeHamt = Runtime.makeHamt, _true = Runtime._true, jsonConvert = Runtime.jsonConvert;
    loadLeisure(function() {});
    defaultEnv.write = function(str) {
      return console.log(str);
    };
    id = lz(function(x) {
      return rz(x);
    });
    getLeft = function(x) {
      return x(id)(id);
    };
    getRight = function(x) {
      return x(id)(id);
    };
    show = function(obj) {
      if (typeof L_show !== "undefined" && L_show !== null) {
        return rz(L_show)(lz(obj));
      } else {
        return console.log(obj);
      }
    };
    leisureEnv = function(env) {
      env.presentValue = function(v) {
        return html(rz(L_showHtml)(lz(v)));
      };
      env.executeText = function(text, props, cont) {
        var err, old, result;
        try {
          old = getValue('parser_funcProps');
          setValue('parser_funcProps', props);
          result = rz(L_baseLoadString)('notebook')(text);
          return runMonad2(result, env, function(results) {
            return runNextResult(results, env, function() {
              setValue('parser_funcProps', old);
              return typeof cont === "function" ? cont(env, results) : void 0;
            });
          });
        } catch (_error) {
          err = _error;
          return this.errorAt(0, err.message);
        }
      };
      return env;
    };
    runNextResult = function(results, env, cont) {
      while (results !== rz(L_nil) && getType(results.head().tail()) === 'left') {
        env.write("PARSE ERROR: " + (getLeft(results.head().tail())));
        results = results.tail();
      }
      if (results !== rz(L_nil)) {
        return runMonad2(getRight(results.head().tail()), env, function(res2) {
          if (getType(res2) !== 'unit') {
            env.write(env.presentValue(res2));
          }
          return runNextResult(results.tail(), env, cont);
        });
      } else {
        return cont();
      }
    };
    presentHtml = function(v) {
      return ': ' + (v instanceof Html ? v.content.replace(/\r?\n/g, '\\n') : escapeHtml(String(v).replace(/\r?\n/g, '\n: ')));
    };
    writeValues = function(env, values) {
      return env.write(values.join('\n'));
    };
    jsEnv = function(env) {
      env.executeText = function(text, props, cont) {
        var err, value;
        try {
          writeValues(env, value = jsEval(env, text));
        } catch (_error) {
          err = _error;
          this.errorAt(0, err.message);
        }
        return typeof cont === "function" ? cont(value) : void 0;
      };
      return env;
    };
    jsEval = function(env, text) {
      var console, err, err2, errNode, expr, exprText, i, len, newText, parsed, ref, ref1;
      try {
        parsed = acorn.parse(text);
      } catch (_error) {
        err = _error;
        errNode = null;
        handleErrors(acornLoose.parse_dammit(text), function(node) {
          return errNode = node;
        });
        try {
          eval(text);
        } catch (_error) {
          err2 = _error;
          if (errNode) {
            env.errorAt(Math.min(errNode.start, errNode.end), err2.message);
          } else {
            env.errorAt(findError(err.message, text), err2.message);
          }
          return [];
        }
      }
      env.results = [];
      newText = 'var leisure_results=[];';
      ref = parsed.body;
      for (i = 0, len = ref.length; i < len; i++) {
        expr = ref[i];
        if (expr.type === 'ExpressionStatement') {
          exprText = text.substring(expr.start, expr.end);
          if (exprText[exprText.length - 1] === ';') {
            exprText = exprText.substring(0, exprText.length - 1);
          }
          newText += "leisure_results.push(" + exprText + ");";
        } else {
          newText += text.substring(expr.start, expr.end);
        }
      }
      newText += ";leisure_results;";
      console = {
        log: (function(_this) {
          return function(str) {
            return env.write(env.presentValue(str));
          };
        })(this)
      };
      return ((ref1 = env["eval"]) != null ? ref1 : localEval)(newText);
    };
    findError = function(err, text) {
      var col, i, len, line, n, ref, ref1, tot, txt, x;
      ref = err.match(/\(([0-9]*):([0-9]*)\)/), x = ref[0], line = ref[1], col = ref[2];
      line = Number(line - 1);
      tot = Number(col);
      ref1 = text.split('\n');
      for (n = i = 0, len = ref1.length; i < len; n = ++i) {
        txt = ref1[n];
        if (n === line) {
          break;
        } else {
          tot += txt.length + 1;
        }
      }
      return tot;
    };
    walk = window.Walk = function(node, func) {
      var type, v;
      v = {};
      for (type in acornWalk.base) {
        v[type] = func;
      }
      return acornWalk.simple(node, v, null);
    };
    isError = function(node) {
      return node.name === "âœ–";
    };
    handleErrors = function(ast, func) {
      return walk(ast, function(node) {
        if (isError(node)) {
          return func(node);
        }
      });
    };
    lsEnv = function(env) {
      env.executeText = function(text, props, cont) {
        var console, err, value;
        try {
          console = {
            log: (function(_this) {
              return function(str) {
                return env.write(env.presentValue(str));
              };
            })(this)
          };
          value = eval(lispyScript._compile(text));
          if (typeof value !== 'undefined') {
            writeValues(env, [value]);
          }
        } catch (_error) {
          err = _error;
          this.errorAt(0, err.message);
        }
        return typeof cont === "function" ? cont(env) : void 0;
      };
      return env;
    };
    csEnv = function(env) {
      env.executeText = function(text, props, cont) {
        var err, values;
        try {
          writeValues(env, values = jsEval(env, CS.compile(text, {
            bare: true
          })));
        } catch (_error) {
          err = _error;
          this.errorAt(0, err.message);
        }
        return typeof cont === "function" ? cont(values) : void 0;
      };
      return env;
    };
    Html = (function() {
      function Html(content) {
        this.content = String(content);
      }

      return Html;

    })();
    html = function(content) {
      return new Html(content);
    };
    errorDiv = function(err, orgText) {
      return "<span class='error' contenteditable='false'><span class='hidden'>" + (orgText || '') + "</span><span data-nonorg='true'>" + (escapeHtml(err)) + "</span></span>";
    };
    replacements = {
      '<': '&lt;',
      '>': '&gt;',
      '&': '&amp;',
      '"': '&quot;',
      "'": '&#39;'
    };
    escapeHtml = function(str) {
      if (typeof str === 'string') {
        return str.replace(/[<>&'"]/g, function(c) {
          return replacements[c];
        });
      } else {
        return str;
      }
    };
    knownLanguages = {
      leisure: leisureEnv,
      javascript: jsEnv,
      js: jsEnv,
      lisp: lsEnv,
      cs: csEnv,
      coffee: csEnv,
      coffeescript: csEnv
    };
    localEval = (function(html) {
      return function(x) {
        return eval(x);
      };
    })(html);
    languageEnvMaker = function(name) {
      return knownLanguages[name != null ? name.toLowerCase() : void 0];
    };
    blockVars = function(data, varDefs) {
      var bl, blockIds, eq, i, len, ref, ref1, ref2, v, value, vars;
      blockIds = {};
      vars = {};
      if (varDefs) {
        ref = (_.isArray(varDefs) ? varDefs : [varDefs]);
        for (i = 0, len = ref.length; i < len; i++) {
          v = ref[i];
          if ((eq = v.indexOf('=')) > 0) {
            value = v.substring(eq + 1).trim();
            if (ref1 = value[0], indexOf.call("'\"0123456789", ref1) >= 0) {
              value = JSON.parse(value);
            } else if (bl = data.getBlockNamed(value)) {
              blockIds[bl] = true;
              value = (ref2 = data.getBlock(bl)) != null ? ref2.yaml : void 0;
            } else {
              value = value.trim();
            }
            vars[v.substring(0, eq).trim()] = value;
          }
        }
      }
      return [vars, _.keys(blockIds)];
    };
    escaped = {
      '\b': "\\b",
      '\f': "\\f",
      '\n': "\\n",
      '\r': "\\r",
      '\t': "\\t",
      '\v': "\\v",
      '\"': "\\\"",
      '\\': "\\\\"
    };
    unescaped = _.zipObject((function() {
      var results1;
      results1 = [];
      for (c in escaped) {
        e = escaped[c];
        results1.push([e, c]);
      }
      return results1;
    })());
    specials = /[\b\f\n\r\t\v\"\\]/g;
    slashed = /\\./g;
    escapeString = function(str) {
      return String(str).replace(specials, function(c) {
        return escaped[c];
      });
    };
    unescapeString = function(str) {
      return String(str).replace(slashed, function(c) {
        var ref;
        return (ref = unescaped[c]) != null ? ref : c[1];
      });
    };
    return {
      languageEnvMaker: languageEnvMaker,
      html: html,
      Html: Html,
      escapeHtml: escapeHtml,
      blockVars: blockVars,
      knownLanguages: knownLanguages,
      presentHtml: presentHtml,
      escapeString: escapeString,
      unescapeString: unescapeString
    };
  });

}).call(this);

//# sourceMappingURL=eval.js.map
