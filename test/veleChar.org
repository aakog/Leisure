* Data
#+BEGIN_SRC leisure :results def
x = 3
#+END_SRC

#+NAME: character-sheet
#+BEGIN_SRC text :post formatted-character-sheet(*this*) :flowlevel -1 :results dynamic :exports code :index players name
name: NAME
ruche: RUCHE
character: PC_NAME

#+END_SRC
#+RESULTS:
: characters:
:   - allocatedRuche: 0
:     baseRuche: 0
:     composure: 2
:     cost: 0
:     health: 2
:     name: PC_NAME
:     type: character
: cost: 0
: extraRuche: RUCHE
: name: NAME
: type: character-sheet

#+BEGIN_HTML :var player=character-sheet
{{{view player}}}
#+END_HTML

#+BEGIN_SRC html :defview character-sheet
{{#condense}}
<div class='characterSheetHolder'>
  <div class='characterSheet'>
    {{#each errors}}
      <div class='error bx'>{{this}}</div>
    {{/each}}
    <div class='player bx'>{{name}} &#9;&#9;{{extraRuche}}</div><div class='characterName bx'>&#9;üåï {{characters.[0].name}} {{cost}}</div>
    {{#each characters}}
      {{#unless @first}}
        <div class='character bx'>üåï {{name}}{{#if attributes}} [{{#each attributes}}{{#unless @first}}, {{/unless}}{{capitalize this}}{{/each}}]{{/if}} {{cost}}</div>
      {{/unless}}
      <div class='ruche bx'><div class='current-ruche'></div><div class='max-ruche'>&nbsp;&#9;Max Ruche {{allocatedRuche}}</div></div>
      {{#if @first}}
        <div class='health bx'><table class='health stress-boxes'><tr><td class='stressLabel'>Health</td>{{#repeat health}}<td>&#9;<span class='hidden'>üûé</span></td>{{/repeat}}</tr></table></div>
        <div class='composure bx'><table class='composure stress-boxes'><tr><td class='stressLabel'>Comp</td>{{#repeat composure}}<td>&#9;<span class='hidden'>üûé</span></td>{{/repeat}}</tr></table></div>
      {{/if}}
      {{#each consequences}}
        <div class='consequence {{level}} bx'>‚ò†{{#if number}} {{number}}{{/if}} {{level}} {{capitalize name}}</div>
      {{/each}}
      {{#each aspects}}<div class='aspect bx'>‚ùÇ{{#if highConcept
        }} [High Concept{{#if attribute}}/{{capitalize attribute}}{{/if}}]{{else}}{{#if trouble
        }} [Trouble{{#if attribute}}/{{capitalize attribute}}{{/if}}]{{else}}{{#if attribute
        }} [{{capitalize attribute}}]{{/if}}{{/if}}{{/if
        }} {{capitalize name}}</div>
      {{/each}}
      {{#each traits}}<div class='trait bx{{#if focus
        }} focus'>‚óÜ {{capitalize focus}}{{
        else}}'>‚óá {{capitalize name}}{{/if
        }} d{{value}}{{#if stress}} {{stress}}{{/if}}</div>
        {{#each abilities}}
          <div class='ability bx'>‚ú´ {{capitalize name}}{{#if attribute
            }} [{{capitalize attribute}}]{{/if}}:{{#each effects
              }}{{capitalize type}} {{value}}{{#unless @last}},{{/unless}}{{/each}}</div>
        {{/each}}
      {{/each}}
    {{/each}}
  </div>
</div>
{{/condense}}
#+END_SRC
* code
:properties:
:hidden: true
:end:
#+NAME: formatted-character-sheet
#+BEGIN_SRC coffee :var player
do =>
  console.log "Lounge: ", Lounge
  if player != (cleanedPlayer = player.replace(/\t/g,' '))
    {opts, data, blockVars} = Lounge
    id = blockVars['*this*']._id
    debugger
    setTimeout (->
      block = opts.parsedCodeBlock id
      oldBlock = data.getBlock block.block._id
      source = block.items.source
      oldSrc = source.content
      block.setSource "#{source.text.substring 0, source.contentPos}#{cleanedPlayer}#{source.text.substring source.contentPos + oldSrc.length}"
      #block.block.yaml = undefined
      block.setResults ''
      # #data.getYaml(block.block)
      # #debugger
      # changes = opts.changesFor data.getFirst(), [oldBlock], [data.getBlock block.block._id]
      # block.block.code = changes.newBlocks[0].code
      # #data.getCode(block.block)()
      block.save true
      #old = {}
      #old[block.block._id] = oldBlock
      #opts.changed {oldBlocks: [oldBlock], newBlocks: [data.getBlock block.block._id], old}
    ), 10
    {}
  else
    result = @Vele.parse player
    result.type = 'character-sheet'
    if m = result.errors?[0]?.match /^(.*) on line ([0-9]+)/
      lines = player.split(/(\n)/)
      offset = 0
      for i in [0...Number(m[2]) + 1]
        offset = player.indexOf('\n', offset) + 1
      console.log "Error at #{offset}: #{m[1]}"
      Lounge?.errorAt offset, m[1]
    result
#+END_SRC

#+BEGIN_SRC coffee :results def
if !@Vele
  sloppyNameLine = /^\s*[0-9]*\s([^0-9 ]\S*)\s*([0-9]+)\s+(\S.*)(?:\s+[0-9]+\s*)$/
  ignorePat = /^[0-9]+\s+max ruche|^health|^comp|^[0-9]+ tmp/i
  tmpAspectPat = /^(?:\s|[0-9])*\btmp\b\s*(\S.*)?\s*$/
  basicLinePat = /^(\S+):(.*)$/
  aspectPat = /^(?:\[([^\/\]]+)(?:\/(.*))?\]\s+)?(\S.*)$/
  traitPat = /^(.*\S)\s+d([1468][02]?)(?:\s*\(\s*\+[0-9]+)?(?:\s*(composure|health))?(?:\s*\))?$/i
  highConceptPat = /^hc|high\s*concept$/
  troublePat = /^tr|trbl|trouble$/
  attributePat = /^order|purity|mercy|truth|nurture|creation|chaos|corruption|domination|scheming|strife|madness$/
  consequenceTypePat = /^(?:\s*[0-9]+)?\s*(mild|moderate|severe|extreme|tmp)(?:\s+(\S.*))?$/i
  abilityPat = /^([^\[\]:]*[^\[\]:\s])\s*(?:\[(.*)\])?:\s*(\S.*)$/
  effectPat = /^(.*\S)\s+([0-9]+)$/
  characterPat = /^([^\[\]]+?)\s*(?:\[(.*)\])?$/
  specialLinePat = /^(‚ùÇ|‚óÜ|‚óá|‚ú´|‚ò†|[^:\s]+\s*(?:[^:].*|$))(.*)$/
  consequenceValues = ['tmp', 'mild', 'moderate', 'severe', 'extreme']
  specialLineKeys =
    chars: "‚ùÇ‚óÜ‚óá‚ú´‚ò†"
    keys: ['aspect', 'focus', 'trait', 'ability', 'consequence']
  getLineKey = (line, sloppy)->
    line = line.trim()
    if m = line.match basicLinePat
      [..., key, value] = m
      {key, value: value.trim()}
    else if m = line.match specialLinePat
      [..., char, value] = m
      if char.length == 1 && (i = specialLineKeys.chars.indexOf(char)) != -1
        #debugger
        key: specialLineKeys.keys[i], value: value.trim()
      else key: 'character', value: char.trim()
    else {}
  cleanAspectType = (str)->
    str = str.trim().toLowerCase()
    if str.match highConceptPat then 'highConcept'
    else if str.match troublePat then 'trouble'
  cleanAttribute = (str)->
    str = str.trim().toLowerCase()
    if str.match attributePat then str
  capitalizeList = (list)-> item[0].toUpperCase() + item[1..] for item in list
  andIt = (list)->
    if list.length == 1 then list[0]
    else if list.length == 2 then list[0] + " and " + list[1]
    else _.dropRight(list).join(', ') + ", and " + _.last list
  class PlayerParser
    constructor: ->
      @value =
        characters: []
        cost: 0
    parse: (str)->
      error = false
      @lines = []
      usedSloppy = false
      for line, i in str.split('\n') when line.trim()
        @lines.push line
        @pos = i
        {key, value} = getLineKey line
        if @pos == 0 && m = line.match sloppyNameLine
          usedSloppy = true
          [ignore, playerName, ruche, pcName] = m
          @value.name = playerName
          @value.extraRuche = ruche
          #debugger
          @character pcName, line
        else if m = line.match tmpAspectPat then @consequence value, line, 'tmp', m[1]
        else if line.match ignorePat then continue
        else if key
          if !usedSloppy && @pos <= 1
            if @pos == 0 then @value.name = value
            else if @pos == 1 then @value.extraRuche = value
          else if this[key]
            try
              this[key].call this, value, line
            catch err
              debugger
              @addError "Error parsing line #{@pos}: #{line}\n#{err.stack}", true
          else @unknownKey key, @pos, line
        else @addError "Couldn't parse line #{@pos}: #{line}", true
      mainChar = @value.characters[0]
      for char, i in @value.characters
        @value.cost += char.cost = char.baseRuche + char.allocatedRuche
      aspectAttrs = (aspect.attribute for aspect in mainChar.aspects ? [] when aspect.attribute)
      mainAttrs = mainChar.attributes ? []
      for trait in mainChar.traits ? [] when trait.abilities
        for ability in trait.abilities when ability.attribute
          if !(ability.attribute in mainAttrs)
            mainAttrs.push ability.attribute
      for char in @value.characters[1..] when char.attributes
        for attr in char.attributes
          if !(attr in mainAttrs)
            mainAttrs.push attr
      if mainAttrs.length then mainChar.attributes = mainAttrs
      extra = (attr for attr in aspectAttrs when !(attr in mainAttrs))
      missing = (attr for attr in mainAttrs when !(attr in aspectAttrs))
      if extra.length then @addError "#{andIt capitalizeList extra} should not be in the PC aspects", true
      if missing.length then @addError "#{andIt capitalizeList missing} #{if missing.length == 1 then 'is' else 'are'} missing from the PC aspects", true
      @value
    addError: (err, noLocation)->
      if !noLocation then err = "#{err} on line #{@pos}: #{@lines[@pos]}"
      if !@value.errors then @value.errors = []
      @value.errors.push err
    unknownKey: (key, index, line)-> @addError "Unknown key: #{key}"
    character: (name, line, item)->
      @value.characters.push
        name: name
        baseRuche: 0
        allocatedRuche: 0
      if item then @curCharacter().type = 'item'
      else
        @curCharacter().type = 'character'
        @curCharacter().health = 2
        @curCharacter().composure = 2
      if (m = name.match characterPat) && m[2]
        if att = cleanAttribute m[2]
          @curCharacter().name = m[1]
          if !(att in @curAttributes()) then @curAttributes().push att
        else @addError "Couldn't parse attribute in name"
    item: (name, line)-> @character name, line, true
    curCharacter: -> _.last @value.characters
    owner: ->
      for char in @value.characters by -1
        if char.type == 'character' then return char
      null
    curTraits: -> @curCharacter().traits ? @curCharacter().traits = []
    curTrait: -> _.last @curCharacter().traits
    curAbilities: -> @curTrait().abilities ? @curTrait().abilities = []
    curAspects: -> @curCharacter().aspects ? @curCharacter().aspects = []
    curConsequences: -> @curCharacter().consequences ? @curCharacter().consequences = []
    curAttributes: -> @curCharacter().attributes ? @curCharacter().attributes = []
    currentRuche: (str)-> @curCharacter().currentRuche = Number str
    aspect: (str)->
      if str
        [..., primary, secondary, name] = str.match aspectPat
        aspect = {name}
        if primary
          if type = cleanAspectType primary
            aspect[type] = true
            if secondary
              if !(attribute = cleanAttribute secondary)
                return @addError "Unknown aspect attribute '#{secondary}'"
              aspect.attribute = attribute
              if !(attribute in @curAttributes()) then @curAttributes().push attribute
          else if aspect.attribute = cleanAttribute primary
            if !(aspect.attribute in @curAttributes()) then @curAttributes().push aspect.attribute
          else return @addError "Unknown aspect type or attribute '#{primary}'"
        @curAspects().push aspect
        @curCharacter().allocatedRuche++
    consequence: (str, line, type, name)->
      if !name && (m = str.match consequenceTypePat) then [ignore, type, name] = m
      if type
        @curConsequences().push
          level: type.toLowerCase()
          name: name ? ''
          number: consequenceValues.indexOf type.toLowerCase()
      else @addError "Couldn't parse consequence"
    focus: (str)-> @parseTrait 'focus', str
    trait: (str)-> @parseTrait 'name', str
    parseTrait: (tag, str)->
      if m = str.match traitPat
        [..., name, value, stress] = m
        obj = {value: Number value}
        obj[tag] = name
        if stress
          obj.stress = stress
          if obj.value in [8, 10] && @owner()[stress] < 3 then @owner()[stress] = 3
          else if obj.value == 12 && @owner()[stress] < 4 then @owner()[stress] = 4
        @curTraits().push obj
        @curCharacter().baseRuche += obj.value / 2 - 1
      else @addError "Couldn't parse trait"
    ability: (str)->
      if !@curTrait() then @addError "Attempt to create ability without a trait"
      else if m = str.match abilityPat
        [..., name, attribute, effectsStr] = m
        @curAbilities().push ability = {name, effects: []}
        if attribute
          if attr = cleanAttribute attribute
            ability.attribute = attr
            if !(attr in @curAttributes()) then @curAttributes().push attr
          else @addError "Couldn't parse attribute '#{attribute}'"
        if @curAbilities().length > 1 then @curCharacter().allocatedRuche += 3
        for effect, i in effectsStr.split /\s*,\s*/
          if m = effect.match effectPat
            ability.effects.push type: m[1], value: Number m[2]
            if ability.effects.length > 1 then @curCharacter().allocatedRuche += 3
            @curCharacter().allocatedRuche += Number m[2]
          else @addError "Couldn't parse effect ##{i}"
      else @addError "Couldn't parse ability"
  @Vele =
    parse: (str)-> new PlayerParser().parse(str)
#+END_SRC
* Helpers
:properties:
:hidden: true
:end:
#+BEGIN_SRC coffee :results def
Handlebars.registerHelper 'capitalize', (v)-> if v[0] then v[0].toUpperCase() + v[1..] else v
$('''
<a name="tc" target="_blank" href="http://www.teamcthulhu.com" class='tc-banner'>
  <button name="team_cthulhu" title="x">
    <span><img src="css/images/eldersign.png">TEAM CTHULHU</span>
  </button>
</a>
''').appendTo(document.body).find('button').button()
Handlebars.registerHelper 'repeat', (times, options)->
  (options.fn(this) for i in [0...Number times] by 1).join ''
#+END_SRC
* Styles
:properties:
:hidden: true
:end:
#+BEGIN_SRC css
@media print {
  [data-view=leisure-toolbar] {
    display: none;
  }
  .characterSheet {
    top: 1em;
  }
  [data-view=leisure-toolbar].collapse ~ .tc-banner {
    display: none !important;
  }
}
.tc-banner {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  z-index: 100;
  white-space: nowrap;
}
[data-view=leisure-toolbar].collapse ~ .tc-banner {
  display: initial;
}
[data-view=leisure-toolbar] {
  z-index: 2;
}
[data-view=leisure-toolbar].collapse + [maindoc] .characterSheetHolder {
  z-index: 99;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  background: white;
}
.error {
  white-space: normal;
  background: pink;
}
.characterSheetHolder {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 1;
}
[data-view=leisure-toolbar].collapse + [maindoc] .characterSheet {
  right: initial;
  left: 2em;
}
.characterSheet {
  width: 50ex;
  display: inline-flex;
  flex-wrap: wrap;
  position: absolute;
  top: 3em;
  right: 2em;
  z-index: 1;
}
.bx {
  border: solid black 1px;
  flex-basis: 100%;
  font-weight: bold;
  padding: 2px;
}
.player,
.characterName {
  display: inline-block;
  font-weight: bold;
}
.player {
  background: #0000ff;
  color: white;
  flex-basis: 20ex;
}
.characterName {
  flex-grow: 1;
  flex-basis: 10ex;
}
.current-ruche {
  display: inline-block;
  width: 5ex;
  height: 100%;
  border-right: solid black 2px;
  padding-top: 2px;
  padding-bottom: 2px;
}
.current-ruche::before {
  content: "\0000a0";
}
.max-ruche {
  display: inline-block;
  width: calc(100% - 5ex - 6px);
  padding-top: 2px;
  padding-bottom: 2px;
}
.max-ruche::before {
  /*content: "\0000a0Max Ruche ";*/
}
.stress-boxes {
  display: inline-table;
  border-collapse: collapse;
  margin: 1px;
}
.stress-boxes td {
    width: 2em;
    border: solid black 2px;
}
.stress-boxes td.stressLabel {
  background: #cccccc;
  border-color: #cccccc;
  border-right-color: black;
  width: 6ex;
}
.health, .composure {
  padding: 0;
  background: white;
}
.health .stress-boxes {
  background: #f4cccc;
}
.composure .stress-boxes {
  background: #c9daf8;
}
.ruche {
  background: #b6d7a8;
  padding: 0;
}
.character, .characterName {
  background: #c9daf8;
}
.trait {
  background: #a2c4c9;
  font-weight: bold;
}
.ability {
  background: #b6d7a8;
}
.aspect {
  background: #e7c9af;
}
.consequence {
  background: #ea9999;
}
#+END_SRC
