* Data
#+BEGIN_SRC leisure :results def
x = 3
#+END_SRC

#+NAME: character-sheet
#+BEGIN_SRC text :post formatted-character-sheet(*this*) :flowlevel -1 :results dynamic :exports code :index players name
3 Bill  34 Golden Monkey 51
7 Max Ruche 7
Health
Comp
0 tmp
0 tmp
☠ 2 mild
☠ 4 moderate
☠ 6 severe
☠ 8 extreme
❂ [HC/Truth] Agent of the Order
❂ [Trbl] On Loan from the Hand
❂ Harvester of Knowledge
❂ The Way of the Howler Monkey
❂
◆ Scrahv Ninja (not martial arts) d12
✫ Scrahv Implement [Truth]: Fiction 2
◇ Toughness d10
◇ Stony resilience d12 (+2 composure)
◇ Hand to Hand Combat d8
◇ Scholar d6
◇ Overly Reasonable d4
Mask of Disguise [Truth]
8 Max Ruche 8
◇ Seamless Finish d12
✫ Disguises: Create 8
#+END_SRC
#+RESULTS:
: characters:
:   - allocatedRuche: 6
:     aspects:
:       - attribute: truth
:         highConcept: true
:         name: Agent of the Order
:       - name: On Loan from the Hand
:         trouble: true
:       - name: Harvester of Knowledge
:       - name: The Way of the Howler Monkey
:     attributes:
:       - truth
:     baseRuche: 20
:     composure: 4
:     consequences:
:       - level: tmp
:         name: ''
:         number: 0
:       - level: tmp
:         name: ''
:         number: 0
:       - level: mild
:         name: ''
:         number: 2
:       - level: moderate
:         name: ''
:         number: 4
:       - level: severe
:         name: ''
:         number: 6
:       - level: extreme
:         name: ''
:         number: 8
:     cost: 26
:     health: 2
:     name: Golden Monkey
:     traits:
:       - abilities:
:           - attribute: truth
:             effects:
:               - type: Fiction
:                 value: 2
:             name: Scrahv Implement
:         focus: Scrahv Ninja (not martial arts)
:         value: 12
:       - name: Toughness
:         value: 10
:       - name: Stony resilience
:         stress: composure
:         value: 12
:       - name: Hand to Hand Combat
:         value: 8
:       - name: Scholar
:         value: 6
:       - name: Overly Reasonable
:         value: 4
:     type: character
:   - allocatedRuche: 8
:     attributes:
:       - truth
:     baseRuche: 5
:     composure: 2
:     cost: 13
:     health: 2
:     name: Mask of Disguise
:     traits:
:       - abilities:
:           - effects:
:               - type: Create
:                 value: 8
:             name: Disguises
:         name: Seamless Finish
:         value: 12
:     type: character
: cost: 39
: extraRuche: '34'
: name: Bill
: type: character-sheet

#+BEGIN_HTML :var player=character-sheet
{{{view player}}}
#+END_HTML

#+BEGIN_SRC html :defview character-sheet
{{#condense}}
<div class='characterSheetHolder'>
  <div class='characterSheet'>{{#each errors}}
      <div class='error bx'>{{this}}</div>
    {{/each}}<div class='player bx'>{{name}}<span data-noncontent>&nbsp;</span><span class='hidden'>&#9;&#9;</span>{{extraRuche}} </div><span class='hidden'>&#9;</span><div class='characterName bx'><span contenteditable='false' data-noncontent>🌕 </span><span class='hidden'>🌕 </span>{{characters.[0].name}} <span contenteditable='false' data-noncontent>{{cost}}</span><span class='hidden'>{{cost}}</span></div>{{#each characters}}
      {{#unless @first}}
        <div class='character bx'><span data-noncontent>🌕 </span><span class='hidden'>🌕 </span>{{name}}<span contenteditable='false'>{{#if attributes}} [{{#each attributes}}{{#unless @first}}, {{/unless}}{{capitalize this}}{{/each}}]{{/if}} {{cost}}</span></div>
      {{/unless}}
      <div class='ruche bx'><div class='current-ruche'></div><div class='max-ruche'><span class='hidden'>&#9;</span><span data-noncontent>&nbsp;Max Ruche </span><span class='hidden'>Max Ruche </span>{{allocatedRuche}}</div></div>
      {{#if @first}}
        <div class='health bx' contenteditable='false'><table class='health stress-boxes'><tr><td class='stressLabel'>Health</td>{{#repeat health}}<td><span class='hidden'>&#9;🞎</span></td>{{/repeat}}</tr></table></div>
        <div class='composure bx' contenteditable='false'><table class='composure stress-boxes'><tr><td class='stressLabel'>Comp</td>{{#repeat composure}}<td><span class='hidden'>&#9;🞎</span></td>{{/repeat}}</tr></table></div>
      {{/if}}
      {{#each consequences}}
        <div class='consequence {{level}} bx'><span data-noncontent>☠{{#if number}} {{number}}{{/if}} {{level}}</span><span class='hidden'>☠{{#if number}} {{number}}{{/if}} {{level}}</span>&nbsp;{{capitalize name}}
</div>{{/each}}{{#each aspects}}<div class='aspect bx'>❂{{#if highConcept
        }} [High Concept{{#if attribute}}/{{capitalize attribute}}{{/if}}]{{else}}{{#if trouble
        }} [Trouble{{#if attribute}}/{{capitalize attribute}}{{/if}}]{{else}}{{#if attribute
        }} [{{capitalize attribute}}]{{/if}}{{/if}}{{/if
        }}&nbsp;{{capitalize name}}</div>
      {{/each}}
      {{#each traits}}<div class='trait bx{{#if focus
        }} focus'>◆ {{capitalize focus}}{{
        else}}'>◇ {{capitalize name}}{{/if
        }} d{{value}}{{#if stress}} {{stress}}{{/if}}</div>
        {{#each abilities}}
          <div class='ability bx'>✫ {{capitalize name}}{{#if attribute
            }} [{{capitalize attribute}}]{{/if}}:{{#each effects
              }}{{capitalize type}} {{value}}{{#unless @last}},{{/unless}}{{/each}}</div>
        {{/each}}
      {{/each}}
    {{/each}}
  </div>
</div>
{{/condense}}
#+END_SRC

#+BEGIN_SRC coffee :control character-sheet
@initializeView = (view)->
  window.editor.useView view
#+END_SRC

#+BEGIN_SRC coffee :results def
{LeisureEditCore, BasicEditingOptions, preserveSelection, condenseHtml} = Leisure

class CharacterEditor extends BasicEditingOptions
  constructor: (@node, @options)->
    super()
    @blockId = @node.prop 'id'
    opts = this
    @data =
      getText: -> opts.blocks[opts.blockId].text
      getLength: -> opts.blocks[opts.blockId].text.length
      docOffsetForBlockOffset: (block, offset)->
        if typeof block == 'object' then block.offset else offset
      blockOffsetForDocOffset: (offset)->
        block: opts.blockId
        offset: offset
  idForNode: -> @blockId
  nodeForId: -> @node
  guiText: -> @editor.blockTextForNode @editor.node
  useView: (view)->
    console.log "EDITOR", @editor
    @originalId = view.closest('[data-observe]').attr('data-observe').trim()
    @node.html ''
    @node.append view
    @blocks[@blockId] =
      _id: @blockId
      text: @guiText()
  replaceText: ({start, end, text})->
    block = @options.parsedCodeBlock @originalId
    oldText = @guiText().replace(/\t/g, ' ')
    #debugger
    block.setSourceContent (oldText.substring(0, start) + text + oldText.substring end).trim().replace(/^\s*\n/gm, '') + '\n'
    preserveSelection -> block.save true

@sheet = $("<div></div>").insertAfter '[maindoc]'
@sheet.attr 'data-block', 'characterSheet'
@sheet.attr 'id', 'characterSheet'
leisureEditor = Leisure.findEditor $('[maindoc]')
@editor = new CharacterEditor @sheet, leisureEditor.options
new LeisureEditCore @sheet, @editor
#+END_SRC
* code
:properties:
:hidden: true
:end:
#+NAME: formatted-character-sheet
#+BEGIN_SRC coffee :var player
do =>
  console.log "Lounge: ", Lounge
  if player == window.lastPlayer then window.lastResult
  else if player != (cleanedPlayer = player.replace(/\t/g,' '))
    #debugger
    {opts, data, blockVars} = Lounge
    id = blockVars['*this*']._id
    setTimeout (->
      block = opts.parsedCodeBlock id
      oldBlock = data.getBlock block.block._id
      block.setSourceContent cleanedPlayer
      block.setResults ''
      block.save true
    ), 0
    {}
  else
    window.lastPlayer = player
    result = @Vele.parse player
    result.type = 'character-sheet'
    if m = result.errors?[0]?.match /^(.*) on line ([0-9]+)/
      lines = player.split(/(\n)/)
      offset = 0
      for i in [0...Number(m[2]) + 1]
        offset = player.indexOf('\n', offset) + 1
      console.log "Error at #{offset}: #{m[1]}"
      Lounge?.errorAt offset, m[1]
    window.lastResult = result
#+END_SRC

#+BEGIN_SRC coffee :results def
if !@Vele
  debugger
  sloppyNameLine = /^(?:\s|[0-9])*\b(\S.*)\s+([0-9]+)\s+(?:🌕\s*)?(?:(\S.*)\s+[0-9]+\s*|(\S.*))$/
  ignorePat = /^[0-9]*\s+max ruche|^health|^comp|^[0-9]+ tmp/i
  tmpAspectPat = /^(?:\s|[0-9])*\btmp\b\s*(\S.*)?\s*$/
  basicLinePat = /^([^:\s]+):(.*)$/
  aspectPat = /^(?:\[([^\/\]]+)(?:\/(.*))?\]\s+)?(\S.*)$/
  traitPat = /^(.*\S)\s+d([468]|10|12)(?:\s*\(\s*\+[0-9]+)?(?:\s*(composure|health))?(?:\s*\))?$/i
  highConceptPat = /^hc|high\s*concept$/i
  troublePat = /^tr|trbl|trouble$/i
  attributePat = /^order|purity|mercy|truth|nurture|creation|chaos|corruption|domination|scheming|strife|madness$/
  consequenceTypePat = /^(?:\s*[0-9]+)?\s*(mild|moderate|severe|extreme|tmp)(?:\s+(\S.*))?$/i
  abilityPat = /^([^\[\]:]*[^\[\]:\s])\s*(?:\[(.*)\])?:\s*(\S.*)$/
  effectPat = /^(.*\S)\s+([0-9]+)$/
  characterPat = /^([^\[\]]+?)\s*(?:\[(.*)\])?(?:\s*[0-9]+)\s*$/
  specialLinePat = /^(❂|◆|◇|✫|☠|🌕|)(.*)$/
  consequenceValues = ['tmp', 'mild', 'moderate', 'severe', 'extreme']
  specialLineKeys =
    chars: "❂◆◇✫☠🌕"
    keys: ['aspect', 'focus', 'trait', 'ability', 'consequence', 'item']
  getLineKey = (line, sloppy)->
    line = line.trim()
    if m = line.match specialLinePat
      [..., char, value] = m
      i = specialLineKeys.chars.indexOf(char)
      key: specialLineKeys.keys[i], value: value.trim()
    else if m = line.match basicLinePat
      [..., key, value] = m
      {key, value: value.trim()}
    else {}
  cleanAspectType = (str)->
    str = str.trim().toLowerCase()
    if str.match highConceptPat then 'highConcept'
    else if str.match troublePat then 'trouble'
  cleanAttribute = (str)->
    str = str.trim().toLowerCase()
    if str.match attributePat then str
  capitalizeList = (list)-> item[0].toUpperCase() + item[1..] for item in list
  andIt = (list)->
    if list.length == 1 then list[0]
    else if list.length == 2 then list[0] + " and " + list[1]
    else _.dropRight(list).join(', ') + ", and " + _.last list
  class PlayerParser
    constructor: ->
      @value =
        characters: []
        cost: 0
    parse: (str)->
      error = false
      @lines = []
      usedSloppy = false
      for line, i in str.split('\n') when line.trim()
        @lines.push line
        @pos = i
        {key, value} = getLineKey line
        if @pos == 0 && m = line.match sloppyNameLine
          usedSloppy = true
          [ignore, playerName, ruche, pcName, pcName2] = m
          pcName = pcName ? pcName2
          @value.name = playerName.trim()
          @value.extraRuche = ruche.trim()
          #debugger
          @character pcName.trim(), line
        else if m = line.match tmpAspectPat then @consequence value, line, 'tmp', m[1]
        else if line.match ignorePat then continue
        else if key
          if !usedSloppy && @pos <= 1
            if @pos == 0 then @value.name = value
            else if @pos == 1 then @value.extraRuche = value
          else if this[key]
            try
              this[key].call this, value, line
            catch err
              debugger
              @addError "Error parsing line #{@pos}: #{line}\n#{err.stack}", true
          else @unknownKey key, @pos, line
        else @addError "Couldn't parse line #{@pos}: #{line}", true
      mainChar = @value.characters[0]
      for char, i in @value.characters
        @value.cost += char.cost = char.baseRuche + char.allocatedRuche
      aspectAttrs = (aspect.attribute for aspect in mainChar.aspects ? [] when aspect.attribute)
      mainAttrs = mainChar.attributes ? []
      for trait in mainChar.traits ? [] when trait.abilities
        for ability in trait.abilities when ability.attribute
          if !(ability.attribute in mainAttrs)
            mainAttrs.push ability.attribute
      for char in @value.characters[1..] when char.attributes
        for attr in char.attributes
          if !(attr in mainAttrs)
            mainAttrs.push attr
      if mainAttrs.length then mainChar.attributes = mainAttrs
      extra = (attr for attr in aspectAttrs when !(attr in mainAttrs))
      missing = (attr for attr in mainAttrs when !(attr in aspectAttrs))
      if extra.length then @addError "#{andIt capitalizeList extra} should not be in the PC aspects", true
      if missing.length then @addError "#{andIt capitalizeList missing} #{if missing.length == 1 then 'is' else 'are'} missing from the PC aspects", true
      @value
    addError: (err, noLocation)->
      if !noLocation then err = "#{err} on line #{@pos}: #{@lines[@pos]}"
      if !@value.errors then @value.errors = []
      @value.errors.push err
    unknownKey: (key, index, line)-> @addError "Unknown key: #{key}"
    character: (name, line, item)->
      @value.characters.push
        name: name
        baseRuche: 0
        allocatedRuche: 0
      if item then @curCharacter().type = 'item'
      else
        @curCharacter().type = 'character'
        @curCharacter().health = 2
        @curCharacter().composure = 2
      if (m = name.match characterPat) && m[2]
        if att = cleanAttribute m[2]
          @curCharacter().name = m[1]
          if !(att in @curAttributes()) then @curAttributes().push att
        else @addError "Couldn't parse attribute in name"
    item: (name, line)-> @character name, line, true
    curCharacter: -> _.last @value.characters
    owner: ->
      for char in @value.characters by -1
        if char.type == 'character' then return char
      null
    curTraits: -> @curCharacter().traits ? @curCharacter().traits = []
    curTrait: -> _.last @curCharacter().traits
    curAbilities: -> @curTrait().abilities ? @curTrait().abilities = []
    curAspects: -> @curCharacter().aspects ? @curCharacter().aspects = []
    curConsequences: -> @curCharacter().consequences ? @curCharacter().consequences = []
    curAttributes: -> @curCharacter().attributes ? @curCharacter().attributes = []
    currentRuche: (str)-> @curCharacter().currentRuche = Number str
    aspect: (str)->
      if str
        [..., primary, secondary, name] = str.match aspectPat
        aspect = name: (name ? '').trim()
        if primary
          if type = cleanAspectType primary
            aspect[type] = true
            if secondary
              if !(attribute = cleanAttribute secondary)
                return @addError "Unknown aspect attribute '#{secondary}'"
              aspect.attribute = attribute
              if !(attribute in @curAttributes()) then @curAttributes().push attribute
          else if aspect.attribute = cleanAttribute primary
            if !(aspect.attribute in @curAttributes()) then @curAttributes().push aspect.attribute
          else return @addError "Unknown aspect type or attribute '#{primary}'"
        @curAspects().push aspect
        @curCharacter().allocatedRuche++
    consequence: (str, line, type, name)->
      if !name && (m = str.match consequenceTypePat) then [ignore, type, name] = m
      if type
        @curConsequences().push
          level: type.toLowerCase()
          name: (name ? '').trim()
          number: consequenceValues.indexOf(type.toLowerCase()) * 2
      else @addError "Couldn't parse consequence"
    focus: (str)-> @parseTrait 'focus', str
    trait: (str)-> @parseTrait 'name', str
    parseTrait: (tag, str)->
      if m = str.match traitPat
        [..., name, value, stress] = m
        obj = {value: Number value}
        obj[tag] = name
        if stress
          obj.stress = stress
          if obj.value in [8, 10] && @owner()[stress] < 3 then @owner()[stress] = 3
          else if obj.value == 12 && @owner()[stress] < 4 then @owner()[stress] = 4
        @curTraits().push obj
        @curCharacter().baseRuche += obj.value / 2 - 1
      else @addError "Couldn't parse trait"
    ability: (str)->
      if !@curTrait() then @addError "Attempt to create ability without a trait"
      else if m = str.match abilityPat
        [..., name, attribute, effectsStr] = m
        @curAbilities().push ability = {name, effects: []}
        if attribute
          if attr = cleanAttribute attribute
            ability.attribute = attr
            if !(attr in @curAttributes()) then @curAttributes().push attr
          else @addError "Couldn't parse attribute '#{attribute}'"
        if @curAbilities().length > 1 then @curCharacter().allocatedRuche += 3
        for effect, i in effectsStr.split /\s*,\s*/
          if m = effect.match effectPat
            ability.effects.push type: m[1], value: Number m[2]
            if ability.effects.length > 1 then @curCharacter().allocatedRuche += 3
            @curCharacter().allocatedRuche += Number m[2]
          else @addError "Couldn't parse effect ##{i}"
      else @addError "Couldn't parse ability"
  @Vele =
    parse: (str)-> new PlayerParser().parse(str)
#+END_SRC
* Helpers
:properties:
:hidden: true
:end:
#+BEGIN_SRC coffee :results def
Handlebars.registerHelper 'capitalize', (v)-> if v[0] then v[0].toUpperCase() + v[1..] else v
$('''
<a name="tc" target="_blank" href="http://www.teamcthulhu.com" class='tc-banner'>
  <button name="team_cthulhu" title="x">
    <span><img src="css/images/eldersign.png">TEAM CTHULHU</span>
  </button>
</a>
''').appendTo(document.body).find('button').button()
Handlebars.registerHelper 'space', (n)-> n == ' '
Handlebars.registerHelper 'repeat', (times, options)->
  (options.fn(this) for i in [0...Number times] by 1).join ''
#+END_SRC
* Styles
:properties:
:hidden: true
:end:
#+BEGIN_SRC css
@media print {
  [data-view=leisure-toolbar] {
    display: none;
  }
  .characterSheet {
    top: 1em;
  }
  [data-view=leisure-toolbar].collapse ~ .tc-banner {
    display: none !important;
  }
}
.tc-banner {
  display: none;
  position: fixed;
  top: 0;
  right: 0;
  z-index: 100;
  white-space: nowrap;
}
[data-view=leisure-toolbar].collapse ~ .tc-banner {
  display: initial;
}
[data-view=leisure-toolbar] {
  z-index: 2;
}
[data-view=leisure-toolbar].collapse ~ #characterSheet {
  z-index: 99;
  bottom: 0;
  left: 0;
  background: white;
}
.error {
  white-space: normal;
  background: pink;
}
#characterSheet {
  position: absolute;
  top: 0;
  right: 0;
  z-index: 1;
  Xwhite-space: pre;
}
[data-view=leisure-toolbar].collapse ~ #characterSheet .characterSheet {
  right: initial;
  left: 2em;
}
.characterSheet {
  width: 50ex;
  display: inline-flex;
  flex-wrap: wrap;
  position: absolute;
  top: 3em;
  right: 2em;
  z-index: 1;
}
.bx {
  border: solid black 1px;
  flex-basis: 100%;
  font-weight: bold;
  padding: 2px;
}
.player,
.characterName {
  display: inline-block;
  font-weight: bold;
}
.player {
  background: #0000ff;
  color: white;
  flex-basis: 20ex;
}
.characterName {
  flex-grow: 1;
  flex-basis: 10ex;
}
.current-ruche {
  display: inline-block;
  width: 5ex;
  height: 100%;
  border-right: solid black 2px;
  padding-top: 2px;
  padding-bottom: 2px;
}
.current-ruche::before {
  content: "\0000a0";
}
.max-ruche {
  display: inline-block;
  width: calc(100% - 5ex - 6px);
  padding-top: 2px;
  padding-bottom: 2px;
}
.max-ruche::before {
  /*content: "\0000a0Max Ruche ";*/
}
.stress-boxes {
  display: inline-table;
  border-collapse: collapse;
  margin: 1px;
}
.stress-boxes td {
    width: 2em;
    border: solid black 2px;
}
.stress-boxes td.stressLabel {
  background: #cccccc;
  border-color: #cccccc;
  border-right-color: black;
  width: 6ex;
}
.health, .composure {
  padding: 0;
  background: white;
}
.health .stress-boxes {
  background: #f4cccc;
}
.composure .stress-boxes {
  background: #c9daf8;
}
.ruche {
  background: #b6d7a8;
  padding: 0;
}
.character, .characterName {
  background: #c9daf8;
}
.trait {
  background: #a2c4c9;
  font-weight: bold;
}
.ability {
  background: #b6d7a8;
}
.aspect {
  background: #e7c9af;
}
.consequence {
  background: #ea9999;
}
#+END_SRC
