// Generated by CoffeeScript 1.10.0
(function() {
  var Nil, Promise, SM, SourceNode, _, ast2Json, asyncMonad, defaultEnv, errorString, evalInput, fs, gen, genSource, getLeisurePromise, getMonadSyncMode, getParseErr, getType, getValue, identity, isIO, jsCodeFor, json2Ast, lazy, lc, leisurePromise, lz, newCall, readFile, ref, ref1, ref2, ref3, ref4, ref5, replEnv, replaceErr, requireFiles, requirePromise, requirejs, resolve, root, runMonad2, rz, setDataType, setMegaArity, setType, setWarnAsync, simpleEval, sourceNode, tangle, withFile, writeFile;

  SM = require('source-map-support');

  SM.install();

  requirejs = require('requirejs');

  ((typeof window !== 'undefined' && window) || global).Lazy = requirejs('lib/lazy');

  Error.stackTraceLimit = Infinity;

  ref = root = module.exports = requirejs('./base'), newCall = ref.newCall, resolve = ref.resolve, lazy = ref.lazy, defaultEnv = ref.defaultEnv;

  rz = resolve;

  lz = lazy;

  lc = Leisure_call;

  _ = requirejs('lodash');

  fs = require('fs');

  ref1 = requirejs('./ast'), getType = ref1.getType, setType = ref1.setType, setDataType = ref1.setDataType, ast2Json = ref1.ast2Json, json2Ast = ref1.json2Ast, Nil = ref1.Nil;

  global.btoa = require('btoa');

  ref2 = requirejs('./gen'), gen = ref2.gen, genSource = ref2.genSource, withFile = ref2.withFile, sourceNode = ref2.sourceNode, SourceNode = ref2.SourceNode, setMegaArity = ref2.setMegaArity;

  ref3 = require('./node'), readFile = ref3.readFile, writeFile = ref3.writeFile;

  ref4 = requirejs('./runtime'), identity = ref4.identity, runMonad2 = ref4.runMonad2, isIO = ref4.isIO, asyncMonad = ref4.asyncMonad, replaceErr = ref4.replaceErr, getMonadSyncMode = ref4.getMonadSyncMode, setWarnAsync = ref4.setWarnAsync, requireFiles = ref4.requireFiles, getValue = ref4.getValue;

  Promise = requirejs('bluebird').Promise;

  ref5 = requirejs('./tangle'), tangle = ref5.tangle, jsCodeFor = ref5.jsCodeFor;

  global.setType = setType;

  global.setDataType = setDataType;

  global.defaultEnv = defaultEnv;

  global.identity = identity;

  getParseErr = function(x) {
    return x(lz(function(value) {
      return rz(value);
    }));
  };

  replEnv = {
    __proto__: defaultEnv,
    prompt: function(msg, cont) {
      return rl.question(msg, function(x) {
        var err, error;
        try {
          return cont(x);
        } catch (error) {
          err = error;
          return console.log("ERROR HANDLING PROMPT: " + err.stack);
        }
      });
    },
    presentValue: function(x) {
      return show(x) + '\n';
    }
  };

  errorString = function(err) {
    var ref6, s;
    if (L$thunkStack) {
      s = L$thunkStack.join('\n   at ');
      (typeof global !== "undefined" && global !== null ? global : window).L$thunkStack = [];
      return err.toString() + ":\n   at " + s;
    } else {
      return (ref6 = err.stack) != null ? ref6 : err.toString();
    }
  };

  process.on('uncaughtException', function(err) {
    return console.log("Uncaught Exception: " + (errorString(err)));
  });

  requirePromise = function(file) {
    return new Promise(function(resolve, reject) {
      return requirejs([file], resolve);
    });
  };

  leisurePromise = null;

  getLeisurePromise = function() {
    if (!leisurePromise) {
      leisurePromise = requirePromise('./leisure/generatedPrelude').then(function() {
        return requirePromise('./leisure/std');
      }).then(function() {
        return simpleEval('resetStdTokenPacks');
      })["catch"](function(err) {
        return console.error("ERROR LOADING LEISURE SYSTEM!\n" + err.stack);
      });
    }
    return leisurePromise;
  };

  evalInput = function(text) {
    if (text) {
      return getLeisurePromise().then(function() {
        return simpleEval(text);
      });
    } else {
      return succeed('');
    }
  };

  simpleEval = function(text) {
    return new Promise(function(succeed, fail) {
      var err, error, result;
      try {
        result = lc(L_newParseLine, 0, Nil, text);
        return runMonad2(result, replEnv, function(ast) {
          var err, error, source;
          try {
            if (getType(ast) === 'err') {
              return fail(new Error("PARSE ERORR: " + (getParseErr(ast))));
            } else {
              source = genSource(text, ast);
              result = eval(source);
              if (isIO(result)) {
                console.log("(processing IO monad)");
              }
              return runMonad2(result, replEnv, function(result) {
                return succeed({
                  ast: ast,
                  source: source,
                  result: result
                });
              });
            }
          } catch (error) {
            err = error;
            return fail(new Error(errorString(err)));
          }
        });
      } catch (error) {
        err = error;
        return fail(new Error(errorString(err)));
      }
    });
  };

  module.exports = {
    evalInput: evalInput
  };

}).call(this);

//# sourceMappingURL=replBase.js.map
