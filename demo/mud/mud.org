#+TITLE:CthulhuMUD
* Setup
:properties:
:hidden: true
:end:
** Import utilities
:properties:
:import: utilities.org
:end:
* Test
:properties:
:namespace: mud.core
:end:

#+BEGIN_SRC wisp :results dynamic
;(map even? '(1 2 3 4))
;(String '(1 2 3 a))
(lens a b) 
;3
#+END_SRC
#+ERROR: 25, lensProperty is not defined

#+BEGIN_SRC wisp :results dynamicX
(transaction->
  (update (:_id 3 :name "bubba"))
  ...
  (custom frob)))
;; -> (let [t1  (Transaction.)
            t2  (update (:_id 3 :name "bubba"))
            ...
            tN  (frob tM)
            tO  (tr-check tM tN)]
            tO)
#+END_SRC

* Sample MUD Object
#+NAME: ExampleFred
#+BEGIN_SRC yaml :index location location
id: mud-10
type: thing
name: fred
prefix: hungry
title: the barbarian
description: Fred is a nice guy.  Tea and crumpets at your place?
activity: Looking for food
location: mud-3
#+END_SRC
* Sample MUD Code
#+BEGIN_SRC wisp
  ;; Declare collaborative code
  (defcollab munge
    "Munge some data"
    []
    (tr-commit
      (transaction->
       fred <- (get "ExampleFred")
       joe <- (get "ExampleJoe")
       (do
         (aset (:hunger joe) 12)
         (aset (:height fred) 3))
       (custom frobnicate joe)))

  ;; possibility 1
  (defn frobnicate
    "frobnicate a person"
    [transaction person]
    (let [newHp (- (:hitpoints person) 1)]
      (aset (:hitpoints person) newHp)
      (tr-update transaction person)))

  ;; possibility 2
  (defn frobnicate
    "frobnicate a person"
    [transaction person]
    (let [newHp (- (:hitpoints person) 1)]
      (aset (:hitpoints person) newHp)
      (transaction-> transaction
        (update person))))

#+END_SRC
* GUI
#+BEGIN_HTML :controller consoleController
<div class="worldContainer">
    <div class="leftSide">
        rooms
    </div>
    <div class="rightSide">
        <div class="textLog">
            Text log
        </div>
        <div class="commandEntry">
            Enter command:<br>
            <input class="commandInput" type="text">
        </div>
    </div>
</div>
#+END_HTML
* Plumbing
:properties:
:namespace: mud.core
:end:
** Mud state
#+NAME: mudState
#+BEGIN_SRC yaml
currentId: 0
#+END_SRC
** Basics
#+NAME: Basics
#+BEGIN_SRC wisp :results def
  (defmacro collaboratively [name & args] `(.doCollaboratively data (.-name ~name) ~args))
  (defn registerCollaborativeFuncs [& funcs] (map #(.registerCollaborativeCode data %1) funcs))
  (defmacro defcollab
    [name args & body]
    (let [doc (if (string? args) args "")
          args (if (string? args) (first body) args)
          body (if (string? args) (rest body) body)]
      `(do
         (defn ^{:doc ~doc} ~name ~args ~@body)
         (.openRegistration data)
         (registerCollaborativeFuncs ~name)
         (.closeRegistration data))))
  (defn nextId []
    (let [game (.getData data "mudState")
          id (+ 1 (:currentId game))]
      (.log window.console "currentId: " id)
      (set! (:currentId game) id)
      (.setData data "gameState" game)
      id))
#+END_SRC

#+NAME: DataBasics
#+BEGIN_SRC wisp :results def
  (def data-headline "data-items")
  (def location-index "location")
  (def location-property "location")
  (defn createObject [object]
    (.appendDataToHeadline data
                           data-headline object.id
                           object
                           {:flowLevel 3 :index "location location"}))
  (defn updateObject [object]
    (.setData data
              object.id
              object
              {:flowLevel 3 :index "#{location-index} #{location-property}"}))
  (defn deleteObject [id] (.removeData data id))
  (defn getObject [id] (.getData data id))
  (defn getContents [id] (.find data location-index id))
#+END_SRC

** Lenses
*** Examples
#+BEGIN_SRC wisp :results dynamic
(JSON/stringify (lens-set (lens a b c) {:a {:b {:c 3 :d 5} :e 7}} 4))
(JSON/stringify (lens-set (lens 0) [2 3 4] 7))
(lens-get (lens a 1) {:a [2 3 4]})
#+END_SRC
#+RESULTS:
: {&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:4,&quot;d&quot;:5},&quot;e&quot;:7}}
: [7,3,4]
: 3
*** Code
#+BEGIN_SRC wisp :results def
(defn- no-colon
  [sym]
  (let [n (name sym)]
    (if (== ":" (first n))
      (rest n)
      n)))

(defn named?
  "Is this a named thing?"
  [x]
  (or (symbol? x) (keyword? x) (string? x)))
#+END_SRC

#+BEGIN_SRC wisp :results def
  (defn- Lens
    "Lens type"
    [get set description]
    (set! this.get get)
    (set! this.set set)
    (set! this.description description)
    this)

  (set! Lens.prototype.toString
        (fn []
          (join (concat ["(lens"]
                        [(if (empty? this.description) "" " ")]
                        (intersperse this.description " ")
                        [")"]))))

  (defn o
    "Compose 2 functions of one variable"
    [f1 f2]
    (fn [x] (f1 (f2 x))))

  (defn lens-empty
    []
    (Lens. identity identity []))

  (def lens-parsers
    "Sequence of lens parsers"
    [])

  (defn parse-lens
    "Parse lens entry"
    [entry]
    (let [parser (find #((:predicate %) entry)  lens-parsers)]
      (if parser
        ((:definition parser) entry)
        (throw (Error. (str "Lens could parse " (String entry)))))))

  (defn lens-compose
    "Compose lenses"
    [l1 l2]
    (if (empty? (:description l1))
      l2
      (let [l1get (.-get l1)
            l1set (.-set l1)
            l2get (.-get l2)
            l2set (.-set l2)]
        (Lens.
         (o l2get l1get)
         (fn [obj val] (l1set obj (l2set (l1get obj) val)))
         (concat (.-description l1) (.-description l2))))))

  (defn lens-get
    "Get a value from an object"
    [lens obj]
    (.get lens obj))

  (defn lens-set
    "Put a value into a object"
    [lens obj value]
    (.set lens obj value))

  ;(.alert window "******* ADD TRANSACTION SUPPORT TO LENSES *******")

#+END_SRC

#+BEGIN_SRC wisp :results def
  (defmacro deflens-parser 
    "Add a lens parser to the lens builder"
    [predicate definition]
    `(set! lens-parsers (conj lens-parsers {:predicate ~predicate :definition ~definition})))

  (deflens-parser ;;; properties
    #(named? %)
    (fn
      [prop]
      (Lens.
       (fn [obj] (aget obj prop))
       (fn [obj val] (let [newObj (cond (dictionary? obj) (Object/assign (Object.) obj)
                                        (vector? obj) (.slice obj))]
                       (aset newObj prop val)
                       newObj))
       [prop])))

  (deflens-parser ;;; transactions
    #(and (sequential? %) (named (first %))  (== "transaction" (name (first %))))
    (fn
      [id]
      (Lens.
       (fn [trans] (tr-get trans id)
         (fn [trans val] (tr-update val))
         [`(transaction ~id)]))))

  (defmacro lens
    "Make a lens on some data"
    [& ops]
    (reduce (fn [l1 l2] (lens-compose l1 l2)) (map parse-lens ops)))

  (defmacro lensX
    [& ops]
    (loop [ops ops
           result ()]
      (if (empty? ops)
        result
        (let [op (first ops)
              newLens (cond (named? op) `(lens-property ~(no-colon op))
                            (number? op) `(lens-property ~op)
                            :else (throw (Error. (str "Bad lens operation: " op))))]
          (recur (rest ops) (if (empty? result)
                              newLens
                              `(lens-compose ~result ~newLens)))))))

#+END_SRC
*** Tests
#+BEGIN_SRC wisp
(lens a)
#+END_SRC
#+ERROR: 1, lens is not defined


#+RESULTS:
: 
** Transactions
*** Transaction-> macro
**** (transaction-> STATEMENT ...)
*** Transastion-> standard statements
**** (clearIndex INDEX)
**** (update DATA/SEQUENCE ...) -- makes a transaction with a copy of the data
**** (remove DATA/ID/SEQUENCE ...)
**** VAR <- (get ID)
**** VAR <- (find INDEX)
**** VAR <- (find INDEX ID)
**** [VAR VALUE ...]
**** (do STATEMENT ...) -- for side effects, return value is ignored
**** (custom func arg arg arg ...)
***** func is given transaction as first arg
***** must return either the given transaction or a child of it
*** Examples
#+BEGIN_SRC wisp
  ;(defCollab)
  (defn test1
    "Move an object from one place to another"
    []
    (transaction->
     (clearIndex "id")
     fred <- (tget "ExampleFred")
     [name (tget (lens name) fred)]
     (do (print (str "Name: " name)))))

  (defn test2
    "Move an object from one place to another"
    []
    (transaction->
     (clearIndex "id")
     (tlet
      [fred (tr-get "ExampleFred")]
      (let
          [name (:name fred)]
          (print name)
          (set! (:name fred) "Charles"))
      :then
      (tr-update fred))))
#+END_SRC
*** Utilities
#+BEGIN_SRC wisp :results def
  (defn each-nested
    "Do side effects over a nested list of vectors"
    [func & items]
    (.forEach (flatten items) func))

  (defn flatten
    "Flatten nested sequences"
    [& items]
    (let [result []
          stack []]
      (loop [item items]
        (if (and (sequence? item) (not (string? item)) (not (imap? item)) (not (empty? item)))
          (do
            (.push stack (rest item))
            (recur (first item)))
          (do
            (if (or (not (sequence? item)) (string? item))
              (.push result item))
            (if (empty? stack)
              result
              (recur (.pop stack))))))))
#+END_SRC

tests
#+BEGIN_SRC wisp
(= [1 2 3 4 5 6 7 8] (flatten [[1 2] [[3]] 4] 5 [6 [7 [8]]]))
#+END_SRC
*** Code
#+BEGIN_SRC wisp :results def
  (defn- Transaction
    "Transaction type:
      parent - parent transaction
      updates - map of id->object
      removes - set of ids
      gets - map of id->object
      names - map of name->id"
    [parent creates updates removes gets names indexer]
    (set! this.parent parent)
    (set! this.creates (or (and creates (imap creates)) (iset [])))
    (set! this.updates (or (and updates (imap updates)) (imap {})))
    (set! this.removes (or (and removes (iset removes)) (iset [])))
    (set! this.gets (or (and gets (imap gets)) (imap {})))
    (set! this.names (or (and names (imap names)) (imap {})))
    (set! this.indexer (or indexer (.copy (:indexer data))))
    this)

  (defn- tr-string
    "Convert a transaction to a string (toString())"
    []
    (str "(transaction "
         (JSON/stringify (.toObject (:creates this))) " "
         (JSON/stringify (.toObject (:updates this))) " "
         (JSON/stringify (.toArray (:removes this))) " "
         (JSON/stringify (.toObject (:gets this))) " "
         (JSON/stringify (.toObject (:names this)))
         ")"))
  (set! Transaction.prototype.toString tr-string)

  (set! Transaction.transactionNumber 0)

  (defn- tcopy
    "Copy a transaction"
    [creates updates removes gets names indexer]
    (Transaction.
     this
     (or creates this.creates)
     (or updates this.updates)
     (or removes this.removes)
     (or gets this.gets)
     (or names this.names)
     (or indexer this.indexer)))
  (set! Transaction.prototype.copy tcopy)

  (defn transaction
    "Create a transaction"
    [creates updates removes gets names]
    (Transaction. nil creates updates removes gets names))

  (defn tr->json
    "convert a transaction to JSON"
    [trans]
    {:creates (.toArray (:creates trans))
     :updates (.toObject (:updates trans))
     :removes (.toArray (:removes trans))
     :gets (.toObject (:gets trans))
     :names (.toObject (:names trans))})

  (defn json->tr
    "Create a transaction from a JSON representation"
    [json]
    (Transaction.
     (iset (:creates json))
     (imap (:updates json))
     (iset (:removes json))
     (imap (:gets json))
     (imap (:names json))
     (indexAll (:gets json) (:updates json))))

  (defn indexAll
    "Create indexer for dictionaries of blocks"
    [& blockDicts]
    (let [indexer (.copy (:indexer data))]
      (doseq [dict blockDicts]
        (doseq [key (keys dict)]
          (let [block (aget dict key)]
            (if (:keys block)
              (set! indexer (.addBlockKey (:id block :key key)))))))
      indexer))

  (defn tr-update
    "Update or insert data"
    [trans & objects]
    (let [objects (flatten objects)
          oldGets (:gets trans)
          oldUpdates (:updates trans)
          oldObjects (map #(.tr-get %) objects)]
      debugger
      (.copy trans
             (:creates trans)
             (.withMutations ;;; updates
              oldUpdates
              (fn [map]
                (doseq [item objects] (.set map (:_id item) item))
                map))
             (.withMutations ;;; removes
              (:removes trans)
              (fn [set]
                (doseq [item objects] (.delete set item))
                set))
             nil ;;; gets
             (.withMutations ;;; names
              (:names trans)
              (fn [map]
                (doseq [item objects
                        oldItem oldObjects]
                  (let [name (:codeName item)
                        oldName (and oldItem (:codeName oldItem))]
                    (if (not (== name oldName))
                      (if oldName
                        (set! map (.delete map oldName)))
                      (if name (.set map name (:_id item))))))
                map))
             (let [indexer (:indexer trans)] ;;; indexer
               (doseq [item objects
                       oldItem oldObjects]
                 (if oldItem
                   (doseq [key (.keysFor indexer oldItem)]
                     (set! indexer (.deleteBlockKey key))))
                 (doseq [key (.keysFor indexer item)]
                   (set! indexer (.addBlockKey key))))
               indexer))))

  (defn tr-remove
    "Remove data -- arguments can be names, ids, or objects"
    [trans & things]
    (let [updates (:updates trans)
          creates (:creates trans)
          items (map #(tr-get %) (filter #(.contains updates %) (flatten things)))
          ids (map #(:_id %) items)]
      (.copy trans
             (.withMutations ;;; creates
              creates
              (fn [creates] (doseq [id ids] (.remove creates id))))
             (.withMutations ;;; updates
              updates
              (fn [updates] (doseq [id ids] (.remove updates id))))
             (.withMutations ;;; removes
              (:removes trans)
              (fn [removes]
                (doseq [item (filter #(not (.contains creates %)) ids)]
                  (.add removes item))))
             nil ;;; gets
             (.withMutations ;;; names
              (:names trans)
              (fn [names]
                (doseq [item items]
                  (let [id (:_id item)
                        name (:codeName item)]
                    (if name
                      (.remove names name))))))
             (let [indexer (:indexer trans)] ;;; indexer
               (doseq [item items]
                 (doseq [key (.keysFor indexer item)]
                   (set! indexer (.deleteBlockKey key))))
               indexer))))

  (defn tr-read
    "Read data into the transaction.
    (tr-read trans ids) -> [newTransaction, data1, data2, ...]
    (tr-read trans ids func) -> result of (func newTransaction, data1, data2, ...)
    ids is can actually be a combination of names and ids"
    ([trans ids func] (apply func (tr-read ids)))
    ([trans ids]
     (let [removes (:removes trans)
           updates (:updates trans)
           gets (:gets trans)
           allIds (flattenIds)
           filteredIds (filter #(tr-realId %) allIds)
           filteredIds (filter #(and id (not (or (.contains removes %)
                                                 (.contains updates %))) ids))
           newGets (filter identity (map #(.getBlock data (or (.getNamedBlockId data %) %) filteredIds)))
           named (filter #(:codeName %) newGets)
           newTrans (if (empty? newGets)
                      trans
                      (.copy trans null null null
                             (.withModifications
                              (:gets trans)
                              (fn [gets] (doseq [item newGets]
                                           (.set gets (:_id item) item))))
                             (if (empty? named)
                               null
                               (.withModifications
                                (:names trans)
                                (fn [names] (doseq [item named]
                                              (.set names (:codeName item) (:_id item))))))))]
       (let [result (map #(tr-get %) allIds)]
         (.unshift result newTrans)
         result))))

  (defn tr-find
    "Find data in an index"
    [trans index key]
    (tr-get trans func (.find (:indexer trans) index key)))

  (defn tr-clearIndex
    "Remove data in an index"
    [trans indexName]
    (tr-remove trans (tr-find trans indexName)))

  (defn tr-realId
    "Get real Id for a thing"
    [trans thing]
    (let [id (if (dictionary? thing) (:_id thing) thing)]
      (and (string? id)
           (or (.get (:names trans) id)
               (.getNamedBlockId data id)
               id))))

  (defn tr-get
    "Get a thing"
    [trans thing]
    (let [id (tr-realId thing)]
      (and id
           (not (.contains (:removes trans) id))
           (or (.get (:updates trans) id)
               (.get (:gets trans id))))))

  (defn tr-check
    "If an object is a transaction, return it, otherwise raise an error"
    [value errMsg]
    (if (instance? Transaction value) value
        (let [err (Error. (str errMsg value))]
          (.error window.console errMsg value)
          (.error window.console err)
          (throw err))))

  (defn tr-valid?
    "Verify that all of a transaction's gets are still valid"
    [trans]
    (every (fn [block]
             (let [curBlock (.getBlock data (:_id block))]
               (and curBlock
                    (== (:text block) (:text curBlock)))))
           (values (:gets trans))))

  (defn tr-commit
    "Commit a transaction"
    [trans]
    (tr-check trans "Attempt to commit an object that is not a transaction: ")
    (doseq [update (:updates trans)]
      (.baseSetData data update (:codeAttributes update)))
    (doseq [del (:removes trans)]
      (.baseRemoveData data del)))
#+END_SRC
*** Transaction macro examples
**** get usages
#+BEGIN_SRC wisp
  (transaction-> (Transaction.)
   [a b c] <- (get "bob" "fred" "joe")
   (do (print a b c))
   ...)
#+END_SRC
**** get generated code
#+BEGIN_SRC wisp
(let [T1 (transaction)
      RETRIEVE (tr-retrieve T1 "bob" "fred" "joe")
      T2 (aget RETRIEVE 0)
      a (aget RETRIEVE 1)
      b (aget RETRIEVE 2)
      c (aget RETRIEVE 3)]
  (print a b c)
  ...)
#+END_SRC
**** update usages
#+BEGIN_SRC wisp
  (transaction-> (Transaction.)
   (update a b c)
   ...)
#+END_SRC
**** update generated code
#+BEGIN_SRC wisp
********************
#+END_SRC
**** custom usages
#+BEGIN_SRC wisp
(transaction-> (Transaction.)
  (custom frobnicate x y z)
  ...)
#+END_SRC
**** custom generated code
#+BEGIN_SRC wisp
  (let [T1 (transaction)
        T2 (tr-check (frobnicate T1 x y z))]
    ...)
#+END_SRC
*** Transaction macro code
#+BEGIN_SRC wisp :results def
  (defn insert-arg
    "Insert an item as the first arg in an expr"
    [arg expr]
    (if (seq? expr)
      (cons (first expr) (cons arg (rest expr)))
      (list expr arg)))

  (defn filter-lets
    "Arrow through transaction exprs using let bindings"
    [body func]
    (let [vars []]
      (loop [exprs body
             lastExpr nil
             lastVar nil]
        (if (empty? exprs)
          (if (empty? vars) (or lastExpr lastVar) `(let ~vars ~lastExpr))
          (let [expr (first exprs)
                expr (if lastVar
                       (insert-arg lastVar expr)
                       expr)
                expr (if func (func expr) expr)]
            (if lastExpr (.push vars lastVar lastExpr))
            (recur (rest exprs)
                   (if (or lastVar func) expr)
                   (if (or lastVar func)
                     (gensym)
                     expr)))))))

  (def transactionArrowErrMsg
    "transaction-> expression returned an object that is not a transaction: ")
#+END_SRC

#+BEGIN_SRC wisp :results def
  (defmacro transaction->
    "Arrow through transaction exprs, verifying that each value is a transaction"
    [& body]
    (filter-lets body #(list 'tr-check % 'transactionArrowErrMsg)))

  (defmacro do->
    "Do side effects and return the result of the first expression"
    [expr & body]
    (if (empty? body)
      expr
      (let [name (gensym)]
        `(let [~name ~expr]
           ~@body
           ~name))))
#+END_SRC
*** Transaction macro tests
#+BEGIN_SRC wisp
(macroexpand '(transaction->))
(macroexpand '(transaction-> a))
(macroexpand '(transaction-> a b))
(macroexpand '(transaction-> a b (c d)))
(macroexpand '(side-effects a b c))
#+END_SRC
*** Example code
#+BEGIN_SRC wisp
  (tr-commit
   (transaction-> (Transaction.)
    (tr-read ["fred" "bob"]
             (fn [trans fred bob]
               (aset (:))))))
#+END_SRC
* GUI
:properties:
:namespace: mud.core
:end:
#+BEGIN_SRC css
    .worldContainer {
        height: 480px;
        position: relative;
        width: 640px;
    }
    .leftSide {
        border: 1px solid #777;
        height: 470px;
        left: 5px;
        position: absolute;
        top: 5px;
        width: 310px;
    }
    .rightSide {
        border: 1px solid #777;
        height: 470px;
        position: absolute;
        right: 5px;
        top: 5px;
        width: 310px;
    }
    .textLog {
        border: 1px solid #777;
        height: 385px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        width: 290px;
    }
    .commandEntry {
        border: 1px solid #777;
        height: 50px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        top: 400px;
        width: 290px;
    }
    input.commandInput {
        width: 290px;
    }
#+END_SRC

#+NAME: consoleController
#+BEGIN_SRC wisp
 (defn init [view]
   (let [input (aget (.find ($ view) ".commandInput") 0)]
     (.addEventListener
      input "keydown"
      (fn [e]
        (.stop-propagation e)))
     (.addEventListener
      input "keypress"
      (fn [e]
        (.stop-propagation e)))))

 (set! this.initializeView init)
#+END_SRC

#+BEGIN_HTML :controller consoleController
<div class="worldContainer">
    <div class="leftSide">
        rooms
    </div>
    <div class="rightSide">
        <div class="textLog">
            Text log
        </div>
        <div class="commandEntry">
            Enter command:<br>
            <input class="commandInput" type="text">
        </div>
    </div>
</div>
#+END_HTML

* Parser
:properties:
:namespace: mud.core
:end:
* Utilites
* NOTES
** Unit testing
*** Make doc for each test dungeon
*** Import mud.org (hopefully nested imports work)
* Data
:properties:
:name: data-items
:end:
