#+TITLE:CthulhuMUD
* Setup
:properties:
:hidden: true
:end:
** Import utilities
:properties:
:import: utilities.org
:end:
* Test
:properties:
:namespace: mud.core
:end:
Replace a.b.c with 4 in this object

#+BEGIN_SRC wisp :results dynamic

#+END_SRC

* Sample MUD Object
#+NAME: ExampleFred
#+BEGIN_SRC yaml :index location location
id: mud-10
type: thing
name: fred
prefix: hungry
title: the barbarian
description: Fred is a nice guy.  Tea and crumpets at your place?
activity: Looking for food
location: mud-3
#+END_SRC
* Sample MUD Code
#+BEGIN_SRC wisp
  ;; Declare collaborative code
  (defcollab munge
    "Munge some data"
    [x]
    (transaction->
     (transaction<-retrieve "ExampleFred")
     (transaction<-update )))

#+END_SRC
* GUI
#+BEGIN_HTML :controller consoleController
<div class="worldContainer">
    <div class="leftSide">
        rooms
    </div>
    <div class="rightSide">
        <div class="textLog">
            Text log
        </div>
        <div class="commandEntry">
            Enter command:<br>
            <input class="commandInput" type="text">
        </div>
    </div>
</div>
#+END_HTML
* Plumbing
:properties:
:namespace: mud.core
:end:
** Mud state
#+NAME: mudState
#+BEGIN_SRC yaml
currentId: 0
#+END_SRC
** Basics
#+NAME: Basics
#+BEGIN_SRC wisp :results def
  (defmacro collaboratively [name & args] `(.doCollaboratively data (.-name ~name) ~args))
  (defn registerCollaborativeFuncs [& funcs] (map #(.registerCollaborativeCode data %1) funcs))
  (defmacro defcollab
    [name args & body]
    (let [doc (if (string? args) args "")
          args (if (string? args) (first body) args)
          body (if (string? args) (rest body) body)]
      `(do
         (defn ^{:doc ~doc} ~name ~args ~@body)
         (.openRegistration data)
         (registerCollaborativeFuncs ~name)
         (.closeRegistration data))))
  (defn nextId []
    (let [game (.getData data "mudState")
          id (+ 1 (:currentId game))]
      (.log window.console "currentId: " id)
      (set! (:currentId game) id)
      (.setData data "gameState" game)
      id))
#+END_SRC

#+NAME: DataBasics
#+BEGIN_SRC wisp :results def
  (def data-headline "data-items")
  (def location-index "location")
  (def location-property "location")
  (defn createObject [object]
    (.appendDataToHeadline data
                           data-headline object.id
                           object
                           {:flowLevel 3 :index "location location"}))
  (defn updateObject [object]
    (.setData data
              object.id
              object
              {:flowLevel 3 :index "#{location-index} #{location-property}"}))
  (defn deleteObject [id] (.removeData data id))
  (defn getObject [id] (.getData data id))
  (defn getContents [id] (.find data location-index id))
#+END_SRC

** Lenses
*** Examples
#+BEGIN_SRC wisp :results dynamic
(JSON/stringify (lens-set (lens a b c) {:a {:b {:c 3 :d 5} :e 7}} 4))
(JSON/stringify (lens-set (lens 0) [2 3 4] 7))
(lens-get (lens a 1) {:a [2 3 4]})
#+END_SRC
#+RESULTS:
: {&quot;a&quot;:{&quot;b&quot;:{&quot;c&quot;:4,&quot;d&quot;:5},&quot;e&quot;:7}}
: [7,3,4]
: 3
*** Code
#+BEGIN_SRC wisp :results def
(defn- no-colon
  [sym]
  (let [n (name sym)]
    (if (== ":" (first n))
      (rest n)
      n)))

(defn named?
  "Is this a named thing?"
  [x]
  (or (symbol? x) (keyword? x) (string? x)))
#+END_SRC

#+BEGIN_SRC wisp :results def
  (defn- Lens
    "Lens type"
    [get set description]
    (set! this.get get)
    (set! this.set set)
    (set! this.description description)
    this)

  (set! Lens.prototype.toString
        (fn []
          (join (concat ["(lens"]
                        [(if (empty? this.description) "" " ")]
                        (intersperse this.description " ")
                        [")"]))))

  (defn o
    "Compose 2 functions of one variable"
    [f1 f2]
    (fn [x] (f1 (f2 x))))

  (defn lens-empty
    []
    (Lens. identity identity []))

  (defn lens-property
    [prop]
    (Lens.
     (fn [obj] (aget obj prop))
     (fn [obj val] (let [newObj (cond (dictionary? obj) (Object/assign (Object.) obj)
                                      (vector? obj) (.slice obj))]
                     (aset newObj prop val)
                     newObj))
     [prop]))

  (defn lens-compose
    "Compose two lenses"
    [l1 l2]
    (if (empty? (:description l1))
      l2
      (let [l1get (.-get l1)
            l1set (.-set l1)
            l2get (.-get l2)
            l2set (.-set l2)]
        (Lens.
         (o l2get l1get)
         (fn [obj val] (l1set obj (l2set (l1get obj) val)))
         (concat (.-description l1) (.-description l2))))))

  (defmacro lens
    "Make a lens on some data"
    [& ops]
    (loop [ops ops
           result ()]
      (if (empty? ops)
        result
        (let [op (first ops)
              newLens (cond (named? op) `(lens-property ~(no-colon op))
                            (number? op) `(lens-property ~op)
                            :else (throw (Error. (str "Bad lens operation: " op))))]
          (recur (rest ops) (if (empty? result)
                              newLens
                              `(lens-compose ~result ~newLens)))))))

  (defn lens-get
    "Get a value from an object"
    [lens obj]
    (.get lens obj))

  (defn lens-set
    "Put a value into a object"
    [lens obj value]
    (.set lens obj value))
#+END_SRC
** Transactions
*** Transaction-> macro
**** (transaction-> STATEMENT ...)
*** Transastion-> standard statements
**** (clearIndex INDEX)
**** (update DATA/SEQUENCE ...) -- makes a transaction with a copy of the data
**** (remove DATA/ID/SEQUENCE ...)
**** VAR <- (get ID)
**** VAR <- (find INDEX)
**** VAR <- (find INDEX ID)
**** [VAR VALUE ...]
**** (do STATEMENT ...) -- for side effects, return value is ignored
*** Transaction-> custom s-exprs (not matching standard statements)
**** transaction is passed in as first argument as with -> macro
**** must return a (possibly new) transaction -- this is verified
*** Examples
#+BEGIN_SRC wisp
  ;(defCollab)
  (defn test1
    "Move an object from one place to another"
    []
    (transaction->
     (clearIndex "id")
     fred <- (tget "ExampleFred")
     [name (tget (lens name) fred)]
     (do (print (str "Name: " name)))))

  (defn test2
    "Move an object from one place to another"
    []
    (transaction->
     (clearIndex "id")
     (tlet
      [fred (transaction<-get "ExampleFred")]
      (let
          [name (:name fred)]
          (print name)
          (set! (:name fred) "Charles"))
      :then
      (transaction<-update fred))))
#+END_SRC
*** Code
#+BEGIN_SRC wisp :results def
  (defn- Transaction
    "Transaction type"
    [updates removes gets names]
    (set! this.updates (or updates (imap [])))
    (set! this.removes (or removes (iset [])))
    (set! this.gets (or gets (imap [])))
    (set! this.names (or names (imap [])))
    this)

  (set! Transaction.transactionNumber 0)

  (defn- tcopy
    "Copy a transaction"
    [updates removes gets names]
    (Transaction.
     (or updates this.updates)
     (or removes this.removes)
     (or gets this.gets)
     (or names this.names)))
  (set! Transaction.prototype.copy tcopy)

  (defn each-nested
    "Do side effects over a nested list of vectors"
    [func & items]
    (loop
        [item (first items)
         nextItems (rest items)]
      (if (vector? item)
        (recur (first item) (conj nextItems (rest item)))
        (do
          (func item)
          (recur (first nextItems) (rest nextItems))))))

  (defn transaction
    "Create a transaction"
    [] (Transaction.))

  (defn transaction<-update
    "Update or insert data"
    [trans & objects]
    (.copy trans
           (.withMutations
            (:updates this)
            (fn (map) (each-nested #(.set map (.-_id %) %) objects)))
           (.delete (:removes this) (:_id object))))

  (defn transaction<-remove
    "Remove data"
    [trans id]
    (let [id (if (dictionary? id) (:_id id) id)]
      (.copy trans
       (.delete (:updates this) id)
       (.add (:removes this) id))))

  (defn transaction<-retrieve
    "Retrieve data into the transaction, try by name first and then id."
    [trans id]
    (let [block (or (.getData data id) (.getBlock data id))
          newSets (.set (:gets trans) (:_id block) block)
          newNames (if (:codeName block)
                     (.set (:names trans) (:codeName block) (:id block))
                     (:names trans))]
      (.copy trans null null newSets newNames)))

  (defn transaction<-retrieveAll
    "Retrieve data for all of the ids into the transaction"
    [trans ids]
    ;(reduce retrieveIntoTransaction trans ids)
    (reduce transaction<-retrieve trans ids))

  (defn transaction<-find
    "Find data in an index"
    [trans index key]
    (.find data index key))

  (defn transaction<-clearIndex [trans indexName]
    (reduce remove trans (.find data indexName)))

  (defn transaction-get
    "Access data in the transaction"
    [trans id]
    (.get (:gets trans) (or (.get (:names trans) id) id)))

  (defn transaction-accessAll
    "Access all requested data in the transaction"
    [trans ids]
    (map #(transaction-access trans %) ids))

  (defn transaction-check
    "If an object is a transaction, return it, otherwise raise an error"
    [trans]
    (if (instance? Transaction trans) trans
        (throw (Error. (str "Object returned in transaction-> is not a Transaction: " trans)))))

  (defn transaction-valid?
    "Verify that all of a transaction's gets are still valid"
    [trans]
    (every (fn [block]
             (let [curBlock (.getBlock data (:_id block))]
               (and curBlock
                    (== (:text block) (:text curBlock)))))
           (values (:gets trans))))

  (defn transaction-commit
    "Commit a transaction"
    [trans]
    (doseq [update (:updates trans)]
      (.baseSetData data update (:codeAttributes update)))
    (doseq [del (:removes trans)]
      (.baseRemoveData data del)))
#+END_SRC
*** Transaction macro
#+BEGIN_SRC wisp :results def
  (defmacro transaction->
    "Do expressions with a new transaction"
    [& body]
    (let [body (reverse body)
          altered (reduce (fn [result x] (cons x (cons '(transaction-check) result))) () body)]
      `(-> (Transaction.) trans ~@altered)))
#+END_SRC
* GUI
:properties:
:namespace: mud.core
:end:
#+BEGIN_SRC css
    .worldContainer {
        height: 480px;
        position: relative;
        width: 640px;
    }
    .leftSide {
        border: 1px solid #777;
        height: 470px;
        left: 5px;
        position: absolute;
        top: 5px;
        width: 310px;
    }
    .rightSide {
        border: 1px solid #777;
        height: 470px;
        position: absolute;
        right: 5px;
        top: 5px;
        width: 310px;
    }
    .textLog {
        border: 1px solid #777;
        height: 385px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        width: 290px;
    }
    .commandEntry {
        border: 1px solid #777;
        height: 50px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        top: 400px;
        width: 290px;
    }
    input.commandInput {
        width: 290px;
    }
#+END_SRC

#+NAME: consoleController
#+BEGIN_SRC wisp
 (defn init [view]
   (let [input (aget (.find ($ view) ".commandInput") 0)]
     (.addEventListener
      input "keydown"
      (fn [e]
        (.stop-propagation e)))
     (.addEventListener
      input "keypress"
      (fn [e]
        (.stop-propagation e)))))

 (set! this.initializeView init)
#+END_SRC

#+BEGIN_HTML :controller consoleController
<div class="worldContainer">
    <div class="leftSide">
        rooms
    </div>
    <div class="rightSide">
        <div class="textLog">
            Text log
        </div>
        <div class="commandEntry">
            Enter command:<br>
            <input class="commandInput" type="text">
        </div>
    </div>
</div>
#+END_HTML

* Parser
:properties:
:namespace: mud.core
:end:
* Utilites
* Data
:properties:
:name: data-items
:end:
