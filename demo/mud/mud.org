#+TITLE:CthulhuMUD
* Setup
:properties:
:hidden: true
:end:
** Import utilities
:properties:
:import: utilities.org
:end:

* GUI
#+BEGIN_HTML :controller consoleController
<div class="worldContainer">
    <div class="leftSide">
        rooms
    </div>
    <div class="rightSide">
        <div class="textLog">
            Text log
        </div>
        <div class="commandEntry">
            Enter command:<br>
            <input class="commandInput" type="text">
        </div>
    </div>
</div>
#+END_HTML

* GUI
:properties:
:namespace: mud.core
:end:
#+BEGIN_SRC css
    .worldContainer {
        height: 480px;
        position: relative;
        width: 640px;
    }
    .leftSide {
        border: 1px solid #777;
        height: 470px;
        left: 5px;
        position: absolute;
        top: 5px;
        width: 310px;
    }
    .rightSide {
        border: 1px solid #777;
        height: 470px;
        position: absolute;
        right: 5px;
        top: 5px;
        width: 310px;
    }
    .textLog {
        border: 1px solid #777;
        height: 385px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        width: 290px;
    }
    .commandEntry {
        border: 1px solid #777;
        height: 50px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        top: 400px;
        width: 290px;
    }
    input.commandInput {
        width: 290px;
    }
#+END_SRC

** Mocks
#+BEGIN_SRC wisp :results def
  (defn- Game
    "Game type"
    []
    (set! this.listeners {})
    this
  )
  (set! Game.prototype.emit (fn [event] (.log window.console (+ "Sending " (:data event)))))
  (set! Game.prototype.addListener (fn [type listener] (
    (if (not (aget this.listeners type))
      (aset this.listeners :type listener))
  )))
  (def game (Game. ))
  (defn sendCommand
    "Send Command"
    [game c]
    (.emit game {:type "output" :data c}))
#+END_SRC

** Game Setup
#+BEGIN_SRC wisp :results def

#+END_SRC

** Controller
#+NAME: consoleController
#+BEGIN_SRC wisp :results def
 (defn init [view]
   (let [input (aget (.find ($ view) ".commandInput") 0)]
     (.addEventListener
      input "keydown"
      (fn [e]
        (.stop-propagation e)))
     (.addEventListener
      input "keypress"
      (fn [e]
        (.stop-propagation e)
        (if (== e.keyCode 13)
          (do
            (sendCommand game (:value input))
            (set! (:value input) "")
        ))))))

 (set! this.initializeView init)
#+END_SRC

* Test
:properties:
:namespace: mud.core
:end:
#+NAME: errorTest
This produces an unexpected token ) error because it terminates the push
incorrectly.
#+BEGIN_SRC wisp
((fn [x] x) 1)
#+END_SRC

#+BEGIN_SRC wisp :results dynamic
(sum 1 2)
#+END_SRC

#+BEGIN_SRC wisp :results dynamicX
(reduce + [1 2 3])
#+END_SRC
* Data format
** Mud objects
#+BEGIN_SRC yaml :index location location
id: mud-10
type: thing
name: fred
prefix: hungry
title: the barbarian
description: Fred is a nice guy
activity: hopping around
location: mud-3
#+END_SRC
* Plumbing
:properties:
:namespace: mud.core
:end:
#+NAME: mudState
#+BEGIN_SRC yaml
currentId: 0
#+END_SRC
#+NAME: Basics
#+BEGIN_SRC wisp :results def
  (defmacro collaboratively [name & args] `(.doCollaboratively data (.-name ~name) ~args))
  (defn registerCollaborativeFuncs [funcs] (map #(.registerCollaborativeCode data %1) funcs))
  (defn nextId []
    (let [game (.getData data "mudState")
          id (+ 1 (:currentId game))]
      (.log window.console "currentId: " id)
      (set! (:currentId game) id)
      (.setData data "gameState" game)
      id))
#+END_SRC

#+NAME: DataBasics
#+BEGIN_SRC wisp :results def
  (def data-headline "data-items")
  (def location-index "location")
  (def location-property "location")
  (defn createObject [object]
    (.appendDataToHeadline data
                           data-headline object.id
                           object
                           {:flowLevel 3 :index "location location"}))
  (defn updateObject [object]
    (.setData data
              object.id
              object
              {:flowLevel 3 :index "#{location-index} #{location-property}"}))
  (defn deleteObject [id] (.removeData data id))
  (defn getObject [id] (.getData data id))
  (defn getContents [id] (.find data location-index id))
  (defn vec [coll]
    )
#+END_SRC

* Parser
:properties:
:namespace: mud.core
:end:
* Utilites
* Data
:properties:
:name: data-items
:end:
