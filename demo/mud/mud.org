#+TITLE:CthulhuMUD
* Data format
** Mud objects
#+BEGIN_SRC yaml :index location location
id: mud-10
type: thing
name: fred
prefix: hungry
title: the barbarian
description: Fred is a nice guy
activity: hopping around
location: mud-3
#+END_SRC
* Setup
:properties:
:hidden: true
:end:
#+BEGIN_SRC wisp :results def
  (ns mud.core
    (:require
     [wisp.runtime :refer [print]]
     [wisp.ast :refer [symbol symbol? keyword? keyword name namespace
                       gensym unquote? unquote-splicing? quote?
                       syntax-quote? quote-string pr-str]]
     [wisp.sequence :refer [lazy-seq lazy-seq? list? list cons
                            sequential? reverse map filter reduce
                            count empty? first second third rest
                            last butlast take take-while drop conj
                            assoc concat seq seq? vec sort repeat
                            every? some partition interleave nth]]
     ))
  (def data Lounge.data)
#+END_SRC
* Plumbing
:properties:
:namespace: mud.core
:end:
#+NAME: mudState
#+BEGIN_SRC yaml
currentId: 0
#+END_SRC

#+BEGIN_SRC wisp :results def
  (defmacro collaboratively [name & args] `(.doCollaboratively data (.-name ~name) ~args))
  (defn registerCollaborativeFuncs [funcs] (map #(.registerCollaborativeCode data %1) funcs))
  (defn nextId []
    (let [game (.getData data "mudState")
          id (+ 1 (:currentId game))]
      (.log window.console "currentId: " id)
      (set! (:currentId game) id)
      (.setData data "gameState" game)
      id))
#+END_SRC

* GUI
:properties:
:namespace: mud.core
:end:
#+BEGIN_SRC css
    .worldContainer {
        height: 480px;
        position: relative;
        width: 640px;
    }
    .leftSide {
        border: 1px solid #777;
        height: 470px;
        left: 5px;
        position: absolute;
        top: 5px;
        width: 310px;
    }
    .rightSide {
        border: 1px solid #777;
        height: 470px;
        position: absolute;
        right: 5px;
        top: 5px;
        width: 310px;
    }
    .textLog {
        border: 1px solid #777;
        height: 385px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        width: 290px;
    }
    .commandEntry {
        border: 1px solid #777;
        height: 50px;
        margin: 5px;
        padding: 5px;
        position: absolute;
        top: 400px;
        width: 290px;
    }
    input.commandInput {
        width: 290px;
    }
#+END_SRC

#+NAME: consoleController
#+BEGIN_SRC wisp
 (defn init [view]
   (let [input (aget (.find ($ view) ".commandInput") 0)]
     (.addEventListener
      input "keydown"
      (fn [e]
        (.stop-propagation e)))
     (.addEventListener
      input "keypress"
      (fn [e]
        (.stop-propagation e)))))

 (set! this.initializeView init)
#+END_SRC

#+BEGIN_HTML :controller consoleController
<div class="worldContainer">
    <div class="leftSide">
        rooms
    </div>
    <div class="rightSide">
        <div class="textLog">
            Text log
        </div>
        <div class="commandEntry">
            Enter command:<br>
            <input class="commandInput" type="text">
        </div>
    </div>
</div>
#+END_HTML

* Parser
:properties:
:namespace: mud.core
:end:
* Utilites
#+BEGIN_SRC wisp :results def
  (defn sum [& args]
    (loop [tot 0
           a args]
      (if (empty? a)
        tot
        (recur (+ tot (first a)) (rest a)))))
  (defn multiply [& args]
    (loop [tot 1
           a args]
      (if (empty? a)
        tot
        (recur (* tot (first a)) (rest a)))))
  (defn subtract [& args]
    (if (empty? args)
      (throw (Error "Wrong number of arguments (0) passed to: subtract"))
      (loop [tot (first args)
             a (rest args)]
        (if (empty? a)
          tot
          (recur (- tot (first a)) (rest a))))))
  (defn divide [& args]
    (if (empty? args)
      (throw (Error "Wrong number of arguments (0) passed to: divide"))
      (loop [tot (first args)
             a (rest args)]
        (if (empty? a)
          tot
          (recur (/ tot (first a)) (rest a))))))
  (defn strict-equal? [& args]
    (if (or (empty? args) (empty? (rest args)))
      (throw (Error (str "Wrong number of arguments (" (.-length args)  ") passed to: strict-equal?")))
      (let [target (first args)]
        (loop [a (rest args)]
          (cond (empty? a) true
                (not (== target (first a))) false
                :else (recur (rest a)))))))
  (defn- gt [name args]
    (loop [min (first args)
           a (rest args)]
      (if (empty? a)
        true
        (and (> min (first a)) (recur (first a) (rest a))))))
  (defn- lt [name args]
    (loop [max (first args)
           a (rest args)]
      (if (empty? a)
        true
        (and (< max (first a)) (recur (first a) (rest a))))))
  (defn not-greater-than [& args] (not (gt "not-greater-than" args)))
  (defn greater-than [& args] (gt "greater-than" args))
  (defn not-less-than [& args] (not (lt "not-less-than" args)))
  (defn less-than [& args] (lt "less-than" args))
  (print "utilties")
#+END_SRC
