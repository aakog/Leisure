#+TITLE: Data access
* Transaction code
The basic transaction object.

#+BEGIN_SRC leisure :results def
transaction creates reads updates deletes data = \f . f creates reads updates deletes data
emptyTransaction = transaction hamt{} hamt{} 
isTransaction t = hasType t transaction

trCreates transaction = transaction \creates reads updates deletes data . creates
trReads transaction = transaction \creates reads updates deletes data . reads
trUpdates transaction = transaction \creates reads updates deletes data . updates
trDeletes transaction = transaction \creates reads updates deletes data . deletes
trData transaction = transaction \creates reads updates deletes data . data

defCase showBase.transaction func obj | isTransaction obj -> obj \creates reads updates deletes data .
  concat['(transaction ' (showBase func creates) ' ' (showBase func reads) ' ' (showBase func updates) ' ' (showBase func deletes) ')']

defCase toJson.transaction tr | isTransaction tr -> tr \creates reads updates deletes data .
  toJsonObject {
    'type':'transaction'
    'creates':(toJson creates)
    'reads':(toJson reads)
    'updates':(toJson updates)
    'deletes':(toJson deletes)}

currentTransaction = do
  tr <- envGetOpt 'transaction'
  tr id do
    tr = 

trGet name = do
  transaction <- currentTransaction
  valueOpt = getOpt name (trData transaction)
  valueOpt id do
    d <- getDataUnsafe name
    
#+END_SRC

#+BEGIN_SRC leisure :results dynamic
isSet (setAdd 'a' amtSet)
#+END_SRC
#+ERROR: 0, ReferenceError: err is not defined
#+RESULTS:
: ERROR: 
: 
: Parse error: L_isSet is not defined
: CODE: 
: (
: resolve(L_isSet)(function(){&quot;use strict&quot;;return resolve(L_setAdd)(&quot;a&quot;, L_amtSet);}))
: //# sourceMappingURL=data:application/json;utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImR5bmFtaWMgY29kZSB3aXRoIHNvdXJjZSAyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBLGlCQUFPLGlEQUFPLEdBQVAsRUFBVyxRQUFYLEdBQVAiLCJmaWxlIjoiZHluYW1pYyBjb2RlIHdpdGggc291cmNlIiwic291cmNlc0NvbnRlbnQiOlsiaXNTZXQgKHNldEFkZCAnYScgYW10U2V0KSJdfQ==
: 
: AST: anno(\@filename notebook-39 . isSet (setAdd a amtSet))

* Collaborative code
#+BEGIN_SRC leisure :results def
mungeBubbaNumber env n = do
  debug
  b <- getData 'bubba'
  setData 'bubba' (set 'number' n b)
makeCollaborative mungeBubbaNumber
#+END_SRC

#+BEGIN_SRC leisure :results dynamic
mungeBubbaNumber 28
#+END_SRC


#+BEGIN_SRC leisure :results dynamic
do
  b <- getDataUnsafe 'bubba'
  c = set 'number' 5 b
  print c
#+END_SRC
#+RESULTS:
: {"number":5 "name":"bubba"}
: 

#+NAME: bubba
#+BEGIN_SRC yaml
name: bubba
number: 34
#+END_SRC

#+NAME: fred
#+BEGIN_SRC yaml
name: fred
number: 2
#+END_SRC

#+BEGIN_SRC leisure :results dynamic
set 'a' 1 {}
#+END_SRC
#+RESULTS:
: {"a":1}

#+BEGIN_SRC leisure :results dynamic
do
  i <- for repeat 4
  print i
  i
#+END_SRC
#+RESULTS:
: 0
: 1
: 2
: 3
: [0 1 2 3]


#+BEGIN_SRC leisure :results dynamic
#+END_SRC


* Transactions
Minimalistic collaborative transactions. Since we execute collaborative code on
the master peer, we'd like to execute as much code on the slave peers as possible. So,
we have a transaction object that records the assumptions in a transaction, along with
transaction
