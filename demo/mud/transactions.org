#+TITLE: Data access
* Scratch
#+BEGIN_SRC leisure :results dynamic
do
  currentTransaction
  trCreate 'bubba' []
#+END_SRC



#+RESULTS:
: (transaction [bubba] [] [] [])
* Page maxes out memory if left for too long when there's a major stack trace
* Or something
* 
* Transaction code
The basic transaction object.

#+BEGIN_SRC leisure :results def
transaction creates reads updates deletes data errors = \f .
  f creates reads updates deletes data errors

emptyTransaction = transaction set[] map{} set[] set[] map{} dl[]

isTransaction t = hasType t transaction

trEmpty transaction = transaction \c r u d data errs .
  and[
    empty c
    empty r
    empty u
    empty d
    empty errs]

trCreates transaction = transaction \c r u d data errs . c
trReads transaction = transaction \c r u d data errs . r
trUpdates transaction = transaction \c r u d data errs . u
trDeletes transaction = transaction \c r u d data errs . d
trData transaction = transaction \c r u d data errs . data
trErrs transaction = transaction \c r u d data errs . errs

trNoErrs transaction = empty (trErrs transaction)

trSetData data tr = tr \c r u d data errs .
  transaction c r u d data errs
  unit

nlist l = s['[' (join (tolist l) ' ') ']']

defCase showBase.transaction func obj | isTransaction obj ->
  (trEmpty obj) '(transaction)'
    obj \c r u d data errs . do
      r = map head (tolist r)
      s = s['(transaction ' (nlist c) ' ' (nlist r) ' ' (nlist u) ' ' (nlist d)]
      s[s ((empty errs) '' s[' ' (showBase func (tolist errs))]) ')']

defCase toJson.transaction tr | isTransaction tr ->
  tr \c r u d data errs .
    toJsonObject {
      'type':'transaction'
      'creates':(toJson c)
      'reads':(toJson r)
      'updates':(toJson u)
      'deletes':(toJson d)
      'errs':(toJson errs)}

currentTransaction = do
  tr <- envGetOpt 'transaction'
  tr id (setTransaction emptyTransaction)

setTransaction trans = do
  envSet 'transaction' trans
  trans

trCreate name value = do
  trans <- currentTransaction
  trNoErrs trans
  trans \c r u d data errs . setTransaction
    transaction (conj name c) r u d (set name value data) errs

trRead name = do
  trans <- currentTransaction
  trNoErrs trans
  valueOpt = getOpt name (trData trans)
  valueOpt id do
    value <- getDataUnsafe name
    trans \c r u d data errs . setTransaction
      transaction c (set name value r) u d (set name value data) errs
    value

trUpdate name value = do
  trans <- currentTransaction
  trNoErrs trans
  trans \c r u d data errs . do
    u = (contains name c) u (conj name u)
    setTransaction (transaction c r u d (set name value data) errs)

trDelete name value = do
  trans <- currentTransaction
  trNoErrs trans
  trans \c r u d data errs . setTransaction
    transaction (delete name c) r (delete name u) (conj name d) (delete name data) errs
#+END_SRC

#+BEGIN_SRC leisure :results dynamic
isSet (setAdd 'a' amtSet)
#+END_SRC
#+ERROR: 0, ReferenceError: err is not defined
#+RESULTS:
: ERROR: 
: 
: Parse error: L_isSet is not defined
: CODE: 
: (
: resolve(L_isSet)(function(){&quot;use strict&quot;;return resolve(L_setAdd)(&quot;a&quot;, L_amtSet);}))
: //# sourceMappingURL=data:application/json;utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImR5bmFtaWMgY29kZSB3aXRoIHNvdXJjZSAyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBLGlCQUFPLGlEQUFPLEdBQVAsRUFBVyxRQUFYLEdBQVAiLCJmaWxlIjoiZHluYW1pYyBjb2RlIHdpdGggc291cmNlIiwic291cmNlc0NvbnRlbnQiOlsiaXNTZXQgKHNldEFkZCAnYScgYW10U2V0KSJdfQ==
: 
: AST: anno(\@filename notebook-39 . isSet (setAdd a amtSet))

* Collaborative code
#+BEGIN_SRC leisure :results def
mungeBubbaNumber env n = do
  debug
  b <- getData 'bubba'
  setData 'bubba' (set 'number' n b)
makeCollaborative mungeBubbaNumber
#+END_SRC

#+BEGIN_SRC leisure :results dynamic
mungeBubbaNumber 28
#+END_SRC


#+BEGIN_SRC leisure :results dynamic
do
  b <- getDataUnsafe 'bubba'
  c = set 'number' 5 b
  print c
#+END_SRC
#+RESULTS:
: {"number":5 "name":"bubba"}
: 

#+NAME: bubba
#+BEGIN_SRC yaml
name: bubba
number: 34
#+END_SRC

#+NAME: fred
#+BEGIN_SRC yaml
name: fred
number: 2
#+END_SRC

#+BEGIN_SRC leisure :results dynamic
set 'a' 1 {}
#+END_SRC
#+RESULTS:
: {"a":1}

#+BEGIN_SRC leisure :results dynamic
do
  i <- for repeat 4
  print i
  i
#+END_SRC
#+RESULTS:
: 0
: 1
: 2
: 3
: [0 1 2 3]


#+BEGIN_SRC leisure :results dynamic
#+END_SRC


* Transactions
Minimalistic collaborative transactions. Since we execute collaborative code on
the master peer, we'd like to execute as much code on the slave peers as possible. So,
we have a transaction object that records the assumptions in a transaction, along with
transaction
